{-# OPTIONS --postfix-projections #-}

open import Library

module Category where

-- Notation for Setoid fields

-- module HomSet {o h e} {Obj : Set o} (HomS : Obj ‚Üí Obj ‚Üí Setoid h e) where

--   module HomSetoid (A B : Obj) = Setoid (HomS A B)

--   open HomSetoid public using ()
--       renaming ( Carrier       to Hom )

--   module _ {A B : Obj} where
--     open HomSetoid A B public using ()
--       renaming ( _‚âà_           to EqH
--                ; isEquivalence to equivH
--                ; refl          to reflH
--                ; sym           to symH
--                ; trans         to transH
--                )

-- Category

record Category o h e : Set (lsuc (o ‚äî h ‚äî e)) where
  field
    Obj  : Set o
    HomS : (A B : Obj) ‚Üí Setoid h e

  open module HomSetoid  (A B : Obj) = Setoid (HomS A B)
    public using ()
    renaming ( Carrier       to Hom )

  open module HomSetoidH {A B : Obj} = HomSetoid A B
    public using ()
    renaming ( _‚âà_           to Eq
             ; isEquivalence to equiv
             ; refl          to reflEq
             ; sym           to symEq
             ; trans         to transEq
             )
  field
    id    : (A : Obj) ‚Üí Hom A A
    comp  : ‚àÄ{A B C} (f : Hom B C) (g : Hom A B) ‚Üí Hom A C

  field
    comp-id-l  : ‚àÄ{A B} {f : Hom A B} ‚Üí Eq (comp (id B) f) f
    comp-id-r  : ‚àÄ{A B} {f : Hom A B} ‚Üí Eq (comp f (id A)) f

    comp-assoc : ‚àÄ{A B C D} {f : Hom C D} {g : Hom B C} {h : Hom A B}
               ‚Üí Eq (comp (comp f g) h) (comp f (comp g h))

    comp-cong  : ‚àÄ{A B C} {f f' : Hom B C} {g g' : Hom A B}
                 ‚Üí Eq f f'
                 ‚Üí Eq g g'
                 ‚Üí Eq (comp f g) (comp f' g')

open Category public

-- Opposite category

op : ‚àÄ{o h e} (C : Category o h e) ‚Üí Category o h e
op C .Obj            = C .Obj
op C .HomS A B       = C .HomS B A
op C .id A           = C .id A
op C .comp f g       = C .comp g f
op C .comp-id-l      = C .comp-id-r
op C .comp-id-r      = C .comp-id-l
op C .comp-assoc     = C .symEq (C .comp-assoc)
op C .comp-cong e e' = C .comp-cong e' e

-- Empty category

‚ä•-cat : ‚àÄ o h e ‚Üí Category o h e
‚ä•-cat o h e .Obj = Lift _ ‚ä•
‚ä•-cat o h e .HomS _ _ = ‚ä•-setoid _ _
‚ä•-cat o h e .id ()
‚ä•-cat o h e .comp ()
‚ä•-cat o h e .comp-id-l  {f = ()}
‚ä•-cat o h e .comp-id-r  {f = ()}
‚ä•-cat o h e .comp-assoc {f = ()}
‚ä•-cat o h e .comp-cong ()

-- Unit category

‚ä§-cat : ‚àÄ o h e ‚Üí Category o h e
‚ä§-cat o h e .Obj        = Lift _ ‚ä§
‚ä§-cat o h e .HomS _ _   = ‚ä§-setoid _ _
‚ä§-cat o h e .id         = _
‚ä§-cat o h e .comp       = _
‚ä§-cat o h e .comp-id-l  = _
‚ä§-cat o h e .comp-id-r  = _
‚ä§-cat o h e .comp-assoc = _
‚ä§-cat o h e .comp-cong  = _

-- Binary product category

_√ó-cat_ : ‚àÄ {o1 h1 e1} (C1 : Category o1 h1 e1)
            {o2 h2 e2} (C2 : Category o2 h2 e2) ‚Üí Category (o1 ‚äî o2) (h1 ‚äî h2) (e1 ‚äî e2)
(C1 √ó-cat C2) .Obj                           = C1 .Obj √ó C2 .Obj
(C1 √ó-cat C2) .HomS (A1 , A2) (B1 , B2)      = √ó-setoid (C1 .HomS A1 B1) (C2 .HomS A2 B2)
(C1 √ó-cat C2) .id (A1 , A2)                  = C1 .id A1 , C2 .id A2
(C1 √ó-cat C2) .comp (f1 , f2) (g1 , g2)      = C1 .comp f1 g1 , C2 .comp f2 g2
(C1 √ó-cat C2) .comp-id-l                     = C1 .comp-id-l , C2 .comp-id-l
(C1 √ó-cat C2) .comp-id-r                     = C1 .comp-id-r , C2 .comp-id-r
(C1 √ó-cat C2) .comp-assoc                    = C1 .comp-assoc , C2 .comp-assoc
(C1 √ó-cat C2) .comp-cong (e1 , e2) (q1 , q2) = C1 .comp-cong e1 q1 , C2 .comp-cong e2 q2

-- I-ary product category

Œ†-cat : ‚àÄ{i o h e} {I : Set i} (C : I ‚Üí Category o h e) ‚Üí Category (i ‚äî o) (i ‚äî h) (i ‚äî e)
Œ†-cat C .Obj               = ‚àÄ i ‚Üí C i .Obj
Œ†-cat C .HomS A B = Œ†-setoid Œª i ‚Üí C i .HomS (A i) (B i)
Œ†-cat C .id A                  i = C i .id (A i)
Œ†-cat C .comp f g              i = C i .comp (f i) (g i)
Œ†-cat C .comp-id-l             i = C i .comp-id-l
Œ†-cat C .comp-id-r             i = C i .comp-id-r
Œ†-cat C .comp-assoc            i = C i .comp-assoc
Œ†-cat C .comp-cong f=f' g=g'   i = C i .comp-cong (f=f' i) (g=g' i)

-- Sets and functions

SET : ‚àÄ o e ‚Üí Category (lsuc (o ‚äî e)) (o ‚äî e) (o ‚äî e)
SET o e .Obj                                    = Setoid o e
SET o e .HomS S T                               = S ‚á® T
SET o e .id S                                   = FEq.id
SET o e .comp                                   = FEq._‚àò_
SET o e .comp-id-l  {f = f}                 x=y = FEq.cong f x=y
SET o e .comp-id-r  {f = f}                 x=y = FEq.cong f x=y
SET o e .comp-assoc {f = f} {g = g} {h = h} x=y = FEq.cong (f FEq.‚àò (g FEq.‚àò h)) x=y
SET o e .comp-cong  f=f' g=g'               x=y = f=f' (g=g' x=y)


-- Finality and terminal objects

module Finality {o h e} (C : Category o h e) where

  record WeakTerminalObject : Set (o ‚äî h ‚äî e) where
    field
      ùüô : C .Obj
      ! : (A : C .Obj) ‚Üí C .Hom A ùüô

  record Terminal (X : C .Obj) : Set (o ‚äî h ‚äî e) where
    field
      ! : ‚àÄ (A : C .Obj) ‚Üí C .Hom A X
      !-unique : ‚àÄ{A} (f : C .Hom A X) ‚Üí C .Eq f (! A)

  record TerminalObject : Set (o ‚äî h ‚äî e) where
    field
      ùüô        : C .Obj
      terminal : Terminal ùüô

  open Terminal           public
  open TerminalObject     public
  open WeakTerminalObject public

open Finality public


-- Initiality and initial objects

module Initiality {o h e} (C : Category o h e) where
  open Finality (op C) public using () renaming
    ( Terminal           to Initial
    ; !                  to ¬ø
    ; !-unique           to ¬ø-unique
    ; ùüô                  to ùüò
    ; terminal           to initial
    ; TerminalObject     to InitialObject
    ; WeakTerminalObject to WeakInitialObject
    )

module InitialityALT {o h e} (C : Category o h e) where

  Initial : (X : C .Obj) ‚Üí Set (o ‚äî h ‚äî e)
  Initial = Terminal (op C)

  module Initial X (init : Initial X) = Terminal {C = op C} init
    renaming (! to ¬ø; !-unique to ¬ø-unique)

  record InitialObject : Set (o ‚äî h ‚äî e) where
    field
      ùüò       : C .Obj
      initial : Initial ùüò

open Initiality public


-- Functor

record Functor {o1 h1 e1} (C1 : Category o1 h1 e1)
               {o2 h2 e2} (C2 : Category o2 h2 e2)
       : Set (o1 ‚äî h1 ‚äî e1 ‚äî o2 ‚äî h2 ‚äî e2) where
  field
    App : C1 .Obj ‚Üí C2 .Obj

  private F = App
  field
    map : ‚àÄ{A B : C1 .Obj}
        ‚Üí C1 .Hom A B
        ‚Üí C2 .Hom (F A) (F B)

  field
    map-id   : ‚àÄ{A}
             ‚Üí C2 .Eq (map (C1 .id A)) (C2 .id (F A))

    map-comp : ‚àÄ{A B C} {f : C1 .Hom B C} {g : C1 .Hom A B}
             ‚Üí C2 .Eq (map (C1 .comp f g)) (C2 .comp (map f) (map g))

    map-cong : ‚àÄ{A B} {f f' : C1 .Hom A B}
             ‚Üí C1 .Eq f f'
             ‚Üí C2 .Eq (map f) (map f')

open Functor public

-- Given a Functor F : C ‚Üí D, the opposite functor op F : op C ‚Üí op D
-- is the same functor with arrows in both categories considered reversed.

module _ {o1 h1 e1} (C1 : Category o1 h1 e1)
         {o2 h2 e2} (C2 : Category o2 h2 e2) where

  opFun : Functor C1 C2 ‚Üí Functor (op C1) (op C2)
  opFun F .App      = F .App
  opFun F .map      = F .map
  opFun F .map-id   = F .map-id
  opFun F .map-comp = F .map-comp
  opFun F .map-cong = F .map-cong

-- Identity functor

idFun : ‚àÄ{o e h} (C : Category o e h) ‚Üí Functor C C
idFun C .App      = Function.id
idFun C .map      = Function.id
idFun C .map-id   = C .reflEq
idFun C .map-comp = C .reflEq
idFun C .map-cong = Function.id

-- Functor composition

compFun : ‚àÄ {o1 o2 o3 e1 e2 e3 h1 h2 h3}
            {C1 : Category o1 e1 h1}
            {C2 : Category o2 e2 h2}
            {C3 : Category o3 e3 h3}
        ‚Üí (F : Functor C2 C3) (G : Functor C1 C2) ‚Üí Functor C1 C3
compFun F G .App A                  = F .App (G .App A)
compFun F G .map f                  = F .map (G .map f)
compFun {C3 = C} F G .map-id        = C .transEq (F .map-cong (G .map-id)) (F .map-id)
compFun {C3 = C} F G .map-comp      = C .transEq (F .map-cong (G .map-comp)) (F .map-comp)
compFun {C3 = C} F G .map-cong f=f' = F .map-cong (G .map-cong f=f')

-- Projection from the product category is a functor

projFun : ‚àÄ {i o e h} {I : Set i} (C : I ‚Üí Category o e h)
        ‚Üí (i : I)
        ‚Üí Functor (Œ†-cat C) (C i)
projFun C i .App A         = A i
projFun C i .map f         = f i
projFun C i .map-id        = C i .reflEq
projFun C i .map-comp      = C i .reflEq
projFun C i .map-cong f=f' = f=f' i

-- Presheaves over C are contravariant functors from C to SET

Presheaf : ‚àÄ o e {o1 h1 e1} (C : Category o1 h1 e1) ‚Üí Set (lsuc (o ‚äî e) ‚äî o1 ‚äî h1 ‚äî e1)
Presheaf o e C = Functor (op C) (SET o e)

-- Empty presheaf

‚ä•-presheaf : ‚àÄ o e {o1 h1 e1} (C : Category o1 h1 e1) ‚Üí Presheaf o e C
‚ä•-presheaf o e C .App _ = ‚ä•-setoid o e
‚ä•-presheaf o e C .map f ._‚ü®$‚ü©_ ()
‚ä•-presheaf o e C .map f .FEq.cong ()
‚ä•-presheaf o e C .map-id ()
‚ä•-presheaf o e C .map-comp ()
‚ä•-presheaf o e C .map-cong eq ()

-- Unit presheaf

‚ä§-presheaf : ‚àÄ o e {o1 h1 e1} (C : Category o1 h1 e1) ‚Üí Presheaf o e C
‚ä§-presheaf o e _ .App _    = ‚ä§-setoid o e
‚ä§-presheaf o e _ .map _    = _
‚ä§-presheaf o e _ .map-id   = _
‚ä§-presheaf o e _ .map-comp = _
‚ä§-presheaf o e _ .map-cong = _

-- Binary presheaf constructions

module _ {o e o1 h1 e1} {C : Category o1 h1 e1}
         (P Q : Presheaf o e C) where

  -- Binary presheaf product

  √ó-presheaf : Presheaf o e C

  √ó-presheaf .App A                         = √ó-setoid (P .App A) (Q .App A)
  √ó-presheaf .map f ._‚ü®$‚ü©_    (p    , q   ) = P .map f ‚ü®$‚ü© p
                                            , Q .map f ‚ü®$‚ü© q
  √ó-presheaf .map f .FEq.cong (p=p' , q=q') = P .map f .FEq.cong p=p'
                                            , Q .map f .FEq.cong q=q'
  √ó-presheaf .map-id          (p=p' , q=q') = P .map-id p=p'
                                            , Q .map-id q=q'
  √ó-presheaf .map-comp        (p=p' , q=q') = P .map-comp p=p' , Q .map-comp q=q'
  √ó-presheaf .map-cong f=f'   (p=p' , q=q') = P .map-cong f=f' p=p'
                                            , Q .map-cong f=f' q=q'

  -- Presheaf exponential

  private
    Fun : (Œî : C .Obj) ‚Üí Setoid (o ‚äî e) (o ‚äî e)
    Fun Œî = P .App Œî ‚á® Q .App Œî

  -- Kripke function space on setoids

  KFun : (Œì : C .Obj) ‚Üí Setoid (o ‚äî e ‚äî o1 ‚äî h1 ‚äî e1) (o ‚äî e ‚äî o1 ‚äî h1 ‚äî e1)
  KFun Œì = ‚àÄ-setoid Œª Œî ‚Üí C .HomS Œî Œì ‚á® (P .App Œî ‚á® Q .App Œî)

  ‚Üí-presheaf : Presheaf (o ‚äî e ‚äî o1 ‚äî h1 ‚äî e1) (o ‚äî e ‚äî o1 ‚äî h1 ‚äî e1) C
  ‚Üí-presheaf .App = KFun
  ‚Üí-presheaf .map f ._‚ü®$‚ü©_     œï   {Œî} ._‚ü®$‚ü©_    g         =  œï   {Œî} ‚ü®$‚ü©       (C .comp f g)
  ‚Üí-presheaf .map f ._‚ü®$‚ü©_     œï   {Œî} .FEq.cong g=g' x=y  =  œï   {Œî} .FEq.cong (C .comp-cong (C .reflEq) g=g') x=y
  ‚Üí-presheaf .map f .FEq.cong  œï=œà {Œî}           g=g' x=y  =  œï=œà {Œî}           (C .comp-cong (C .reflEq) g=g') x=y

  ‚Üí-presheaf .map-id {Œì}{œï}{œà} œï=œà {Œî} {g} {g'}  g=g' x=y  =  œï=œà {Œî}          (C .transEq (C .comp-id-l) g=g') x=y

  ‚Üí-presheaf .map-comp         œï=œà {Œî}           g=g' x=y  =  œï=œà {Œî} (C .transEq (C .comp-cong (C .reflEq) g=g') (C .comp-assoc)) x=y
  ‚Üí-presheaf .map-cong f=f'    œï=œà {Œî}           g=g' x=y  =  œï=œà {Œî} (C .comp-cong f=f' g=g') x=y


  -- ‚Üí-presheaf : Presheaf (o ‚äî e ‚äî o1 ‚äî h1) (o ‚äî e ‚äî o1 ‚äî h1) C
  -- ‚Üí-presheaf .App Œì .Setoid.Carrier = ‚àÄ {Œî} (g : C .Hom Œî Œì) ‚Üí Fun Œî .Setoid.Carrier
  -- ‚Üí-presheaf .App Œì .Setoid._‚âà_ œï œà = ‚àÄ {Œî} (g : C .Hom Œî Œì) ‚Üí Fun Œî .Setoid._‚âà_ (œï g) (œà g)
  -- ‚Üí-presheaf .App Œì .Setoid.isEquivalence .IsEquivalence.refl  {œï}              {Œî} g x=y = Fun Œî .Setoid.refl {œï g} x=y
  -- ‚Üí-presheaf .App Œì .Setoid.isEquivalence .IsEquivalence.sym   {œï}{œà}    eq     {Œî} g x=y = Fun Œî .Setoid.sym  {œï g} {œà g} (eq g) x=y
  -- ‚Üí-presheaf .App Œì .Setoid.isEquivalence .IsEquivalence.trans {œï}{œà}{Œæ} eq eq' {Œî} g x=y = Fun Œî .Setoid.trans {œï g} {œà g} {Œæ g} (eq g) (eq' g) x=y

  -- ‚Üí-presheaf .map f ._‚ü®$‚ü©_    œï   g     = œï   (C .comp f g)
  -- ‚Üí-presheaf .map f .FEq.cong œï=œà g x=y = œï=œà (C .comp f g) x=y
  -- ‚Üí-presheaf .map-id {Œì} {œï} {œà} œï=œà {Œî} g {x} {y} x=y = begin
  --     (œï (C .comp (C .id Œì) g) ‚ü®$‚ü© x) ‚âà‚ü® {!C .comp-id-l !} ‚ü©
  --     (œï g ‚ü®$‚ü© x)                     ‚âà‚ü® œï=œà g x=y ‚ü©
  --     (œà g ‚ü®$‚ü© y)                     ‚àé
  --   where
  --   open SetoidReasoning (Q .App Œî)
  -- ‚Üí-presheaf .map-comp = {!!}
  -- ‚Üí-presheaf .map-cong = {!!}


-- I-ary presheaf product

Œ†-presheaf : ‚àÄ {i o e o1 h1 e1} {I : Set i} {C : Category o1 h1 e1}
           ‚Üí (P : I ‚Üí Presheaf o e C)
           ‚Üí Presheaf (i ‚äî o) (i ‚äî e) C

Œ†-presheaf P .App A = Œ†-setoid Œª i ‚Üí P i .App A
Œ†-presheaf P .map f ._‚ü®$‚ü©_    a  i = P i .map f ‚ü®$‚ü© a i
Œ†-presheaf P .map f .FEq.cong eq i = P i .map f .FEq.cong (eq i)
Œ†-presheaf P .map-id          eq i = P i .map-id          (eq i)
Œ†-presheaf P .map-comp        eq i = P i .map-comp        (eq i)
Œ†-presheaf P .map-cong f=f'   eq i = P i .map-cong f=f'   (eq i)

-- I-ary presheaf sum

Œ£-presheaf : ‚àÄ {i o e o1 h1 e1} {I : Set i} {C : Category o1 h1 e1}
           ‚Üí (P : I ‚Üí Presheaf o e C)
           ‚Üí Presheaf (i ‚äî o) (i ‚äî e) C
Œ£-presheaf P .App A                       = Œ£-setoid Œª i ‚Üí P i .App A
Œ£-presheaf P .map f ‚ü®$‚ü©       (i    , p ) = i    , P i .map f ‚ü®$‚ü© p
Œ£-presheaf P .map f .FEq.cong (refl , eq) = refl , P _ .map f .FEq.cong eq
Œ£-presheaf P .map-id          (refl , eq) = refl , P _ .map-id   eq
Œ£-presheaf P .map-comp        (refl , eq) = refl , P _ .map-comp eq
Œ£-presheaf P .map-cong f=f'   (refl , eq) = refl , P _ .map-cong f=f' eq


-- Natural transformations

module _ {o1 h1 e1} {C : Category o1 h1 e1}
         {o2 h2 e2} {D : Category o2 h2 e2} where

  module _ (F G : Functor C D) where

    record NaturalTransformation : Set (o1 ‚äî h1 ‚äî e1 ‚äî o2 ‚äî h2 ‚äî e2) where
      field
        transformation : ‚àÄ A ‚Üí D .Hom (F .App A) (G .App A)

      field
        naturality : ‚àÄ{A B} (f : C .Hom A B)
                   ‚Üí D .Eq (D .comp (transformation B) (F .map f))
                           (D .comp (G .map f) (transformation A))

    open NaturalTransformation public

    -- The equality on natural transformation ignores the proof of naturality

    nat-setoid : Setoid (o1 ‚äî h1 ‚äî e1 ‚äî o2 ‚äî h2 ‚äî e2) (o1 ‚äî e2)
    nat-setoid .Setoid.Carrier = NaturalTransformation
    nat-setoid .Setoid._‚âà_ œï œà = ‚àÄ A ‚Üí D .Eq (œï .transformation A) (œà .transformation A)
    nat-setoid .Setoid.isEquivalence .IsEquivalence.refl         A = D .reflEq
    nat-setoid .Setoid.isEquivalence .IsEquivalence.sym   eq     A = D .symEq   (eq A)
    nat-setoid .Setoid.isEquivalence .IsEquivalence.trans eq eq' A = D .transEq (eq A) (eq' A)

  -- Identity natural transformation

  idNat : ‚àÄ (F : Functor C D) ‚Üí NaturalTransformation F F
  idNat F .transformation A = D .id (F .App A)
  idNat F .naturality     f = D .transEq (D .comp-id-l) (D .symEq (D .comp-id-r))

  -- Natural transformation compositions

  compNat : ‚àÄ {F G H : Functor C D}
            (œï : NaturalTransformation G H) (œà : NaturalTransformation F G) ‚Üí NaturalTransformation F H
  compNat {F} {G} {H} œï œà .transformation A = D .comp (œï .transformation A) (œà .transformation A)
  compNat {F} {G} {H} œï œà .naturality {A = A} {B = B} f = begin
      (œïB ‚àò œàB) ‚àò F .map f   ‚âà‚ü® D .comp-assoc ‚ü©
      œïB ‚àò (œàB ‚àò F .map f)   ‚âà‚ü® D .comp-cong (D .reflEq) (œà .naturality f) ‚ü©
      œïB ‚àò (G .map f ‚àò œàA)   ‚âà‚ü® D .symEq (D .comp-assoc) ‚ü©
      (œïB ‚àò G .map f) ‚àò œàA   ‚âà‚ü® D .comp-cong (œï .naturality f) (D .reflEq) ‚ü©
      (H .map f ‚àò œïA) ‚àò œàA   ‚âà‚ü® D .comp-assoc ‚ü©
      H .map f ‚àò (œïA ‚àò œàA)   ‚àé
    where
    open SetoidReasoning (D .HomS (F .App A) (H .App B))
    _‚àò_ = D .comp
    œïA = œï .transformation A
    œïB = œï .transformation B
    œàA = œà .transformation A
    œàB = œà .transformation B

-- Functor categories

module _ {o1 h1 e1} (C : Category o1 h1 e1)
         {o2 h2 e2} (D : Category o2 h2 e2) where

  functor-cat : Category _ _ _ -- Category (o1 ‚äî h1 ‚äî e1 ‚äî o2 ‚äî h2 ‚äî e2) (o1 ‚äî h1 ‚äî e1 ‚äî o2 ‚äî h2 ‚äî e2) (o1 ‚äî e2)
  functor-cat .Obj                    = Functor C D
  functor-cat .HomS F G               = nat-setoid F G
  functor-cat .id F                   = idNat F
  functor-cat .comp œï œà               = compNat œï œà
  functor-cat .comp-id-l            A = D .comp-id-l
  functor-cat .comp-id-r            A = D .comp-id-r
  functor-cat .comp-assoc           A = D .comp-assoc
  functor-cat .comp-cong  f=f' g=g' A = D .comp-cong (f=f' A) (g=g' A)


-- Presheaf category

presheaf-cat : ‚àÄ s {o h e}    (let ‚Ñì = s ‚äî o ‚äî h ‚äî e)
               ‚Üí (C : Category o h e)
               ‚Üí Category (lsuc ‚Ñì) (lsuc ‚Ñì) ‚Ñì
presheaf-cat s {o} {h} {e} C = let ‚Ñì = s ‚äî o ‚äî h ‚äî e in

  functor-cat (op C) (SET ‚Ñì ‚Ñì)

-- proj·µ¢ and inj·µ¢ are natural transformations on presheafs

module _ {i o e o1 h1 e1} {I : Set i} {C : Category o1 h1 e1}
         (P : I ‚Üí Presheaf (i ‚äî o) (i ‚äî e) C) where

  -- Projection from presheaf product is natural

  proj-presheaf : ‚àÄ i ‚Üí NaturalTransformation (Œ†-presheaf P) (P i)
  proj-presheaf i .transformation A ‚ü®$‚ü©        p = p i
  proj-presheaf i .transformation A .FEq.cong eq = eq i
  proj-presheaf i .naturality f               eq = P i .map-cong (C .reflEq) (eq i)

  -- Injection into presheaf sum is natural

  inj-presheaf : ‚àÄ i ‚Üí NaturalTransformation (P i) (Œ£-presheaf P)
  inj-presheaf i .transformation A ._‚ü®$‚ü©_     p = i , p
  inj-presheaf i .transformation A .FEq.cong eq = refl , eq
  inj-presheaf i .naturality f               eq = refl , P i .map-cong (C .reflEq) eq

-- -}
-- -}
-- -}
-- -}
-- -}
-- -}
