\nonstopmode
%% For double-blind review submission
\documentclass[acmsmall%acmlarge%,review,anonymous
]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission
%\documentclass[acmlarge,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission
%\documentclass[acmlarge]{acmart}\settopmatter{}

% For having two versions of a paper in one file.
% Stuff that does not fit into the short version can be encosed in \LONGVERSION{...}
\ifdefined\LONGVERSION
  \relax
\else
% short version:
\newcommand{\LONGVERSION}[1]{}
\newcommand{\SHORTVERSION}[1]{#1}
% % long version:
% \newcommand{\LONGVERSION}[1]{#1}
% \newcommand{\SHORTVERSION}[1]{}
% \newcommand{\SHORTVERSION}[1]{BEGIN~SHORT\ #1 \ END~SHORT}
\fi
\newcommand{\LONGSHORT}[2]{\LONGVERSION{#1}\SHORTVERSION{#2}}
\newcommand{\SHORTLONG}[2]{\SHORTVERSION{#1}\LONGVERSION{#2}}
\newcommand{\EXTENDED}[1]{}

%\usepackage[right]{showlabels}\renewcommand{\showlabelfont}{\small\ttfamily\color{gray}}

% controlling flushleft/center for math displays
% http://www.golatex.de/wechsel-zwischen-leqno-und-reqno-fleqn-uvm-t2488.html
\makeatletter
%\def\leqn{\tagsleft@true}
%\def\reqn{\tagsleft@false}
\def\fleq{\@fleqntrue\let\mathindent\@mathmargin \@mathmargin=\leftmargini}
\def\cneq{\@fleqnfalse}
\g@addto@macro{\endsubequations}{\addtocounter{equation}{-1}}
\makeatother

\usepackage{mathtools} %mathrlap
\usepackage[all]{xy}

\usepackage[cal=boondoxo]{mathalfa}
\usepackage{calc} % \widthof

\usepackage{latex/agda}

% NO EFFECT:
% \renewcommand{\AgdaOperator}    [1]
%     {\AgdaNoSpaceMath{\AgdaFontStyle{\textcolor{AgdaOperator}{\mathbf{#1}}}}}

%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format should change 'acmlarge' to
%% 'sigplan,10pt'.


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption


\makeatletter\if@ACM@journal\makeatother
%% Journal information (used by PACMPL format)
%% Supplied to authors by publisher for camera-ready submission
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2017}
\acmMonth{1}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\else\makeatother
%% Conference information (used by SIGPLAN proceedings format)
%% Supplied to authors by publisher for camera-ready submission
\acmConference[PL'17]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2017}{New York, NY, USA}
\acmYear{2017}
\acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\fi

\makeatletter
\newenvironment{proof*}[1][\proofname]{\par
  \normalfont \topsep6\p@\@plus6\p@\relax
  \trivlist
  \item[\@proofindent\hskip\labelsep
        {\@proofnamefont #1\@addpunct{.}}]\ignorespaces
}{%
  \endtrivlist\@endpefalse
}
\makeatother

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission
\setcopyright{none}             %% For review submission
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear


% \acmBadgeR[http://icfp17.sigplan.org/track/icfp-2017-Artifacts]{artifact_evaluated-functional.png}
\acmBadgeR[http://icfp17.sigplan.org/track/icfp-2017-Artifacts]{artifact_evaluated-reusable.png}
%\acmBadgeL[http://icfp17.sigplan.org/track/icfp-2017-Artifacts]{artifact_available.png}
\acmBadgeL[https://hackage.haskell.org/package/Sit]{artifact_available.png}

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations

\input{macros}


\begin{document}

%% Title information
\title[NbE for Sized Types]{Normalization by Evaluation for Sized Dependent Types}
%\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Andreas Abel}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{0000-0003-0420-4492}             %% \orcid is optional
\affiliation{
  \department{Department of Computer Science and Engineering}
  \institution{Gothenburg University}
  \streetaddress{Rännvägen 6b}
  \city{Göteborg}
%  \state{State1}
  \postcode{41296}
  \country{Sweden}
}
\email{andreas.abel@gu.se}          %% \email is recommended

%% Author with two affiliations and emails.
\author{Andreas Vezzosi}
\affiliation{
  \department{Department of Computer Science and Engineering}
  \institution{Chalmers}
  \streetaddress{Rännvägen 6b}
  \city{Göteborg}
%  \state{State1}
  \postcode{41296}
  \country{Sweden}
}
\email{vezzosi@chalmers.se}          %% \email is recommended

\author{Theo Winterhalter}
\affiliation{
  \institution{École Normale Supérieure de Cachan}
}
\email{theo.winterhalter@gmail.com}

%% Paper note
%% The \thanks command may be used to create a "paper note" ---
%% similar to a title note or an author note, but not explicitly
%% associated with a particular element.  It will appear immediately
%% above the permission/copyright statement.
%\thanks{with paper note}                %% \thanks is optional
                                        %% can be repeated if necesary
                                        %% contents suppressed with 'anonymous'


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Sized types have been developed to make termination checking more perspicuous, more powerful, and more modular by integrating termination into type checking.  In dependently-typed proof assistants where proofs by induction are just recursive functional programs, the termination checker is an integral component of the trusted core, as validity of proofs depend on termination.  However, a rigorous integration of full-fledged sized types into dependent type theory is lacking so far.  Such an integration is non-trivial, as explicit sizes in proof terms might get in the way of equality checking, making terms appear distinct that should have the same semantics.

In this article, we integrate dependent types and sized types with higher-rank size polymorphism, which is essential for generic programming and abstraction.  We introduce a size quantifier $\forall$ which lets us ignore sizes in terms for equality checking, alongside with a second quantifier $\Pi$ for abstracting over sizes that do affect the semantics of types and terms.  Judgmental equality is decided by an adaptation of normalization-by-evaluation for our new type theory, which features \emph{type shape}-directed reflection and reification.  It follows that subtyping and type checking of normal forms are decidable as well, the latter by a bidirectional algorithm.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
 \begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003752.10003790.10011740</concept_id>
<concept_desc>Theory of computation~Type theory</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003752.10010124.10010125.10010130</concept_id>
<concept_desc>Theory of computation~Type structures</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003752.10010124.10010138.10010142</concept_id>
<concept_desc>Theory of computation~Program verification</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10003752.10010124.10010131.10010134</concept_id>
<concept_desc>Theory of computation~Operational semantics</concept_desc>
<concept_significance>100</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Type theory}
\ccsdesc[500]{Theory of computation~Type structures}
\ccsdesc[300]{Theory of computation~Program verification}
\ccsdesc[100]{Theory of computation~Operational semantics}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{dependent types, eta-equality, normalization-by-evaluation, proof irrelevance, sized types, subtyping, universes.}  %% \keywords is optional
%\keywords{Dependent Types, Normalization-by-Evaluation, Proof Irrelevance, Sized Types, Subtyping, Universes}  %% \keywords is optional


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}
\label{sec:intro}

% higher rank sized types
% Church-style and curry style
% The problem of size irrelevance
% Our solution (application rule)
% Shape-irrelevance middle ground between Pfenning, ICC,
% Agda's function types


Dependently-typed programming languages and proof assistants, such as Agda~\citeyearpar{agdawiki} and Coq~\cite{inria:coq86}, require programs to be total, for two reasons.  First, for consistency:  since propositions are just types and proofs of a proposition just programs which inhabit the corresponding type, some types need to be empty; otherwise, each proposition would be true.  However, in a partial language with general recursion, each type is inhabited by the looping program $f = f$.  Secondly, totality is needed for decidability of type checking.  Since types can be the result of a computation, we need computation to terminate during type checking, even for \emph{open terms}, \ie, terms with free variables.

% \cite{boveKraussSozeau:mscs16}
Consequently, the aforementioned languages based on Type Theory come with a termination checker, which needs to reject all non-terminating programs, and should accept sufficiently many terminating programs to allow the user to express her algorithms.  In current termination checkers, programs are required to terminate by structural descent \cite{gimenez:guardeddefinitions}; the structural order may be extended to a lexicographic \cite{abelAltenkirch:jfp02} or size-change termination criterion \cite{jones:sizeChange,wahlstedt:PhD}.  This is not a fundamental limitation, since Type Theory allows many functions to be expressed in a structurally recursive manner, if needed by the help of a well-founded relation \cite{nordstrom:genrec}, inductive domain predicates \cite{boveCapretta:mscs05}, or inductive descriptions of the function graph \cite{bove:entcs09}.  However, the syntactic termination check is very sensitive to reformulations of the program and hostile to abstraction \cite{abel:fics12}.

Sized types \cite{hughesParetoSabry:popl96} delegate the checking for structural descent to the type system by annotating data types with a size parameter.  The type checker can then ensure that in recursive calls the size goes down, certifying termination.  In the simplest setting \cite{gimenez:typeBased,abel:lmcs07}, the size is just an upper bound on the tree height of the data structure; however, more sophisticated size annotations have also been considered \cite{xi:terminationHOSC,blanqui:rta04}.  Most sized type systems are non-dependent \cite{amadio:guardcondition,abelPientka:jfp16,bartheGregoireRiba:lernet08,bartheGregoireRiba:csl08,blanquiRiba:lpar06,dalLagoGrellois:esop17}, yet the combination of sized and dependent types has been studied as well \cite{blanqui:csl05,bartheGregoirePastawski:lpar06,gregoireSacchini:lpar10,sacchini:lics13,sacchini:flops14}.  However, to the best of our knowledge, no study combines \emph{higher-rank size polymorphism} with full-fledged dependent types.\footnote{\citet{xi:terminationHOSC} has first-class size polymorphism, but only indexed types, no universes or large eliminations.}

Higher-rank size quantification takes termination checking to the next
level; it is necessary for abstraction and generic programming.  For
instance, it allows us to write a generic tree traversal which applies
a user-given preprocessor on subtrees before recursively descending
into these trees, and a postprocessor after surfacing from the
descent.
The condition is that preprocessing does not increase the size of the subtree; otherwise, termination could not be guaranteed.  Concretely, assume a type $\tT\,i$ of trees of size $< i$ with a constructor $\tnode : \forall i.\, \List\,(\tT\,i) \to \tT\,(i+1)$ which takes a finite list of subtrees to form a new tree.
In the following definition of $\ttrav$, the preprocessing $\vpre : \forall i.\, \tT\,i \to \tT\,i$ can be safely applied to input tree $t$ because the type of $\vpre$ bounds the size of $\vpre\,t$ by the size of $t$.
In case $\vpre\,t = \tnode\,\vts$, the trees in the list $\vts$ are still guaranteed to be of strictly smaller size than $t$, thus, the recursive call to $\ttrav$, communicated via the $\tmap$ function for lists, is safe.
\[
\begin{array}{l}
  \ttrav : (\vpre : \forall i.\, \tT i \to \tT i)\; (\vpost : \tT \infty \to \tT \infty) \to \forall i.\, \tT\,i \to \tT\,\infty
  \\
  \ttrav \; \vpre \; \vpost \; t = \vpost\;(\tcase\;\vpre\,t\;\tof \, \{ \, \tnode\,\vts \to \tnode\,(\tmap \; (\ttrav \, \vpre \, \vpost) \; \vts)\, \})
\end{array}
\]
The display shows the \emph{Curry}-style program as provided by the user, but state-of-the-art type checkers elaborate the program from surface syntax into an internal \emph{Church}-style syntax with explicit type abstractions and type applications.\footnote{Agda, Coq, Idris~\cite{brady:jfp13}, and Haskell~\cite{sulzmannChakravartyPeythonJonesDonnelly:tldi07} all have Church-style internal languages.}  With implicit type and size applications elaborated, $\ttrav$ would look as follows:
\[
\begin{array}{l}
  \ttrav \; \vpre \; \vpost \; i\; t = \vpost\;(\tcase\;\vpre\,i\,t\;\tof \, \{ \, \tnode\,j\,\vts \to \tnode\,\infty\,(\tmap \; (\tT\,j) \; (\tT\,\infty) \; (\ttrav \, \vpre \, \vpost \, j) \; \vts) \})
\end{array}
\]
Church-style syntax is the basis for all program analyses and transformations to follow and should be considered as the \emph{true} syntax.
However, from a dependent-type perspective, explicit size applications
in terms can be problematic when the type checker compares terms for
equality---which is necessary as types can depend on values.  Inferred
sizes may not be unique, as we have subtyping $\tT\,i \leq \tT\,j$ for
$i \leq j$: we can always weaken an upper bound.  For instance, given
$\vts : \List\,(\tT\,i)$, any of the terms
$\tnode\,i\,\vts$, $\tnode\,(i+1)\,\vts$, $\dots$, $\tnode\,\infty\,\vts$
%$\tnode\,i\,\vts$ or $\tnode\,(i+1)\,\vts$ or $\dots$ or $\tnode\,\infty\,\vts$
has type
$\tT\,\infty$.  Yet semantically, all these trees are equal,
thus, the syntactic equality check should ignore the size argument to
$\tnode$.  Similarly, in the application $\vpre\,i\,t$ the size
argument $i$ should be ignored by the equality check.  Yet
$\vpre\,i : \tT\,i \to \tT\,i$ and $\vpre\,j : \tT\,j \to \tT\,j$ have
different types for $i \not= j$, and moreover these function types are
not in the subtyping relation due to the mixed-variant occurrence of the
size parameter.  It seems that during equality checking we have to
consider terms of different types, at least for a while.  Once we apply
$\vpre\,i$ and $\vpre\,j$ to the same tree $t : \tT\,k$, which
determines $i = j = k$, we are back to safety.  However, allowing
types to differ during an equality check needs special consideration, especially
when the equality-check is type directed.

Consider the analogous situation for the polymorphic lambda calculus System~F, be it the predicative variant or not, extended by a unit type $\One$.
For Church-style, we can give a type-directed $\beta\eta$-equality test which equates all terms at the unit type.  The most interesting rules are the $\eta$-rules for unit and function type and the congruence rule for type application:
\begin{gather*}
\renewcommand{\jchk}{:}
\renewcommand{\jinf}{:}
  \ru{}{\Gamma \der t = t' \jchk \One}
\qquad
  \ru{\Gamma, x \of A \der t\,x = t'\,x \jchk B
    }{\Gamma \der t = t' \jchk A \to B}
\qquad
  \ru{\Gamma \der t = t' \jinf \forall X. B
    }{\Gamma \der t\,A = t'\,A \jinf B[A/X]}
\end{gather*}
The Curry-style version replaces the last conclusion by $\Gamma \der t = t' : B[A/X]$ where the type $A$ to instantiate $X$ has to be guessed.  However, in Curry-style more terms are equated than in Church-style, as for instance the Church-style terms $t\,A\,(\lambda x \of A.\, x)$ and $t\,B\,(\lambda x \of B.\, x)$ map to the same Curry-style term $t\,(\lambda x.\,x)$.  How would we adapt the algorithm for Church-style such that it equates all terms that are equal in Curry-style?  The conclusion of the last rule could be changed to $\Gamma \der t\,A = t'\,A' : B[A/X]$, but then the second term $t'\,A'$ does not have the ascribed type $B[A/X]$, and $\eta$-laws applied to this term would be unsound.  For instance, the algorithm would yield $t\,\One\,x = t\,(A \to A)\,y$ even for $x \not= y$.
We could also consider a heterogeneous check $(\Gamma \der t : A) = (\Gamma' \der t' : A')$ where each term is paired with its own type and context, but this leaves us with the dilemma of explaining the meaning of this judgement when $A$ and $A'$ are incompatible.

Does the literature offer a solution to this problem?
In fact, a Church-style calculus with Curry-style equality has been studied before, it is ICC$^*$ \cite{barrasBernardo:fossacs08,mishraLingerSheard:fossacs08} based on Miquel's Implicit Calculus of Constructions \citeyearpar{miquel:tlca01}.
In ICC$^*$, equality is checked by erasing all type abstractions and applications, and comparing the remaining untyped terms for $\beta\eta$-equality.  While this works for $\eta$-laws that can be formulated on untyped terms, such as $\eta$-contraction of functions $\lambda x.\,t\,x \redeta t$ (when $x$ not free in $t$), it does not extend to type-directed $\eta$-laws such as extensionality for the unit type.  Further, ICC$^*$ is not a type theory formulated with a typed equality judgement, which makes it hard to define its models \cite{miquel:lics00}---we wish not to go there, but stay within the framework of Martin-L\"of Type Theory \citeyearpar{martinlof:predicative75}.

%How can we have our cake and eat it, too?
Now, if the types of compared Curry-style terms are not equal, can they be sufficiently related to give a proper meaning to the algorithmic equality judgement?
It has already been observed that for a type-directed equality check the precise type is not necessary, a \emph{shape} or \emph{skeleton} is sufficient.  The skeleton informs the algorithm whether the terms under comparison are functions, inhabitants of the unit type, or something else, to possibly apply the appropriate $\eta$-law.  For the Logical Framework (LF), the simplest dependent lambda-calculus, the skeletons are simple types that can be obtained from the original dependent types by erasing the dependencies:  dependent function types map to non-dependent ones and indexed data types to simple data types. \citet{harperPfenning:equivalenceLF} present such an equality check for LF which is directed by simple types, and their technique should scale to other type theories that admit dependency erasure.\footnote{For instance, the types of the Calculus of Constructions erase to F$^\omega$-types \cite{geuvers:shortFlexibleSNCC}, and the latter could be used to direct the equality check. \citet{lovasPfenning:lmcs10} consider also \emph{refinement types for logical frameworks} which can be erased to simple types.}

By \emph{large eliminations} \cite{werner:types92} we refer to types computed by case distinction over values; they occur
in type theories that feature both universes and data types.
In the presence of large eliminations, dependency erasure fails, and it is not clear what the skeleton of a dependent type should be.  For instance consider the type $\funT n \NN \underbrace{A \to \dots \to A}_n \to A$ of $n$-ary functions; its shape is dependent on the value of $n$, thus cannot be determined statically.  Thus, the ``skeleton'' idea is also not directly applicable.

Going beyond the standard syntax-directed equality check, there is a
technique that can deal with dynamic $\eta$-expansion.  It is a
type-directed normalization function inspired by
normalization-by-evaluation (NbE) that computes $\eta$-long normal
forms \cite{bergerSchwichtenberg:lics91,danvy:tdpe}.  We can check the
computed normal forms for identity and, thus, decide definitional
equality.  NbE has proven to be a robust method to decide equality in
powerful type theories with non-trivial $\eta$-laws.  It scales to
universes and large eliminations \cite{abelCoquandDybjer:lics07},
topped with singleton types or proof irrelevance
\cite{abelCoquandPagano:lmcs11}, and even impredicativity
\cite{abel:flops10}.  At its heart there are reflection $\up T$ and
reification $\down T$ functions directed by type $T$ and orchestrating
just-in-time $\eta$-expansion.  Reflection $\up T x$ maps variables
$x$ into the realm of values of type $T$ and lets us compute with
open terms.  Reification $\down T a$ takes a value $a$ of type $T$ and
computes its long normal form.  For instance, the normal form of a
closed function $f : U \to T$ would be
$\lambda x.\,\down{T} (f\,(\up U x))$, and for its dependently-typed
variant $f : \funT x U T[x]$ it would be
$\lambda x.\,\down{T[\up U x]} (f\,(\up U x))$.

% In the solution we present in this article, we do not introduce a new syntax for shapes, just a relation $T \shape S$ stating that type $S$ qualifies as shape for type $T$.  We use a normalization function inspired by normalization-by-evaluation (NbE) that computes the $\eta$-long normal form of the terms under comparison, which we then check for identity.

The central technical observation is that reflection and reification do not need the precise type $T$, they work the same for any \emph{shape} $S$ of $T$.
We managed, while not introducing a new syntax for shapes, to define a relation $T \shape S$ on type values stating that type $S$ qualifies as shape for type $T$.
Shapes unfold dynamically during reflection and reification.
For example, when reflecting a variable $x$ into the polymorphic function type $\forall i.\, F\,i$ where $F\,i = \Nat\,i \to \Nat\,i$, we obtain
$(\up{\forall i.\/ F\,i}x)\,i = \up{F\,i} (x\,i)$ for size $i$ and
$(\up{\forall i.\/ F\,i}x)\,j = \up{F\,j} (x\,j)$ for size $j$.  The new types $F\,i$ and $F\,j$ we reflect at are no longer equal (and they are not subtypes of each other), but they still have the same shape, $\Nat\_ \to \Nat\_$.  This means they will still move in lock-step in respect to $\eta$-expansion, which is sufficient to prove NbE correct for judgmental equality.
We call the enabling property of $F$ \emph{shape irrelevance}, meaning that for any pair $i$, $j$ of legal arguments, $F\,i$ and $F\,j$ have the same shape.  Whenever we form a irrelevant function type $\forall x \of U.\, T[x]$, we require $T[x]$ to be shape-irrelevant in $x$.  This is the middle ground between ICC$^*$, where no restriction is placed on $T$ but $\eta$ for unit types is out of reach (at least for the moment), and Pfenning's \citeyearpar{pfenning:lics01} irrelevance modality, adapted to full dependent types by \citet{abelScherer:types10}, which requires $T$ to be irrelevant in $x$ and, thus, has type equality $T[i] = T[j]$.

For the time being, we do not (and cannot) develop a general theory of shape irrelevance.  We confine ourselves to size-irrelevant function types $\forall i.\, T[i]$.  This relieves us from defining a special shape-irrelevance modality, since all size-indexed types $T[i]$ \emph{are} shape irrelevant in $i$, simply because there is no case distinction on size, and sizes appear relevantly only under a sized type constructor such as $\tNat$.  Our technique would not extend to the polymorphic types $\forall X.\,B[X]$ of System~F.  Even though there is no case distinction on types, shape irrelevance of $B[X]$ fails in general, as $X$ could appear as a type on the top-level, e.g. in %$B[X] = X$ or
$B[X] = X \to X$, and then $B[\One]$ and $B[A \to A]$ would have distinct shapes.

To summarize, this article makes the following novel contributions:
\begin{enumerate}

\item We present the first integration of a dependent type theory with higher-rank size polymorphism.
Concretely, we consider a type theory \`a la Martin-L\"of with dependent function types, cumulative universes, subtyping, a judgmental equality with $\eta$-laws, a sized type of natural numbers and two size quantifiers: an irrelevant one $(\forall)$ for binding of sizes in irrelevant positions, and a relevant one $(\Pi)$ for binding of sizes in shape-irrelevant positions (Section~\ref{sec:syntax}).  Judgmental equality features a ``Curry-style'' rule for irrelevant size application which ignores the size arguments, and consequently, the corresponding typing rule will also ignore the size argument.
(In the following rules, $a$, $a'$, and $b$ stand for arbitrary size expressions.)
\[
\ru{\Gamma \der t = t' : \forall i.\, T
  }{\Gamma \der t\,a = t'\,a' : T[b/i]}
\qquad
\ru{\Gamma \der t : \forall i.\, T
  }{\Gamma \der t\,a : T[b/i]}
\qquad
\qquad
\ru{\Gamma \der t = t' : \Pi i.\, T
  }{\Gamma \der t\,a = t'\,a : T[a/i]}
\qquad
\ru{\Gamma \der t : \Pi i.\, T
  }{\Gamma \der t\,a : T[a/i]}
\]
Our substitution theorem distinguishes term- from type-side substitutions.

\item We adapt normalization-by-evaluation (NbE) to sized types and size quantification and show that it decides judgmental equality (sections~\ref{sec:sem} and \ref{sec:soundnbe}).  The novel technical tool is a relation $T \shape S$ which relates a type $T$ to its possible shapes $S$.  This approximation relation allows reflection and reification at size-polymorphic types $\forall i.\, T$.
As usual for the meta-theory of Type Theory with large eliminations, the machinery is involved, but we just require the usual two logical relations:  First, a PER model to define the semantics of types and prove the completeness of NbE (Section~\ref{sec:sem}).  Secondly, a relation between syntax and semantics to prove soundness of NbE (Section~\ref{sec:soundnbe}).

\item We present an bidirectional type checking algorithm \cite{coquand:type} which takes the irrelevant size argument as reliable hint for the type checker (sections~\ref{sec:asub} and \ref{sec:tycheck}).  It is complete for normal forms which can be typed with the restricted rule for $\forall$-elimination:
\[
\ru{\Gamma \der t : \forall i.\, T
  }{\Gamma \der t\,a : T[a/i]}
\]
The algorithm employs the usual lazy reduction for types, \ie, just-in-time weak-head evaluation, in type and sub-type checker
\cite{huet:wsscs89}.  In this, it improves on \citet{fridlenderPagano:tlca13} which instruments full normalization (NbE) at every step.
\end{enumerate}
This article is accompanied by a prototypical type checker \href{https://hackage.haskell.org/package/Sit}{\texttt{Sit}} which implements the type system and type checking algorithm as described in the remainder of the paper.
But before going into the technical details, we will motivate our type system from a practical perspective: reasoning about programs involving sized types in Agda.


\section{Size Irrelevance in Practice}
\label{sec:informal}

In this section, we show how the lack of size irrelevance prevents us from reasoning naturally about programs involving sized types in Type Theory.  We focus on Agda, at the time of writing the only mature implementation of Type Theory with an experimental integration of sized types.

\input{latex/SubDiagError}

\input{latex/SubDiag}

\section{A Type System With Irrelevant Size Application}
\label{sec:syntax}

In this section, we give the syntax and the \emph{declarative} typing, equality, and subtyping judgements.  The typing relation $\Gamma \der t : T$ will \emph{not} be decidable; instead, we present algorithmic typing $\Gamma \der t \jchk T$ in Section~\ref{sec:tycheck}.  However, equality and subtyping will be decidable for well-formed input, see sections~\ref{sec:sem}--\ref{sec:asub}.

We present our type theory as (domain-free) \emph{pure type system} \cite{barendregt:lambdacube} with extra structure.
The \emph{sorts} $s$ are drawn from an infinite predicative hierarchy of universes $\Set[\ell]$ for $\ell \in \NN$.  Universes provide us with polymorphism and the capability to define types by recursion on values.  Whether we have just two universes $\Set[0]$ and $\Set[1]$ or infinitely many, does not matter for the technical difficulty of the meta theory.  The present setup have the advantage that every sort has again a sort since $\Set[\ell] : \Set[\ell+1]$, thus, we do not have to introduce a separate judgement $\Gamma \der T$ for well-formedness of types, we can define it as $\exists s.\ \Gamma \der T : s$.

\begin{figure}[htbp]
\centering
\hrulefill
\[
\begin{array}{l@{~}l@{~\,}l@{~\,}r@{~\,}l@{\quad}l}
\Sort & \ni & s
    & ::= & \Set[\ell] ~(\ell \in \NN)& \mbox{sort (universe)} \\
% \Ann & \ni & \star & ::= & \erased \mid \nonstrict \mid \noterased & \mbox{annotation (irrelevant, shape-irrelevant, relevant)}\\
\Ann & \ni & \star & ::= & \erased \mid \noterased & \mbox{annotation (irrelevant, relevant)}\\
\Exp & \ni & t,u,T,U
    & ::= & w \mid t\,e & \mbox{expressions} \\
\Whnf & \ni & w, W
    & ::= & n \mid s \mid \Size \mid \epiT U T % \mid \piSizeT T
    % \mid \forallT T
    \mid \lambda t% & \mbox{functions} \\ &&
    \mid \Nat a \mid c & \mbox{weak head normal forms} \\ % \mbox{natural numbers} \\
\Data & \ni & c
   & ::= & \zero a \mid \suc a t & \mbox{constructed data} \\
\NeExp & \ni & n
    & ::= & \ind i \mid n \, e & \mbox{neutral expressions} \\
\Elim & \ni & e
    & ::= & t \mid a \mid \ann a \mid \case[\ell] T {t_z} {t_s} \mid \fix[\ell] T t & \mbox{eliminations} \\
\SizeExp & \ni & a,b & ::= & \infty \mid o \mid \ind i + o ~(o \in \NN) & \mbox{size expressions} \\
\Cxt & \ni & \Gamma, \Delta & ::= & \cempty \mid \erext[\noterased] \Gamma T \mid \erext \Gamma \Size
   & \mbox{contexts} \\
\Subst & \ni & \eta,\rho,\sigma,\tau,\xi & ::= & \sempty \mid (\sigma,t)
  & \mbox{substitutions} \\
\end{array}
\]
\hrulefill
\vspace{-2ex}
  \caption{Syntax.}
  \label{fig:syntax}
\end{figure}

For the expression syntax (see Fig.~\ref{fig:syntax}), we use
de~Bruijn \citeyearpar{deBruijn:nameless} indices $\ind i$ to
represent variables.  The index $i \in \NN$ points to the $i$th
enclosing binder of variable $\ind i$.  Binders are lambda abstraction
$\lambda t$ and dependent function types $\epiT U T$, which bind the
$0$th index in $t$ and $T$, resp.  For instance, the term
$\lambda x.\,x\,(\lambda z.\,z)\, (\lambda y.\,x\,y)$
with named variables $x,y,z$ has de Bruijn representation
$\lambda.\,\ind 0\,(\lambda.\, \ind 0)\,(\lambda.\,\ind 1\,\ind0)$.

The notation $\epiT U T$ is an
umbrella for three kinds of function types, where
$\evar \in \{ \erased, \noterased \}$ is a relevance annotation
borrowed from \citet{pfenning:lics01}. $\erpiT[\noterased] U T$ is
the ordinary dependent function type, $\erpiT[\noterased] \Size T$ is
relevant size quantification, and $\erpiT \Size T$ is irrelevant size
quantification.  We omit the ``$\noterased$''-markers
from $\Pi$ by default (and also in contexts $\Gamma$)
and write $\forallT T$ for $\erpiT \Size T$.
%
Examples for relevant size quantification $\piT \Size T$ are
$\piT \Size {\Set[0]}$ and
$\piT \Size {\piT {(\Nat{\ind 0})} {\Set[0]}}$.
In a syntax with named variables and non-dependent function type
they could be written as $\Size \to \Set[0]$ and
$\funT z \Size \Nat z \to \Set[0]$, resp.
%
An instance of irrelevant
quantification $\forall T$ would be
$\forall.\, \piT {(\Nat{\ind 0})} {(\Nat{\ind 1})}$
which is
$\forall z.\, \Nat z \to \Nat z$
in a named syntax.
Herein, $\Nat z$ denotes the type of natural numbers below $z$. The
expression $\Size$ is a possible instance of $U$ in $\epiT U T$, or a
possible type of a variable in a typing context $\Gamma$, but not a
first-class type, \ie, we cannot construct our own functions on sizes.

Canonical natural numbers $c$ are constructed by $\zero a$ and $\suc a t$.
A size expression $a$ is either a constant $o \in \NN$, a variable
$\ind i + o$ possibly with increment $o$, or the limit ordinal
$\infty$ which stands for $\omega$.  The size argument $a$ in the
constructors $\tzero$ and $\tsuc$
is a suggestion for the type checker but bears no
semantic significance.  For example, in the declarative typing
presented here, we can have $\der \zero 5 : \Nat 1$.
In the algorithmic typing however, $\der \zero 5 \jchk \Nat 1$ will be an error.
Note, however, that $\der \zero a : \Nat 0$ is impossible for any $a$,
as $\tzero$ is not strictly below $0$
(when both term and size are interpreted as natural numbers).

Regular application $t\,u$, relevant size application
$t\,a$, and irrelevant size application $t \, \ann a$ eliminate
functions $t$ and are subsumed under the form $t\,e$ with $e ::= u \mid a \mid \ann a$.
We have two further eliminations, which make sense when $t$ stands for a natural number.
These are case distinction
$e = \case[\ell] T {t_z}{t_s}$ and recursive function application
$e' = \fix[\ell'] {T'} {t'}$.
Application of case distinction $\zero a \, e$ will
reduce to the zero-branch $t_z$, and application $(\suc a t) \,e$ to the
instantiation $t_s\,t$ of the successor branch.  The type annotation
$T$ in $\tcase$ allows us to infer the type of the whole case
statement $t\,e$ as $T\,t$.  The function call $c\,e'$ for a canonical
number $c$ and elimination $e' = \fix[\ell'] {T'} {t'}$
reduces to $t'\,(\lambda x.\,x\,e')\,c$ where we allowed
ourselves the use of a named abstraction in the presentation to the
reader.  The unfolding of fixed-points is thus restricted to
application to canonical numbers; this is the usual reduction strategy
which converges for terminating functions \cite{gimenez:typeBased}.

%We write $\sigma$ and $\tau$ for substitutions, which are lists of terms, and
For ordinary $\beta$-reduction we employ \emph{substitutions}
$\sigma$.  These are simply lists of terms that provide one term as
replacement for each free de Bruijn index in a term $t$. We write
\fbox{$t \sigma$} for the application of substitution $\sigma$ to term
$t$ which is defined as usual.  Let \emph{lifting} \fbox{$\slift^k_m$}
be the substitution $(\ind{k+m-1},\dots,\ind{k+1},\ind k)$ which
accepts a term with $m$ free indices and increases each of them by
$k$.  We write $\slift_m$ for the lifting $\slift^1_m$ and
\fbox{$\sid_m$} for the identity substitution $ \slift^0_m$. In
general, we refer to liftings by letter $\xi$.
%
The substitution \fbox{$[u]_m$}${} = (\sid_m, u)$ replaces free index
$\ind 0$ by term $u$ and decrements the other $m$ free indices by
$1$. We drop subscript $m$ from liftings and substitutions when clear from the context.
%
Substitution composition \fbox{$\sigma\tau$} is the pointwise
application of substitution $\tau$ to the list of terms $\sigma$.  In
the proofs to follow, we freely use the following identities:
\begin{gather*}
  t\,\sid \equiv t
\qquad
  (t\sigma)\tau \equiv t(\sigma\tau)
\qquad\quad
  \sigma\, \sid \equiv \sigma
\qquad
  \sid\, \tau \equiv \tau
\qquad
  (\rho\sigma)\tau \equiv \rho(\sigma\tau)
\\
  \ind 0 (\sigma,t) \equiv t
\qquad
  \slift(\sigma,t) \equiv \sigma
\qquad\quad
  [t]\sigma \equiv (\sigma, t\sigma)
\qquad
  \slift[t] \equiv \sid
%  (\sigma\slift)[t] \equiv \sigma
\end{gather*}

As already done in some examples, we may use a named dependent
function type notation as syntactic sugar for the corresponding de
Bruijn representation.  For instance,
$\funT z \Size \Nat z \to \Set[\ell]$ is sugar for
$\piT \Size \piT {(\Nat\,\ind 0)} \Set[\ell]$.  We abbreviate this
type by \fbox{$\FixK\,\ell$}, and let \fbox{$\FixT\,T$} stand for
$\forall z.\ (\sfunT x {\Nat z} T\, z\, x) \to \sfunT x {\Nat (z + 1)} T \,(z+1)\, x$.
%
Similarly to for $\Pi$, we use named lambda abstraction as sugar for de
Bruijn abstraction.  Named abstraction takes care of proper lifting of
de Bruijn indices, for instance,
$\lambda x.\, t x = \lambda. (t \slift)\,\ind 0$ if $t$ is outside the
scope of $x$.
%
We may also use names when we construct concrete contexts, for
instance, if\/ $T$ is well-formed in context $\Gamma$, we may write
$T\,z\,x$ in context $\Gamma.z\of\Size.x\of\Nat z$ to mean
$T\slift^2\,\ind 1\,\ind 0$ in context $\Gamma.\Size.\Nat \ind 0$.

\input{figjudge}

In typing contexts $\Gamma$, we distinguish relevant $(\noterased)$ and irrelevant $(\erased)$ bindings.
When type checking a variable, it needs to be bound in the context relevantly.  However, when entering an irrelevant position, for instance when checking size $a$ in term $\suc a t$ we declare previously irrelevant variables as relevant.
This operation on the context has been coined
\emph{resurrection} by \citet{pfenning:lics01}; formally \fbox{$\resurrect\Gamma$} removes
the ``$\erased$''-markers from all bindings in $\Gamma$, \ie, replaces
them by ``$\noterased$''-markers.  Note that, trivially, resurrection is idempotent: $\resurrecttwice\Gamma = \resurrect{\Gamma}$.

Size increment \fbox{$a + o'$} for $o' \in \NN$ extends addition by $\infty + o' = \infty$ and $(\ind i + o) + o' = \ind i + (o + o')$.  Sizes are partially ordered; size comparison \fbox{$a \leq b$} holds as expected if either $b = \infty$ or  $o \leq o'$ where either $a = o$ and $b = o'$ or $a \in \{ o, \ind i + o \}$ and $b = \ind i + o'$.
Different size variables are incomparable.

\input{figty}
\input{figeq}
\input{fignat}

Fig.~\ref{fig:judge} lists the inductive and derived judgements of our type theory and
figures~\ref{fig:ty} and \ref{fig:eq} the inference rules.
We have \fbox{boxed} the rules dealing with irrelevant size application.
Fig.~\ref{fig:nat} add the typing and equality rules for case distinction
and recursion on natural numbers.
Judgement $\Gamma \der T : \Adm \ell$ characterizes the valid type
annotations $T$ in recursion $\fix[\ell] T t$.  The type constructor $T$
has to be monotone in the size argument; this is a technical condition
for type-based termination \cite{gimenez:typeBased}.  We will make use
of it in Section~\ref{sec:comp}.
We write \fbox{$\DD :: J$} to express that $\DD$ is a derivation of judgement $J$.

In the typing judgement $\Gamma \der t : T$, the term $t$ is in scope of
$\Gamma$, \ie, may not mention irrelevant variables in relevant
positions.  However, the type $T$ is in scope of the resurrected
context $\resurrect\Gamma$, hence, can mention all variables declared
in $\Gamma$.  The other judgements are organized similarly.  To
understand this distinction, consider judgement
$z \div \Size \der \Nat z$.  This would mean that $z$ is irrelevant in
$\Nat z$ and thus, $\Gamma \der \Nat a = \Nat {a'}$ for all sizes
$\resurrect\Gamma \der a,a' : \Size$.  But this is exactly wrong!  However,
judgement $z \div \Size \der \zero z : \Nat (z + 1)$ is fine, it
implies $\Gamma \der \zero a = \zero {a'} : \Nat (b+1)$ for all
$\resurrect\Gamma \der a,a',b : \Size$.

Our substitution theorem
needs to reflect the distinct scope of things left of the colon vs.\
things right of the colon.  In the last example we have applied the
substitution triple $\Gamma \der [a] = [a'] \eeq [b] : (z \div \Size)$
to judgement $z \div \Size \der \zero z : \Nat (z + 1)$.
The first two substitutions apply to the term side while the third
substitution applies to the type side.  The fact that we replace an
irrelevant variable $z$ allows $a,a',b$ to refer to irrelevant
variables from $\Gamma$, thus, they are in scope of $\resurrect\Gamma$.

Typing requires from annotations $\ann a$ in a term only that they are well-scoped size expressions, \ie, just mention relevant size variables.  Let \fbox{$t^\infty$} denote the \emph{erasure} of term $t$, meaning that we replace all annotations $\ann a$ in $t$ by $\ann \infty$.  Let \fbox{$t \approx u$} relate terms that only differ in their annotations, \ie, $t \approx u \defiff t^\infty = u^\infty$.
Erasure does not change the term modulo judgmental equality:
\begin{lemma}[Erasure and similarity]
\label{lem:erase}
\bla
\begin{enumerate}
\item If\/ $\Gamma \der t : T$ then $\Gamma \der t = t^\infty : T$.
\item If\/ $\Gamma \der t, u : T$ and $t \approx u$ then $\Gamma \der t = u : T$.
\end{enumerate}
\end{lemma}


%% COULD BE A LEMMA INSTEAD OF A RULE
% \begin{lemma}[Reflexivity]
%   If\/ $\Gamma \der t : T$ then $\Gamma \der t = t : T$.
% \end{lemma}

\noindent
We should remark here that we have \emph{neither type unicity nor principal types}
due to the irrelevant size application rule.
In the following, we list syntactic properties of our judgements.  To
this end, let $J$ %, $L$, and $R$
match a part of a judgement.

\begin{lemma}[Context well-formedness]
\label{lem:cxtwf}\bla
  \begin{enumerate}
  \item If\/ $\der \cext \Gamma \Delta$ then $\der \Gamma$
  \item If\/ $\Gamma \der J$ then $\der \Gamma$.
  \end{enumerate}
\end{lemma}

All types in a context are considered in the resurrected context,
which justifies the first statement of the following lemma.
A resurrected context is more permissive, as it brings more variable
into scope.  As such, it is comparable to an extended context or a
context where types have been replaced by subtypes.  This intuition
accounts for the remaining statements but (\ref{it:ressubst}).  The
latter is a defining property of substitutions: only replacement for
irrelevant sizes may refer to irrelevant size variables.
\begin{lemma}[Resurrection]
\label{lem:res} \bla
\begin{enumerate}
\item \label{it:reswf} $\der \Gamma$ iff $\der \resurrect\Gamma$.
  Then $\resurrect \Gamma \der \sid : \Gamma$, which can be written
  $\sid : \resurrect\Gamma \leq \Gamma$.
  % Consequently, if\/ $\Gamma \der J$ then $\resurrect \Gamma \der J$.
  % Further, if\/ $\Gamma \der J : \resurrect\Delta$ then $\Gamma \der J : \Delta$.
\item If\/ $\Gamma \der J$ then $\resurrect \Gamma \der J$.
\item If\/ $\Gamma \der \sigma : \resurrect \Delta$ % and $\der \Delta$
  then $\Gamma \der \sigma : \Delta$.
\item \label{it:ressubst} If\/ $\Gamma \der \sigma : \Delta$ % then $\Gamma \der \sigma : \resurrect\Delta$.
  then $\resurrect\Gamma \der \sigma : \resurrect\Delta$.
\end{enumerate}
\end{lemma}

\begin{lemma}[Substitution]
\label{lem:sub}\bla
\begin{enumerate}
\item
  If\/ $\Gamma \der \sigma : \Delta$ and $\Delta \der J$ then $\Gamma \der J\sigma$.
\item
  If\/ $\Gamma \der \sigma = \sigma' \eeq \tau : \Delta$ and $\Delta \der t : T$ then
  $\Gamma \der t\sigma : T\tau$ and $\Gamma \der t\sigma' : T\tau$.
\end{enumerate}
\end{lemma}

\begin{lemma}[Specific substitutions]
\label{lem:specsub}\bla
\begin{enumerate}
\item If\/ $\der \cext \Gamma \Delta$ then $\cext \Gamma \Delta \der \slift_{|\Gamma|}^{|\Delta|} : \Gamma$.
      If\/ $\der \cext \Gamma T$ then $\cext \Gamma T \der \slift : \Gamma$.
\item If\/ $\der \Gamma$ then $\Gamma \der \sid : \Gamma$.
\item If\/ $\Gamma \der u : U$ then $\Gamma \der \sg u : \cext \Gamma U$.
\end{enumerate}
\end{lemma}

The relation $\sueq \Gamma \sigma {\sigma'} \tau \Delta$ is a partial equivalence
relation (PER) on term-side substitutions $\sigma,\sigma'$. Note that
usually we cannot resurrect this judgement to
$\sueq{\resurrect\Gamma}{\sigma}{\sigma'}\tau {\resurrect\Delta}$.
For instance,
$\sueq{z_1 {\div} \Size.\,z_2 {\div} \Size} {\sg{z_1}} {\sg{z_2}} {\sg{\infty}} {z {\div} \Size}$
holds but
$\sueq{z_1 {:} \Size.\,z_2 {:} \Size} {\sg{z_1}} {\sg{z_2}} {\sg{\infty}} {z {:} \Size}$
clearly not.
% The type-side substitution $\tau$ can be converted to one that is
% equal in and for resurrected contexts.
\begin{lemma}[Substitution equality]
\label{lem:subeq}\bla
\begin{enumerate}
\item Conversion: If\/ $\sueq \Gamma \sigma {\sigma'} {\tau_1} \Delta$ and $\sueq {\resurrect\Gamma} {\tau_1} {\tau_2} {\tau} {\resurrect\Delta}$ then $\sueq \Gamma \sigma {\sigma'} {\tau_2} \Delta$.
\item Reflexivity: If\/ $\Gamma \der \sigma : \Delta$ then $\sueq \Gamma \sigma \sigma \sigma \Delta$.
\item Symmetry:  If\/ $\sueq \Gamma \sigma {\sigma'} {\tau} \Delta$ then $\sueq \Gamma {\sigma'} {\sigma} {\tau} \Delta$.
\item Transitivity:  If\/ $\sueq \Gamma {\sigma_1} {\sigma_2} {\tau} \Delta$ and $\sueq \Gamma {\sigma_2} {\sigma_3} {\tau} \Delta$ then $\sueq \Gamma {\sigma_1} {\sigma_3} {\tau} \Delta$.
\item Functionality: Let $\sueq \Gamma \sigma {\sigma'} \tau \Delta$.
  \begin{enumerate}
  \item
  If\/ $\Delta \der t : T$ then $\Gamma \der t\sigma = t\sigma' : T\tau$.
  \item
  If\/ $\Delta \der t = t' : T$ then $\Gamma \der t\sigma = t'\sigma' : T\tau$.
  \item
  Corollary: If\/ $\Delta \der T \leq T'$ then $\Gamma \der T\sigma \leq T\sigma'$.
  \end{enumerate}
\end{enumerate}
\end{lemma}

\LONGVERSION{
\begin{corollary}[Partial resurrection for substitution equality]
  If\/ $\sueq \Gamma \sigma {\sigma'} {\tau} \Delta$ then
  $\sueq {\resurrect \Gamma} \tau \tau \tau {\resurrect \Delta}$.
\end{corollary}
}

\begin{lemma}[Inversion of typing]
\label{lem:invty} \bla
\begin{enumerate}
\LONGVERSION{
\item If\/ $\Gamma \der \Nat a : T'$ then $\Gamma \der a : \Size$ and $\resurrect\Gamma \der \Set[0] \leq T'$.
\item If\/ $\Gamma \der \Set[\ell] : T'$ then $\resurrect\Gamma \der \Set[\ell+1] \leq T'$.
\item If\/ $\Gamma \der \piT U T : T'$ then $\Gamma \der U : s$ and $\cext \Gamma U \der T : s$ and $\resurrect\Gamma \der s \leq T'$ for some $s$.
\item If\/ $\Gamma \der \epiT \Size T : T'$ then
  $\cext\Gamma \Size \der T : s$ and $\resurrect\Gamma \der s \leq T'$.
}
\item If\/ $\Gamma \der \ind i : T'$ then $\Gamma(i) = \erann[\noterased] T$ and $\resurrect\Gamma \der T \leq T'$ for some $T$.
\item If\/ $\Gamma \der \lambda t : T'$ then either
  $\cext \Gamma U \der t : T$
  and
  $\resurrect\Gamma \der \piT U T \leq T'$
  for some $U,T$ or
  $\eext \Gamma \Size \der t : T$
  and
  $\resurrect\Gamma \der \epiT\Size T \leq T'$
  for some $T$.
\item If\/ $\Gamma \der t\,u : T'$ then $\Gamma \der t : \piT U T$ and $\Gamma \der u : U$ and $\resurrect\Gamma \der T[u] \leq T'$ for some $U$, $T$.
\item If\/ $\Gamma \der t\,a : T'$ then $\Gamma \der t : \piT \Size T$ and $\Gamma \der a : \Size$ and $\resurrect\Gamma \der T[a] \leq T'$ for some $T$.
\item If\/ $\Gamma \der t\,\ann a : T'$ then
   $\Gamma \der t : \forallT T$ and
   $\resurrect\Gamma \der a,b : \Size$ and
   $\resurrect\Gamma \der T[b] \leq T'$ for some $T$, $b$.
\LONGVERSION{
\item If\/ $\Gamma \der \zero a : T'$ then $\resurrect \Gamma \der a,b : \Size$ and $\resurrect\Gamma \der \Nat (b + 1) \leq T'$ for some $b$.
\item If\/ $\Gamma \der \suc a t : T'$ then $\resurrect \Gamma \der a,b : \Size$ and $\Gamma \der t : \Nat b$ and $\resurrect\Gamma \der \Nat(b+1) \leq T'$.
\item If\/ $\Gamma \der u\,\case[\ell] T {t_z} {t_s} : T'$ then $\Gamma \der u : \Nat (a+1)$ and $\Gamma \der T : \Nat(a+1) \to \Set[\ell]$ and $\Gamma \der t_z : T\,(\zero a)$ and $\Gamma \der t_s : \funT x {\Nat a} {T\,(\suc a x)}$ and $\resurrect\Gamma \der T\,u \leq T'$ for some $a$.
\item If\/ $\Gamma \der u\,\fix[\ell] T t : T'$ then
  $\Gamma \der u : \Nat a$ and
  $\Gamma \der T : \Adm\,\ell$ and
  $\Gamma \der t : \FixT\,T$ and
  $\resurrect\Gamma \der T\,a\,u \leq T'$.
} % END LONGVERSION
\SHORTVERSION{
\item ... Analogous properties for the remaining term and type constructors.
}
\end{enumerate}
\end{lemma}
\begin{proof}
  Each by induction on the typing derivation, gathering applications of the conversion rule via transitivity of subtyping.
\end{proof}



\section{Semantics and Completeness of Normalization by Evaluation}
\label{sec:sem}

In this section we present an operational semantics of our language,
define the NbE algorithm, construct a PER model, and demonstrate that
NbE is complete for definitional equality, \ie, if
$\Gamma \der t = t' : T$, then $t$ and $t'$ have the same normal form
up to annotations.
\[
\begin{array}{l@{~\,}l@{~\,}l@{~\,}l@{~\,}l@{\qquad}l}
  \Ne & \ni &
  m & ::= & \ind i \mid m\,v \mid m\,a \mid m\,\ann a \mid
            m\,\case[\ell] V{v_z}{v_s} \mid m\,\fix[\ell] V v
    & \mbox{neutral n.f.} \\
    % & \mbox{normal neutral term} \\
  \Nf & \ni &
  v & ::= & m \mid \lambda v \mid \zero a \mid \suc a v \mid
            \Set[\ell] \mid \Nat a \mid \piT {V_u}{V_t} \mid
            \epiT\Size V
    & \mbox{normal form} \\
\end{array}
\]
For the operational semantics,
instead of defining a separate language of values,
we extend the syntax of expressions by de Bruijn levels $\lev k$
to be used as generic values (unknowns), and type annotations
$\up A n$ and $\down A t$ for lazy realizations of the
reflection and reification operations of NbE.
\emph{Terms} are expressions that do not contain these new expression
forms. \emph{Values} \fbox{$f,g,A,B,F \in \D$} are expressions with no free de Bruijn
indices, where each neutral $n$ is under a reflection marker $\up A n$.
The types $A$ that direct reflection $\up A n$ and reification
$\down A f$ also live in the value world.
\[
\begin{array}{lllrl@{\qquad}l}
  \NeExp & \ni & n & ::= & \dots \mid \lev k
    & \mbox{de Bruijn level $k$} \\
  \tUp  & \ni & N & ::= & \up A n
     & \mbox{reflection of neutral term $n$ as value of type $A$} \\
     % & \mbox{reflection of neutral term $n$ into the value world $\D$, at type $A$} \\
  \Whnf & \ni & w & ::= & \dots \mid N
    & \mbox{reflected neutral is weak head normal} \\
  \Exp  & \ni & t & ::= & \dots \mid \down A f
     & \mbox{reification of value $f$ at type $A$} \\
\end{array}
\]
% \[
% \begin{array}{lllrl@{\qquad}l}
% %  \Exp  & \ni & t & ::= & \dots \mid \lev k \mid \up T t \mid \down T t \\
%   \tUp  & \ni & N & ::= & \up A n
%      & \mbox{reflection of neutral term $n$ into the value world $\D$, at
%        type $A$} \\
%   \tDown & \ni & d & ::= & \down A f
%      & \mbox{reification of value $f$ at type $A$} \\
%   \NeExp & \ni & n & ::= & \dots \mid \lev k
%     & \mbox{de Bruijn level $k$} \\
%   \Whnf & \ni & w & ::= & \dots \mid N
%     & \mbox{reflected neutral are weak head normal} \\
%   \Exp  & \ni & t & ::= & \dots \mid d
%     & \mbox{reified values may occur in expressions} \\
% %  \Whnf & \ni & w,d,f,g,A,B,F,G & ::= & \dots \mid  \up T n \mid \down T t \\
% \end{array}
% \]
\emph{De~Bruijn levels} are the mirror images of de Bruijn indices.  While de Bruijn
indices index the context from the right, \ie, $\ind 0$ refers the
last type that entered the context, de Bruijn levels index it from the
left, \ie, $\lev 0$ refers to the first type in the context.  This
way, de Bruijn levels are stable under context extensions, and
suitable to represent unknowns.

\emph{Size values} \fbox{$\alpha, \beta \in \SIZE$} are size
expressions that use de Bruijn levels instead of de Bruijn
indices. Comparison of size values $\alpha \leq \beta$ is
analogous to comparison of size terms $a \leq b$.  In the following, we
will reuse letter $a$ for a value if it cannot be confused for a size
term.

Finally, we identify two expression classes for NbE. Neutrals
$n \in \DNe$ are the ones that will appear in values under the
reflection marker $\up{A}$.  Reified values $d \in \DNf$ are values
under a reification marker $\down{A}$.
\[
\begin{array}{lllll@{\qquad}l}
  \DNe & \ni &
  n & ::= & \ind i \mid n\,d \mid n\,\alpha \mid n\,\ann \alpha \mid
            n\,\case[\ell] D{d_z}{d_s} \mid n\,\fix[\ell] D d
    & \mbox{unreflected neutral value} \\
  \DNf & \ni &
  d & ::= & \down A f
    & \mbox{reified value} \\
\end{array}
\]

\begin{figure}
\hrulefill
$$
\xymatrix@R=12ex@C=12ex{
\mathrlap{\mbox{Semantics ($\beta$)}} &
  &                f \in \D   \ar@[red][d]_{\down A}
\\
\mathrlap{\mbox{Semantics ($\beta\eta$)}} &
  &                d \in \DNf \ar@[red][d]_{\tR_k{}}
  &                n \in \DNe \ar[d]_{\tRne_k} \ar@[blue][ul]_{\up A}
  & \ar@[blue][l]_{\var{}} j \in \Level \ar@{<->}[d]_{k\dotminus(1+\_)}
\\
\mathrlap{\mbox{Syntax}} &
t \in \Exp \ar@[red]@(u,dl)[uur]^{\_\color{blue}\eta} %\ar@/^/[uur]^{\den\_}
  & \ar[l]_{\supseteq}  v \in \Nf
  & \ar[l]_{\supseteq}  m \in \Ne
  & \ar[l]_{\ind{}}     i \in \Index
  &
}
$$
\hrulefill
\caption{Type-assignment NbE in locally nameless
    style.\label{fig:typedchart}}
\end{figure}

\newcommand{\redto}{\mathrel{\color{red}{\to}}}
\newcommand{\blueto}{\mathrel{\color{blue}{\to}}}

Figure~\ref{fig:typedchart}, adapted from \citet{abel:habil} summarized the syntactic categories and main operations involved in NbE in what is called \emph{locally nameless style}.  The \textcolor{red}{red path} $\Exp \redto \D \redto \Dnf \redto \Nf$ decomposes $\beta\eta$-normalization into three steps.
\begin{enumerate}
\item
First, we close the term $t$ with an environment \textcolor{blue}{$\eta$} that maps the
free de Bruijn indices of $t$ to reflected de Bruijn levels.
Reflection of de Bruijn levels follows the \textcolor{blue}{blue path}
$\Level \blueto \DNe \blueto \D$: Levels embed via constructor $\var{}$
into semantic neutrals $\DNe$ which are labeled with their type $A \in \D$
to become an element $\up A \lev j \in \D$.

\item
Then, we label value $t \eta \in \D$ with its type $A$ to obtain $\down A t \eta \in \DNf$.
\item
Finally, \emph{read back} %% $\tR_k$
$\tR_k \down{A} t\eta$ produces a long normal form $v \in \Nf$, converting de Bruijn levels back to indices.
Herein, $k$ should be the length of the context the original term $t$ lived in.
If this is the case, each de Bruijn level encountered during read back is below $k$ and can be safely converted to a de Bruijn index.
\end{enumerate}

\subsection{Weak head reduction}

We define the operational semantics of our language by the weak head
evaluation relation \fbox{$t \evalsto w$} which is defined on
expressions, thus works on values as well as on terms.  It is defined mutually
with auxiliary relation \fbox{$w \at e \evalsto w'$} stating that weak
head normal form $w$ is eliminated by $e$ into weak head normal form $w'$.
% \[
% \begin{array}{l@{\qquad}l}
%   t \evalsto w & \mbox{term $t$ evaluates to weak head normal form $w$} \\
%   w \at e \evalsto w' & \mbox{eliminating $w$ with $e$ evaluates to $w'$} \\
% %  w \at \vec e \evalsto w' & \mbox{applying $w$ to eliminations $\vec e$ evaluates to $w'$} \\
% \end{array}
% \]

\noindent
\fbox{$t \evalsto w$}
\ and \
\fbox{$w \at e \evalsto w'$}
\vspace{-6ex}
\begin{gather*}
  \ru{}{w \evalsto w}
\qquad
  \ru{t \evalsto w \qquad w \at e \evalsto w'}{t\,e \evalsto w'}
% \end{gather*}
% \fbox{$w \at e \evalsto w'$}
% \begin{gather*}
\\[1.5ex]
  \ru{t[u] \evalsto w
    }{(\lambda t) \at u \evalsto w}
\qquad
  \ru{t[\alpha] \evalsto w
    }{(\lambda t) \at \alpha \evalsto w}
\qquad
  \ru{t[\alpha] \evalsto w
    }{(\lambda t) \at \ann \alpha \evalsto w}
\qquad
  \ru{t_z \evalsto w
    }{(\zero \alpha) \at \casett \evalsto w}
\\[1.5ex]
  \ru{t_s\, t \evalsto w
    }{(\suc \alpha t) \at \casett \evalsto w}
\qquad
  \rux{t\,\ann \alpha\,(\lambda x.\, x\, \fixtt)\,c \evalsto w
     }{c \at \fixtt \evalsto w
     }{c\in \{ \zero \alpha, \suc \alpha u \}}
\end{gather*}
%The rules added for NbE deal with elimination of delayed reflection:
For NbE, we add evaluation rules that deal with elimination of delayed reflection:
\begin{gather*}
  \ru{A' \evalsto \piT A B
    }{(\up {A'} n) \at u \evalsto \up{B[u]} (n \, \down A u) }
\qquad
  \ru{A \evalsto \piT \Size B
    }{(\up {A} n) \at \alpha \evalsto \up{B[\alpha]} (n \, \alpha)}
\qquad
  \ru{A \evalsto \forallT B
    }{(\up {A} n) \at \ann \alpha \evalsto \up{B[\alpha]} (n \ann \alpha)}
\\[1.2ex]
  \ru{%A \evalsto \Nat \beta \qquad
    }{(\up {A} n) \at \case[\ell] B {f_z} {f_s} \evalsto
      \up{B\,(\up{A} n)}\,
      % \up{B\,(\up{\Nat \infty} n)}
         n\,\case[\ell]
             {(\down {\Nat \infty \to \Set[\ell]} B)}
             {(\down {B\,{\zero\infty}} f_z)}
             {(\down {\funS x {\Nat \infty} B\,(\suc \infty x)} f_s)}
    }
\\[1ex]
  \ru{%A \evalsto \Nat \beta \qquad
    }{(\up {A} n) \at \fix[\ell] B f \evalsto
      n\,\fix[\ell] {(\down {\FixK} B)} {(\down {\FixT\, B} f)}
    }
\end{gather*}

\subsection{Read back}
\label{sec:read}

The \emph{read back} phase of NbE \cite{gregoireLeroy:icfp02}
transforms a reified value $d$ into a normal form $v$.  It is
specified via an inductively defined relation $\R k d v$ and several auxiliary relations.
The number $k$, will be instantiated by the length of the context
$\Gamma$ later.  It allows us to transform a de Bruijn level $l$ into a de
Bruijn index $i$, via the law $i + l + 1 = k$.  At this point, we do
not ensure that the $k$ is large enough to accommodate the de Bruijn
levels in $d$.  Levels $l \geq k$ which are to big will simply be mapped
to de Bruijn index $0$.  The correct $k$ is later ensured by our
logical relation (Section~\ref{sec:soundnbe}).
% Judgements.
% \[
% \begin{array}{l@{\qquad}l}
%    \R k d  v     & \mbox{} \\
%    \RTy k T  V  & \mbox{} \\
%    \RNat k t  v & \mbox{} \\
%    \RNe k t  m  & \mbox{} \\
% \end{array}
% \]
Even though read back operates on values in practice, formally it is
defined on expressions.

\noindent
\fbox{$\R k d v$}\ \ Read back reified value $d$.
\begin{gather*}
  \ru{U \evalsto s \qquad
      \RTy k T V
    }{\R k {\down{U} T} V}
\qquad
  \ru{U \evalsto \Nat \alpha \qquad
      \RNat k u v
    }{\R k {\down{U} u} v}
\qquad
  \ru{U \evalsto N \qquad
      \RUp k u m
      % u \evalsto \up{T} n \qquad \RNe k n m
    }{\R k {\down{U} u} m}
\\[2ex]
  \ru{U \evalsto \piT A B \qquad
      \R{k+1} {\down{B[\up A \lev k]} (f\,\up A \lev k)} v
    }{\R k {\down{U} f} {\lambda v}}
\\[2ex]
  \ru{U \evalsto \piT \Size B \qquad
      \R{k+1} {\down{B[\lev k]} (f\,\lev k)} v
    }{\R k {\down{U} f} {\lambda v}}
\qquad
  \ru{U \evalsto \forallT B \qquad
      \R{k+1} {\down{B[\lev k]} (f\,\ann{\lev k})} v
    }{\R k {\down{U} f} {\lambda v}}
\end{gather*}

\noindent
\fbox{$\RUp k t m$}\ \  Read back neutrals under annotation.  (The annotation is ignored.)
\begin{gather*}
  \ru{t \evalsto \up T n \qquad
      \RNe k n m
    }{\RUp k t m}
\end{gather*}

\noindent
\fbox{$\RNat k t v $}\ \ Read back natural number value.
\begin{gather*}
  \ru{% t \evalsto \up {\Nat \alpha} n \qquad
      %t \evalsto \up {T} n \qquad \RNe k n m
      \RUp k t m
    }{\RNat k t m}
\qquad
  \ru{t \evalsto \zero{\alpha} \qquad
      \RSize k {\alpha} a
    }{\RNat k t {\zero a}}
\qquad
  \ru{t \evalsto \suc{\alpha}u \qquad
      \RSize k {\alpha} a \qquad
      \RNat k u v
    }{\RNat k t {\suc a v}}
\end{gather*}

\noindent
\fbox{$\RSize k {\alpha} a$}\ \ Read back size value $\alpha$.
\vspace{-1.5ex}
\begin{gather*}
  \ru{
    }{\RSize k \infty \infty}
\qquad
  \ru{
    }{\RSize k o o}
\qquad
  \ru{
    }{\RSize k {\lev j + o} {\ind{k\dotminus(1+j)} + o}}
\end{gather*}

\noindent
\fbox{$\RNe k n m$} and \fbox{$\RElim k e e^v$}\ \ Read back unreflected neutral.
\begin{gather*}
%   \ru{t \evalsto \lev j
%     }{\RNe k t {\ind{k-1-j}}}
% \qquad
  \ru{%t \evalsto \lev j\,\vec e \qquad
      \RElim k {e_i} {e^v_i} \mforall i
    }{\RNe k {\lev j\,\vec e} {\ind{k \monus (1+j)}\,\vec e^v}}
\qquad
% \end{gather*}
% \begin{gather*}
  \ru{\R k d v
    }{\RElim k d v}
\qquad
  \ru{\RSize k \alpha b
    }{\RElim k \alpha b}
\qquad
  % \ru{
  %   }{\RElim k {\ann \alpha} {\ann \infty}}
  \ru{\RSize k \alpha b
    }{\RElim k {\ann \alpha} {\ann b}}
\\[2ex]
  \ru{\R k D V \qquad
      \R k {d_z} {v_z} \qquad
      \R k {d_s} {v_s}
    }{\RElim k {(\case[\ell] D {d_z} {d_s})} {\case[\ell] V {v_z} {v_s}}}
\qquad
  \ru{\R k D V \qquad
      \R k d v
    }{\RElim k {(\fix[\ell] D d)} {\fix[\ell] V v}}
\end{gather*}

\noindent
\fbox{$\RTy k T V$} \ \ Read back type value.
\begin{gather*}
  \ru{T \evalsto \Set[\ell]
    }{\RTy k T {\Set[\ell]}}
\qquad
  \ru{T \evalsto \Nat \alpha \qquad
      \RSize k \alpha b
    }{\RTy k T {\Nat b}}
\qquad
  \ru{% T \evalsto \up{U}n \qquad \RNe k n m
      \RUp k T m
    }{\RTy k T m}
\\[2ex]
  \ru{T \evalsto \piT A B \qquad
      \RTy k A {V_a} \qquad
      \RTy {k+1} B {V_b}
    }{\RTy k T {\piT {V_a} V_b}}
\qquad
  \ru{T \evalsto \epiT \Size B \qquad
      \RTy {k+1} B {V}
    }{\RTy k T {\epiT \Size V}}
\end{gather*}

% We write \fbox{$t \approx t'$} iff $t$ and $t'$ are syntactically equal if we ignore sizes $\ann a$ in irrelevant positions.  For example, $\suc a \tzero \approx \suc 0 \tzero$, but $\Nat a \not\approx \Nat 0$.



\subsection{Partial equivalence relations}
\label{sec:per}

A type $T$ will be interpreted as a partial equivalence relation (PER)
$\A$ on terms, \ie, a relation which is symmetric and transitive. The
domain $\dom(\A)$ of the relation can be thought of as the set of
terms which denotes the extension of the type; on
$\dom(\A) = \{a \mid \exists a'.\ (a,a') \in \A \}$ the relation $\A$
is in fact an equivalence relation.  We write $a = a' \in \A$ for
relatedness in $\A$ and $a \in \A$ if $a \in \dom(\A)$.

The PERs $\NE$ and $\NF$ characterize (neutral) normalizing values.
For instance, two values $n$ and $n'$ are related in $\NE$ if at any $k \in \NN$
they can be read back to neutral normal forms $m$ and $m'$
which are identical up to annotations.
\[
% \begin{array}{l@{\quad}l@{\quad}l@{~}l@{~}l@{~}l@{~}l@{~}l}
%   n = n' \in \NE
%     & \defas &
%     \RNe k n m &\mand& \RNe k {n'} {m} &\mforall k \\
%   d = d' \in \NF
%     & \defas &
%     \R k d v &\mand& \R k {d'} {v} &\mforall k \\
%   e = e' \in \ELIM
%     & \defas &
%     \RElim k e e_v &\mand& \RElim k {e'} {e_v} &\mforall k \\
%   A = A' \in \TY
%     & \defas &
%     \RTy k A V &\mand& \RTy k {A'} {V} &\mforall k \\
% \end{array}
%\newcommand{\myfbox}[1]{\begin{array}[c]{@{}l@{}}\framebox(60,12)[l]{~\,#1}\end{array}}
\newcommand{\myfbox}[1]{\framebox(60,13)[l]{~\,#1}}
\begin{array}{l@{\quad}l@{\quad}l@{~}l@{\,}l@{\quad}l@{\,}l@{~}l@{~\;}r@{~}l@{~}l@{~}l}
  \raisebox{-0.5ex}{\myfbox{$n = n' \in \NE$}}
    & \defas &
    \tRne _k & n \evalsto m &\mand& \tRne _k & {n'} \evalsto {m'} &\mand& m &\nfeq& m' &\mforall k
\\[1ex]
  \raisebox{-0.8ex}{\myfbox{$d = d' \in \NF$}}
    & \defas &
    \tR _k & d \evalsto v &\mand& \tR _k & {d'} \evalsto {v'} &\mand& v &\nfeq& v' &\mforall k
\\[1ex]
  \raisebox{-0.6ex}{\myfbox{$e = e' \in \ELIM$}}
    & \defas &
    \tRelim _k & e \evalsto e_v &\mand& \tRelim _k & {e'} \evalsto {e_v'} &\mand& e_v &\nfeq& e_v' &\mforall k
\\[1ex]
  \raisebox{-0.8ex}{\myfbox{$A = A' \in \TY$}}
    & \defas &
    \tRty _k & A \evalsto V &\mand& \tRty _k & {A'} \evalsto {V'} &\mand& V &\nfeq& V' &\mforall k \\
\end{array}
% \begin{array}{l@{\quad}l@{\quad}l@{~}l@{\quad}l@{~}l@{~\;}r@{~}l@{~}l@{~}l}
%   \raisebox{-0.5ex}{\myfbox{$n = n' \in \NE$}}
%     & \defas &
%     \RNe k n m &\mand& \RNe k {n'} {m'} &\mand& m &\nfeq& m' &\mforall k
% \\[1ex]
%   \raisebox{-0.8ex}{\myfbox{$d = d' \in \NF$}}
%     & \defas &
%     \R k d v &\mand& \R k {d'} {v'} &\mand& v &\nfeq& v' &\mforall k
% \\[1ex]
%   \raisebox{-0.6ex}{\myfbox{$e = e' \in \ELIM$}}
%     & \defas &
%     \RElim k e e_v &\mand& \RElim k {e'} {e_v'} &\mand& e_v &\nfeq& e_v' &\mforall k
% \\[1ex]
%   \raisebox{-0.8ex}{\myfbox{$A = A' \in \TY$}}
%     & \defas &
%     \RTy k A V &\mand& \RTy k {A'} {V'} &\mand& V &\nfeq& V' &\mforall k \\
% \end{array}
\]
Once we have established useful closure properties of these PERs, they
abstract most of the reasoning about the read-back relation from our
proofs.  This idea is due to Coquand \cite{abelCoquandPagano:tlca09}.

\begin{lemma}[Closure properties of $\NE$]
  \label{lem:closne}
  \bla
  \begin{enumerate}
  \item $\lev k = \lev k \in \NE$.
  \item If\/ $n = n' \in \NE$ and $e = e' \in \ELIM$ then $n\,e = n'\,e' \in \NE$.
  \end{enumerate}
\end{lemma}

\begin{lemma}[Closure properties of $\ELIM$]
  \label{lem:closelim}
  \bla
  \begin{enumerate}
  \item If\/ $d = d' \in \NF$ then $d = d' \in \ELIM$.
  \item If\/ $\alpha \in \SIZE$ then $\alpha = \alpha \in \ELIM$.
  \item $\ann \alpha = \ann{\alpha'} \in \ELIM$.
  \item If\/ $A = A' \in \TY$ and $d_z = d_z' \in \NF$ and $d_s = d_s' \in \NF$
        then $\case[\ell] A {d_z}{d_s} = \case[\ell]{A'}{d_z'}{d_s'} \in \ELIM$.
  \item If\/ $D = D' \in \NF$ and $d = d' \in \NF$ then $\fix[\ell] D d = \fix[\ell]{D'}{d'} \in \ELIM$.
  \end{enumerate}
\end{lemma}

Now we define some PERs and PER constructors on values.  All these PERs $\A$ are closed under weak head equality, meaning if $a = b \in \A$ and $a'$ has the same weak head normal form as $a$, then $a' = b \in \A$.  (By symmetry, $\A$ is also closed under weak head equality on the second argument.)

\fleq
%Neutrals in the value world $\D$.
PER $\NEE$ interprets all neutral types.
\[
\fbox{$t = t' \in \NEE$} \defas
  t \evalsto \up T n \mand t' \evalsto \up{T'}{n'} \mand
  n = n' \in \NE
  .
% \fbox{$\NEE$} \defas \{ (\up T n, \up{T'}{n'})
%   % \msuchthat T \evalsto N \mand T' \evalsto N' \mand
%   \mid n = n' \in \NE \}
\]

\fbox{$\NAT(\alpha)$} interprets $\Nat \alpha$ and is defined inductively by the following rules.
\begin{gather*}
  \ru{% t \evalsto \up{\Nat \alpha} n \qquad
      % t' \evalsto \up{\Nat \alpha'} n' \qquad
      % n = n' \in \NE
      t = t' \in \NEE
    }{t = t' \in \NAT(\beta)}
\qquad
  \ru{t \evalsto \zero \alpha \\
      t' \evalsto \zero{\alpha'}
    }{t = t' \in \NAT(\beta+1)}
\qquad
  \ru{t \evalsto \suc \alpha u \qquad
      t' \evalsto \suc {\alpha'} {u'} \\
      u = u' \in \NAT(\beta)
    }{t = t' \in \NAT(\beta+1)}
\end{gather*}

\fbox{$\SIZE$} interprets $\Size$ and is a discrete PER of size values:
\vspace{-1ex}
\begin{gather*}
  \ru{
    }{\infty = \infty \in \SIZE}
\qquad
  \ru{
    }{o = o \in \SIZE}
\qquad
  \ru{
    }{\lev k + o = \lev k + o \in \SIZE}
\end{gather*}

Let $\A$ be a PER (including $\A = \SIZE$) and $\F$ a family of PERs over $\A$ such that
$\F(u) = \F(u')$ whenever $u = u' \in \A$.  We define
\[
  \fbox{$\PIAF$} \defas \{(t,t') \mid t\,u = t'\,u' \in \F(u) \mforall u = u' \in \A \}
  .
\]
%This works also for $\A = \SIZE$.

For a family $\F$ over $\SIZE$ we also have the irrelevant function space
\[
  \fbox{$\FORALL\,\F$} \quad \, \defas
  \{(t,t') \mid t \ann \alpha = t' \ann{\alpha'} \in \F(\beta) \mforall \alpha,\alpha',\beta \in \SIZE \}
  .
\]
\cneq

% \begin{lemma}[PER Subsumption]
% \label{lem:subsump} \hfill
% \begin{enumerate}
% \item If\/ $\alpha \leq \beta$ then $\NAT(\alpha) \subseteq \NAT(\beta)$.
% \item If\/ $\F(\alpha) \leq \F'(\alpha)$ for all $\alpha \in \SIZE$, then $\FORALL \F \subseteq \FORALL \F'$.
% \item IF\/ $\A' \subseteq \A$ and $\F(u) \subseteq \F'(u)$ for all $u \in \A'$, then $\PIAF \subseteq \PI\,\A'\,\F'$.
% \end{enumerate}
% \end{lemma}



\subsection{PER model}
\label{sec:permodel}

Semantic types and their interpretation as PERs are now defined via a
family of inductive-recursive definitions \cite{dybjer:jsl00}, one for
each universe level $\ell$.  The construction follows \citet{abelCoquandDybjer:lics07}.

By induction on $\ell \in \NN$ we define the PER family
$\_ = \_ \in \Set[\ell]$ of types
together with the extension $\EL[\ell] T$ (for $T = T' \in \Set[\ell]$)
which is a PER of values of type $T$.
The rules for \fbox{$T = T' \in \SET[\ell]$} are listed in Fig.~\ref{fig:per}.
\begin{figure}
\hrulefill
\[
\begin{array}{l@{\qquad}l}
  \ru{% T \evalsto \up{\Set[\ell']} n \qquad
      % T' \evalsto \up{\Set[\ell'']} n' \qquad
      % n = n' \in \NE
      T = T' \in \NEE
    }{T = T' \in \SET[\ell]}
  & \EL[\ell](T) = \NEE
\\[3ex]
  \ru{T \evalsto \Nat\,\alpha \qquad T' \evalsto \Nat\,\alpha
    }{T = T' \in \SET[\ell]}
  & \EL[\ell](T) = \NAT(\alpha)
\\[3ex]
  \rux{T \evalsto \Set[\ell'] \qquad T' \evalsto \Set[\ell']
     }{T = T' \in \SET[\ell]
     }{\ell'{<}\ell}
  & \EL[\ell](T) = \SET[\ell']
\\[3ex]
  \rul{T \evalsto \piT A B \quad \
      T' \evalsto \piT{A'}{B'} \quad \
      A = A' \in \SET[\ell] \\
      B[u] = B'[u'] \in \SET[\ell] \mforall u = u' \in \EL[\ell](A)
    }{T = T' \in \SET[\ell]}
  & \EL[\ell](T) = \PI(\EL[\ell](A),\;u \mapsto \EL[\ell](B[u]))
\\[3ex]
  \rul{T \evalsto \piT \Size B \qquad
      T' \evalsto \piT{\Size}{B'} \\
      B[\alpha] = B'[\alpha] \in \SET[\ell] \mforall \alpha \in \SIZE
    }{T = T' \in \SET[\ell]}
  & \EL[\ell](T) = \PI(\SIZE,\; \alpha \mapsto \EL[\ell](B[\alpha]))
\\[3ex]
  \rul{T \evalsto \forallT B \qquad
      T' \evalsto \forallT{B'} \\
      B[\alpha] = B'[\alpha] \in \SET[\ell] \mforall \alpha \in \SIZE
    }{T = T' \in \SET[\ell]}
  & \EL[\ell](T) = \FORALL(\alpha \mapsto \EL[\ell](B[\alpha]))
\end{array}
\]
\hrulefill
\caption{Semantic types and their interpretation.\label{fig:per}}
\end{figure}
All relations involved here are closed under weak head equality.
\begin{lemma}[Well-definedness]
  Let $\DD :: T_1 = T_2 \in \SET[\ell]$.
  \begin{enumerate}
  \item Symmetry: $T_2 = T_1 \in \SET[\ell]$.
  \item Transitivity: If\/ $T_2 = T_3 \in \SET[\ell]$ then $T_1 = T_3 \in \SET[\ell]$.
  \item Extension: $\EL[\ell](T_1) = \EL[\ell](T_2)$ and ``both'' are PERs.
  \end{enumerate}
\end{lemma}
\LONGVERSION{
\begin{proof}
  Simultaneously by induction on $\DD$.
\end{proof}
}

% The PER model has the usual properties, one of them being that $\EL[\ell](T)$ does not depend $\ell$ nor the derivation that introduced $T = T' \in \SET[\ell]$.  Thus, we simply write $t = t' \in \EL(T)$ or even $t = t' \in T$.
\begin{lemma}[Derivation independence of extension]
\label{lem:indep}
  If\/ $\DD_1 :: T = T_1 \in \SET[\ell_1]$
  and $\DD_2 :: T_2 = T \in \SET[\ell_2]$ then $\EL[\ell_1](T) = \EL[\ell_2](T)$.
\end{lemma}
\LONGVERSION{
\begin{proof}
  By induction on $\DD_1$ and cases on $\DD_2$.
\end{proof}
}
Since $\EL[\ell](T)$ does not depend on $\ell$ nor the derivation that introduced $T = T' \in \SET[\ell]$,  we may simply write $t = t' \in \EL(T)$ or even $t = t' \in T$.


\subsection{Subtyping}
\label{sec:subty}

The semantic types (PERs) admit subsumption:

\begin{lemma}[Subsumption]
\label{lem:subsump} \hfill
\begin{enumerate}
\item \label{it:natsub} If\/ $\alpha \leq \beta$ then $\NAT(\alpha) \subseteq \NAT(\beta)$.
\item \label{it:allsub} If\/ $\F(\alpha) \subseteq \F'(\alpha)$ for all $\alpha \in \SIZE$, then $\FORALL \F \subseteq \FORALL \F'$.
\item \label{it:pisub}  If\/ $\A' \subseteq \A$ and $\F(u) \subseteq \F'(u)$ for all $u \in \A'$, then $\PIAF \subseteq \PI\,\A'\,\F'$.
\item \label{it:usub}  If\/ $\ell \leq \ell'$ then $\SET[\ell] \subseteq \SET[\ell']$.
\end{enumerate}
\end{lemma}
\LONGVERSION{
\begin{proof}
  Propositions (\ref{it:natsub}--\ref{it:pisub}) are clear.
  For (\ref{it:usub}), prove $T = T' \in \SET[\ell']$ by induction on $T = T' \in \SET[\ell]$.
  For the base types this is direct, let us look at the function space.
\[
  \rul{T \evalsto \piT A B \qquad
      T' \evalsto \piT{A'}{B'} \qquad
      A = A' \in \SET[\ell] \qquad
      B[u] = B'[u'] \in \SET[\ell] \mforall u = u' \in \EL[\ell](A)
    }{T = T' \in \SET[\ell]}
\]
  By induction hypothesis, $A = A' \in \SET[\ell']$, and we have $\EL[\ell'](A) = \EL[\ell](A)$ by Lemma~\ref{lem:indep}.  Assuming $u = u' \in \EL(A)$, we get $B[u] = B'[u'] \in \SET[\ell']$ by induction hypothesis on $B[u] = B'[u'] \in \SET[\ell]$.
\end{proof}
}
We define subtyping of type values \fbox{$T \leq T' \in \TYPE$} by induction on $T \in \SET[\ell]$ and $T' \in \SET[\ell']$.
Simultaneously, we need to prove correctness, namely that $T \leq T' \in \TYPE$ implies $\EL(T) \subseteq \EL(T')$.  The correctness follows from Lemma~\ref{lem:subsump} and we do not spell it out here.
\begin{gather*}
  \ru{T = T' \in \NEE
    }{T \leq T' \in \TYPE}
\qquad
  \ru{T \evalsto \Nat \alpha \quad
      T' \evalsto \Nat \alpha' \quad
      \alpha \leq \alpha'
    }{T \leq T' \in \TYPE}
\qquad
  \ru{T \evalsto \Set[\ell_0] \quad
      T' \evalsto \Set[\ell_0'] \quad
      \ell_0 \leq \ell_0'
    }{T \leq T' \in \TYPE}
\\[2ex]
  \ru{T \evalsto \piT A B \qquad
      T' \evalsto \piT {A'}{B'} \qquad
      A' \leq A \in \TYPE \qquad
      B[u] \leq B'[u'] \in \TYPE \mforall u = u' \in A'
    }{T \leq T' \in \TYPE}
\\[2ex]
  \ru{T \evalsto \epiT \Size B \qquad
      T' \evalsto \epiT {\Size}{B'} \qquad
      B[\alpha] \leq B'[\alpha] \in \TYPE \mforall \alpha \in \SIZE
    }{T \leq T' \in \TYPE}
\end{gather*}
\begin{lemma}[Subtyping is a preorder]
\label{lem:preord}
\bla
\begin{enumerate}
\item If\/ $T = T' \in \SET[\ell]$ then $T \leq T' \in \TYPE$.
\item If\/ $T_1 \leq T_2 \in \TYPE$ and $T_2 \leq T_3 \in \TYPE$ then $T_1 \leq T_3 \in \TYPE$.
\end{enumerate}
\end{lemma}


% \begin{lemma}[Universe subsumption]
%   \label{lem:usubsump}
%   If\/ $\ell \leq \ell'$ then $\SET[\ell] \subseteq \SET[\ell']$.
% \end{lemma}
% \begin{proof}
%   Prove $T = T' \in \SET[\ell']$ by induction on $T = T' \in \SET[\ell]$.
%   For the base types this is direct, let us look at the function space.
% \[
%   \rul{T \evalsto \piT A B \qquad
%       T' \evalsto \piT{A'}{B'} \qquad
%       A = A' \in \SET[\ell] \qquad
%       B[u] = B'[u'] \in \SET[\ell] \mforall u = u' \in \EL[\ell](A)
%     }{T = T' \in \SET[\ell]}
% \]
%   By induction hypothesis, $A = A' \in \SET[\ell']$, and we have $\EL[\ell'](A) = \EL[\ell](A)$ by Lemma~\ref{lem:indep}.  Assuming $u = u' \in \EL(A)$, we get $B[u] = B'[u'] \in \SET[\ell']$ by induction hypothesis on $B[u] = B'[u'] \in \SET[\ell]$.
% \end{proof}



\subsection{Type shapes}
\label{sec:shape}

Reflection and reification perform $\eta$-expansion so that we arrive at an $\eta$-long $\beta$-normal form.  To perform the $\eta$-expansion, the precise type is not needed, just the approximate shape, in particular, whether it is a function type (do expand) or a base type (do not expand).
For the logical framework, the shape of a dependent type is just its
underlying simple type \cite{harperPfenning:equivalenceLF}. However,
in the presence of universes and large eliminations, there is no
underlying simple type.  Of course, we can take a type as its own
shape, but we want at least that $\Nat \alpha$ and $\Nat \beta$ have
the same shape even for different $\alpha, \beta$.
Also all neutral types can be summarized under a single shape.

We make our intuition precise by defining a relation $T \shape S$
between type values, to express that $S$ is a possible shape of type
$T$.  The asymmetry of this relation stems from the case for function
types.  At function types
$\piT A B \shape \piT R S$, we take $S$ to be a family over domain
$A$, not $R$!  We cannot take $R$ since we have to compare families $B$ and $S$
at a common domain, and $A$ and $R$ are not equal.

Fig.~\ref{fig:shape} defines \fbox{$T \shape S$} for $T \in \SET[\ell]$.
We call $T$ the \emph{template} and $S$ one of its possible \emph{shapes}.
%% WORKAROUND SINCE \shape does not seem to work in \caption
\newbox{\TshapeS}\savebox{\TshapeS}{\fbox{$T \shape S$}}
\begin{figure}
\hrulefill
\begin{gather*}
  \ru{T \evalsto N \quad \
      S \evalsto N'
    }{T \shape S}
\qquad
  \ru{T \evalsto \piT A B \quad \
      S \evalsto \piT{A'}{B'} \quad \
      A \shape A' \quad \
      B[u] \shape B'[u'] \mforall u = u' \in A
    }{T \shape S}
\\[2ex]
   \ru{T \evalsto \Set[\ell] \qquad
       S \evalsto \Set[\ell]
    }{T \shape S}
\qquad
  \ru{T \evalsto \piT \Size B \qquad
      S \evalsto \piT{\Size}{B'} \qquad
      B[\alpha] \shape B'[\alpha] \mforall \alpha \in \SIZE
    }{T \shape S}
\\[2ex]
  \ru{T \evalsto \Nat \alpha \qquad
      S \evalsto \Nat \beta
    }{T \shape S}
\qquad
  \ru{T \evalsto \forallT B \qquad
      S \evalsto \forallT{B'} \qquad
      B[\alpha] \shape B'[\alpha'] \mforall \alpha,\alpha' \in \SIZE
    }{T \shape S}
\end{gather*}
\hrulefill
\caption{Type shapes \usebox{\TshapeS}\,.}
\label{fig:shape}
\end{figure}
Note that $T \in \SET[\ell]$ and $T \shape S$ do not imply $S \in \SET[\ell]$.
Type shapes are not well-defined types in general.
For instance, assume a term $F : \Nat 0 \to \Set[0]$ which diverges if applied to a successor term.
Then $T := \funT x {\Nat 0} {F\,x}$ is a well-defined type; we have $T \in \SET[0]$.
Now consider $S := \funT x {\Nat \infty} {F\,x}$.
We have $T \shape S$, but $S$ is not well-defined; $S \not\in \SET[0]$.
% $\funT x {\Nat 0} {F\,x} \shape , but the latter one is not a well-defined type.

\begin{lemma}[Types are their own shapes]
  If\/ $T = T' \in \SET[\ell]$ then $T \shape T'$.
\end{lemma}

\begin{lemma}[Templates are up to equality]
  If\/ $T = T' \in \SET[\ell]$ and $T' \shape S$ then $T \shape S$.
\end{lemma}

However, templates are not closed under subtyping in either direction because subtyping is contravariant for function type domains but the shape relation is covariant.

Further, it is not true that equal types make equally good shapes.  We do not have that
$T \shape S$ and $S = S' \in \SET[\ell]$ imply $T \shape S'$.  This property fails for function types.
Given $\piT U T \shape \piT R S$ and $\piT R S = \piT {R'}{S'} \in \SET[\ell]$ we would need to show that $T[u] \shape S'[u']$ for all $u = u' \in U$, but we only have $S[u] = S'[u'] \in \SET[\ell]$ for all $u = u' \in R$, thus the induction does not go through.  The fact that $U \shape R$ does not give us a handle on their inhabitants, we would need a stronger relation such as $U \leq R \in \TYPE$.
It is possible to construct an actual counterexample, using
$\piT {R'} S' =  \funT x {\Nat 0} {F\,x}$ from above and $\piT R S = \funT x {\Nat 0} {G\,x}$
such that $G$ is defined on all of $\Nat \infty$ but agrees with $F$ only on $x \in \Nat 0$.
Then $\piT U T = \funT x {\Nat \infty} {G\,x}$ gives the desired counterexample.

% Note that while such examples exist in the semantics, they probably do not exist in the syntax (where no well-typed term is diverging).  However, it is not clear to us how to define

% %% WRONG
% \begin{lemma}[Subtypes are valid templates]
%   Let $T \in \SET[\ell]$ and $T' \in \SET[\ell']$.
%   If\/ $T \leq T'$ and $T' \shape S'$ then $T \shape S'$.
% \end{lemma}
% \begin{proof}
% By induction on the derivations.
% \begin{caselist}

% \nextcase $T \evalsto \piT A B$ and $T' \evalsto \piT{A'}{B'}$ and $T' \evalsto \piT R S$.
% \\
% We have $A \shape R$ by induction hypothesis on $A' \leq A$ and $A' \shape R$.  No!
% \end{caselist}
% \end{proof}

Shapes are used to direct $\eta$-expansion when we reflect neutrals into semantic types and reify semantic values to long normal forms.  The following theorem is the heart of our technical development.

\begin{theorem}[Reflection and reification]
\label{thm:rere}
Let $T \in \SET[\ell]$ and $T \shape S_1$ and $T \shape S_2$.
\begin{enumerate}
\item \label{it:up}
If\/ $n_1 = n_2 \in \NE$ then $\up{S_1}{n_1} = \up{S_2}{n_2} \in T$.
\item \label{it:down}
If\/ $t_1 = t_2 \in T$ then $\down{S_1}{t_1} = \down{S_2}{t_2} \in \NF$.
\end{enumerate}
\end{theorem}
\begin{proof*}
By induction on $T \in \SET[\ell]$ and cases on $T \shape S_1$ and $T \shape S_2$.
\SHORTLONG{\qed}{
\begin{caselist}

\nextcase $T \evalsto \piT A B$ with $A \in \SET[\ell]$ and
      $B[u] = B[u'] \in \SET[\ell] \mforall u = u' \in A$
\begin{gather*}
%   \ru{A \in \SET[\ell] \qquad
%       B[u] = B[u'] \in \SET[\ell] \mforall u = u' \in A
%     }{T \in \SET[\ell]}
% \\[2ex]
  \ru{S_1 \evalsto \piT{A_1}{B_1} \qquad
      A \shape A_1 \qquad
      B[u] \shape B_1[u'] \mforall u = u' \in A
    }{T \shape S_1}
\\[1.5ex]
  \ru{S_2 \evalsto \piT{A_2}{B_2} \qquad
      A \shape A_2 \qquad
      B[u] \shape B_2[u'] \mforall u = u' \in A
    }{T \shape S_2}
\end{gather*}
\begin{enumerate}
\item To show $\up{S_1}{n_1} = \up{S_2}{n_2} \in T$ assume arbitrary $u_1 = u_2 \in A$.
  Let $d_i = \down{A_i}{u_i}$.
  By induction hypothesis (\ref{it:down}) with shapes $A \shape A_1$ and $A \shape A_2$
  we get $d_1 = d_2 \in \NF$.
  Thus, $n_1\,d_1 = n_2\,d_2 \in \NE$ by Lemma~\ref{lem:closne}, and
  by induction hypothesis (\ref{it:up}) with shapes
  $B[u_1] \shape B_1[u_1]$ and $B[u_1] \shape B_2[u_2]$ we obtain
  $\up{B_1[u_1]}(n_1\,d_1) = \up{B_2[u_2]}(n_2\,d_2) \in B[u_1]$.
  With $(\up{S_i}{n_i})\,u_i \evalsto \up{B_i[u_i]}(n_i\,d_i)$ we are done by definition of $\EL(T)$.

\item We assume $k \in \NN$ and show $\R k {\down{S_i}{t_i}} \lambda v_i$ for some normal forms
$v_1 \nfeq v_2$.  Let $u_i = \up{A_i} \lev k$.  Note that $u_1 = u_2 \in A$ by induction hypothesis, since $\var k = \var k \in \NE$ by Lemma~\ref{lem:closne}.
It is sufficient to show
$\R{k+1}{\down{B_i[u_i]}{(t_i\,u_i)}} {v_i}$.
By definition of $\EL(T)$ we have $t_1\,u_1 = t_2\,u_2 \in B[u_1]$, thus, by induction hypothesis,
$\down{B_1[u_1]}(t_1\,u_1) = \down{B_2[u_2]}(t_2\,u_2) \in \NF$, which delivers $v_1$ and $v_2$ for $k+1$.
\end{enumerate}

\nextcase $T \evalsto \forallT B$ with $B[\alpha] \in \SET[\ell] \mforall \alpha \in \SIZE$
\begin{gather*}
%   \ru{B[\alpha] \in \SET[\ell] \mforall \alpha \in \SIZE
%     }{T \in \SET[\ell]}
% \\[2ex]
  \ru{S_1 \evalsto \forallT{B_1} \qquad
      B[\alpha] \shape B_1[\alpha'] \mforall \alpha, \alpha' \in \SIZE
    }{T \shape S_1}
\\[1.5ex]
  \ru{S_2 \evalsto \forallT{B_2} \qquad
      B[\alpha] \shape B_2[\alpha'] \mforall \alpha, \alpha' \in \SIZE
    }{T \shape S_2}
\end{gather*}
\begin{enumerate}
\item To show $\up{S_1}{n_1} = \up{S_2}{n_2} \in T$ assume arbitrary $\alpha_1,\alpha_2 \in \SIZE$.
  Since $n_1 \ann{\alpha_1} = n_2 \ann{\alpha_2} \in \NE$ by Lemma~\ref{lem:closne}, we obtain
  $\up{B_1[\alpha_1]}{(n_1 \ann{\alpha_1})} = \up{B_2[\alpha_2]}{(n_2 \ann{\alpha_2})} \in B[\alpha_1]$
  by induction hypothesis.
  Thus, $(\up{S_1}{n_1}) \ann{\alpha_1} = (\up{S_2}{n_2}) \ann{\alpha_2} \in B[\alpha_1]$
  by weak head expansion, which entails the goal by definition of $\EL(T)$.
\item Assume $k \in \NN$ and note that $\lev k = \lev k \in \SIZE$, hence,
  $t_1\,\ann{\lev k} = t_2\,\ann{\lev k} \in B[\lev k]$.  Thus, by induction hypothesis,
  $\R{k+1}{\down{B_i[\lev k]}(t_i\,\ann{\lev k})}{v_i}$ with $v_1 \nfeq v_2$, and finally
  $\R k {\down{S_i} t_i} {\lambda v_i}$ by definition of read back.
\qed
\end{enumerate}

\end{caselist}
} % END SHORTLONG
\end{proof*}

\begin{corollary}
  \label{cor:rere}
  Let\/ $T \in \SET[\ell]$.
  \begin{enumerate}
  \item If\/ $n = n' \in \NE$ then $\up T n = \up T n' \in T$.
  \item If\/ $t = t' \in T$ then $\down T t = \down T {t'} \in \NF$.
  \end{enumerate}
\end{corollary}


\subsection{Computation with natural numbers}
\label{sec:comp}

In this section we show that the eliminations for natural numbers are accurately modeled.
\begin{lemma}[Case]
  \label{lem:case}
If\/ $a = a' \in \Nat (\alpha+1)$
and $B = B' \in \Nat (\alpha+1) \to \Set[\ell]$
and $f_z = f_z' \in B\,(\zero \beta)$
and $f_s = f_s' \in \funT x {\Nat \alpha} B\,(\suc \gamma x)$
then $a\,\case[\ell] B {f_z}{f_s} = a'\,\case[\ell] {B'} {f_z'}{f_s'} \in B\,a$.
\end{lemma}
\begin{proof*}
By induction on $a = a' \in \Nat(\alpha+1)$.
\SHORTLONG{\qed}{
\begin{caselist}

\nextcase $a \evalsto \zero \beta$ and $a' \evalsto \zero{\beta'}$.
Since our PERs are closed under weak head equality,
and, for instance, $a\, \case[\ell] B {f_z}{f_s}$ has the same weak head normal form as $f_z$,
it suffices to show $f_z = f_z' \in B\,(\zero \beta)$, which is one of our assumptions.

\nextcase $a \evalsto \suc \beta b$ and $a' \evalsto \suc {\beta'}{b'}$ with $b = b' \in \Nat \alpha$.
Again, it suffices to show
$f_s\,b = f_s'\,b' \in B\,(\suc \beta b)$, which is an instance of our last assumption.

\nextcase $a \evalsto \up T n$ and $a' \evalsto \up {T'} n'$ with $n = n' \in \NE$.
Let $D = \down{\Nat \infty \to \Set[\ell]} B$
and $d_z = \down{B\,(\zero \infty)} f_z$
and $d_s = \down{\funS x {\Nat\,\infty} {B\,(\suc \infty x)}} f_s$
and $e = \case[\ell] D {d_z}{d_s}$.
% $e = \case[\ell]
%   {(\down{\Nat \infty \to \Set[\ell]} B)}
%   {(\down{B\,(\zero \infty)} f_z)}
%   {(\down{\funS x {\Nat\,\infty} {B\,(\suc \infty x)} f_s)}$
Let $D',d_z',d_s',e'$ be defined analogously from $B',f_z',f_s'$.  It suffices to show $e = e' \in \ELIM$, since then we have $n\,e = n'\,e' \in \NE$ by the closure properties of $\NE$ (Lemma~\ref{lem:closne}),
and $\up{B[a]} (n\,e) = \up{B'[a']} (n'\,e') \in B[a]$ by reflection (Theorem~\ref{thm:rere}).
The remaining goal $\case[\ell] D {d_z}{d_s} = \case[\ell] {D'} {d_z'}{d_s'} \in \ELIM$ follows by the closure properties for eliminations (Lemma~\ref{lem:closelim}), since $D = D' \in \NF$ and $d_z = d_z' \in \NF$ and $d_s = d_s' \in \NF$ all hold by reification (Theorem~\ref{thm:rere}).
\qed
\end{caselist}
} % END SHORTLONG
\end{proof*}

\begin{lemma}[$\NAT$ is cocontinuous]
  \label{lem:limit}
  $\NAT(\infty) = \bigcup_{\alpha < \infty} \NAT(\alpha)$.
\end{lemma}
\begin{proof}
  By induction on $a = a' \in \NAT(\infty)$, we can easily show $a = a' \in \NAT(\alpha)$ for some $\alpha < \infty$.
  For instance, $\alpha$ could be number of uses of the successor rule plus one.
\end{proof}

%A type constructor $B \in \FixK\,\ell$ is \emph{admissible for recursion}, \fbox{$B \in \ADM$}, if
%$\bigcap_{
\noindent
As the semantic counterpart of judgement $\Gamma \der T : \Adm \ell$,
let us write \fbox{$B = B' \in \Adm\ell$} iff $B = B' \in \FixK\,\ell$ and
for all $\beta \in \SIZE$ and $a \in \Nat \beta$ we have
$B\,\beta\, a \leq B\,\infty\,a \in \TYPE$ and
$B'\,\beta\, a \leq B'\,\infty\,a \in \TYPE$.
\begin{lemma}[Fix]
Let $g = a \, \fix[\ell] B f$ and $g' = a'\,\fix[\ell]{B'}{f'}$.
If\/ $a = a' \in \Nat \alpha$
and $B = B' \in \Adm\ell$
and $f = f' \in \FixT\,B$
then $g = g' \in B\,\alpha\,a$.
\end{lemma}
\begin{proof*}
By well-founded induction on $\alpha$.
\SHORTLONG{\qed}{
\begin{caselist}

\nextcase $\alpha < \infty$ and $a \evalsto \up{T}n$ and $a' \evalsto \up{T'}{n'}$ and $n = n' \in \NE$.
In this case $g$ and $g'$ evaluate to neutral applications of $\tfix$.  The proof proceeds analogously to Lemma~\ref{lem:case}.

\nextcase $\alpha < \infty$ and $a \evalsto c$ and $a' \evalsto c'$.  Then $\alpha = \beta + 1$ with $\beta<\infty$.
The weak head normal form of $g$ equals the weak head normal form of
$h := f\,\ann \gamma\,(\lambda x.\,x\,\fix[\ell] B f)\,c$ where $\gamma$ is the size annotation of $c$.
It suffices to show $h = h' \in B\,\alpha\,a$ for $h'$ defined analogously from $B',f',c'$.
This follows from the assumption on $f, f'$ if we manage to show
$(\lambda x.\,x\,\fix[\ell] B f) = (\lambda x.\,x\,\fix[\ell] {B'} {f'}) \in
\funT x {\Nat\beta} {B\,\beta\,x}$.
To this end, assume $b = b' \in \Nat\beta$ and show
$b\,\fix[\ell] B f = b'\,\fix[\ell] {B'} {f'} \in B\,\beta\,b$.
However, this is an instance of the induction hypothesis thanks to $\beta < \alpha$.


\nextcase $\alpha = \infty$.
Note that $a = a' \in \Nat \alpha$ for some $\alpha < \infty$ by Lemma~\ref{lem:limit}.
By induction hypothesis, $g = g' \in B\,\alpha\,a$.  Since
$B\,\alpha\,a \leq B\,\infty\,a$ by admissibility of $B$, the goal
$g = g' \in B\,\infty\,a$ follows by subsumption.
\qed
\end{caselist}
} % END SHORTLONG
\end{proof*}

\subsection{Fundamental Theorem}
\label{sec:fund}

In this section we show that the declarative judgements are sound, in
particular, well-formed syntactic types map to semantic types, and
definitionally equal terms map to related values in the PER model.
The proof runs the usual course.  First, we define inductively a
PER of substitutions
\fbox{$\eta = \eta' \eeq \rho \in \Gamma$}\,.
\begin{gather*}
  \ru{
    }{\sempty = \sempty \eeq \sempty \in \cempty}
\qquad
  \ru{\eta = \eta' \eeq \rho \in \Gamma \qquad
      T\rho \in \SET[\ell] \qquad
      u = u' = t \in T \rho
    }{\sext \eta u = \sext{\eta'}{u'} \eeq \sext{\rho}{t} \in \cext \Gamma T}
\\[2ex]
  \ru{\eta = \eta' \eeq \rho \in \Gamma \qquad \alpha \in \SIZE
    }{\sext \eta \alpha = \sext{\eta'}{\alpha} \eeq \sext{\rho}{\alpha} \in \cext \Gamma \Size}
\qquad
  \ru{\eta = \eta' \eeq \rho \in \Gamma \qquad \alpha,\alpha',\beta \in \SIZE
    }{\sext \eta \alpha = \sext{\eta'}{\alpha'} \eeq \sext{\rho}{\beta} \in \erext \Gamma \Size}
\end{gather*}
We write $\rho \in \Gamma$ for $\rho = \rho \eeq \rho \in \Gamma$.
\begin{lemma}[Resurrection]
  \label{lem:resenv}
  If\/ $\eta = \eta' \eeq \rho \in \Gamma$ then $\rho \in \resurrect\Gamma$.
\end{lemma}

\noindent
Then, in Fig.~\ref{fig:sem}, we define semantic counterparts of our declarative judgements by recursion on the length of the context.
\begin{figure}
\hrulefill
\[
\begin{array}{l@{\quad}l@{\quad}l}
  \models () & \defas & \mtrue \\
  \models \eext \Gamma \Size & \defas & \models \Gamma \\
  \models \cext \Gamma s     & \defas & \models \Gamma \\
  \models \cext \Gamma T     & \defas & \models \Gamma \mand \resurrect\Gamma \models T
\\[2ex]
  \Gamma \models s & \defas & \models \Gamma \\
%  \Gamma \models s & \defas & \mtrue \\
  \Gamma \models T & \defas & \Gamma \models T = T \\
  \Gamma \models T = T' & \defas & \Gamma \models T = T' : s \mforsome s %\Set[\ell] \mforsome \ell
\\[2ex]
  \Gamma \models T : \Adm\,\ell & \defas & \Gamma \models T : \FixK\,\ell \mand
    T\eta = T'\eta' \in \Adm\,\ell
    % \EL(T\eta) \subseteq \EL(T'\eta')
    \mforall \eta = \eta' \eeq \rho \in \Gamma
\\
  \Gamma \models T \leq T' & \defas & \Gamma \models T \mand \Gamma \models T' \mand
    T\eta \leq T'\eta' \in \TYPE
    % \EL(T\eta) \subseteq \EL(T'\eta')
    \mforall \eta = \eta' \eeq \rho \in \Gamma
\\[2ex]
  \Gamma \models t : T & \defas & \Gamma \models t = t : T \\
  \Gamma \models t = t' : T & \defas & %\models \Gamma \mand
    % \resurrect\Gamma \models T \mand
    \models \cext \Gamma T \mand
    t \eta = t' \eta' \in T \rho \mforall \eta = \eta' \eeq \rho \in \Gamma
\\[2ex]
  \Gamma \models \sigma : \Delta & \defas & \Gamma \models \sigma = \sigma \eeq \sigma : \Delta \\
  \Gamma \models \sigma = \sigma' \eeq \tau : \Delta & \defas &
    \models \Gamma \mand \models \Delta \mand
    \sigma \eta = \sigma' \eta' \eeq \tau \rho \in \Delta
    \mforall \eta = \eta' \eeq \rho \in \Gamma
\end{array}
\]
\hrulefill
\caption{Semantic judgements.\label{fig:sem}}
\end{figure}

\begin{theorem}[Fundamental theorem]
  \label{thm:fund}
  \bla
  \begin{enumerate}
  \item
  If\/ $\der \Gamma$ then $\models \Gamma$.
  \item
  If\/ $\Gamma \der J$ then % $\models \Gamma$ and
  $\Gamma \models J$.
  \end{enumerate}
\end{theorem}
\SHORTVERSION{
\begin{proof}
Simultaneously, by induction on the derivation.
\end{proof}
}
\LONGVERSION{  % BEGIN LONGVERSION
\begin{proof*}
Simultaneously, by induction on the derivation.
% The soundness of subtyping and the conversion rule is due to subsumption (lemmata \ref{lem:subsump} and \ref{lem:usubsump}).

\begin{caselist}
\nextcase $\forall$-introduction.
\[
  \ru{\erext \Gamma \Size \der t = t' : T
    }{\Gamma \der \lambda t = \lambda t' : \forall T}
\]
First $\models \Gamma$ follows from the induction hypothesis $\models {\erext \Gamma \Size}$.
To show $\resurrect\Gamma \models \forall T$,
assume $\eta = \eta' \eeq \rho \in \resurrect \Gamma$
and show $(\forall T)\eta = (\forall T)\eta' \in \SET[\ell]$ for some $\ell$.
To this end, assume $\alpha \in \SIZE$ and show $T(\eta,\alpha) = T(\eta',\alpha) \in \SET[\ell]$.
Note that $(\eta,\alpha) = (\eta',\alpha) \eeq (\rho,\alpha) \in
\resurrect {\erext \Gamma \Size} = \cext {\resurrect\Gamma}\Size$,
thus, we can instantiate the induction hypothesis and obtain our goal.

For the main goal,
assume $\eta = \eta' \eeq \rho \in \Gamma$ and
show $(\lambda t)\eta = (\lambda t')\eta' \in (\forall T)\rho$.
To this end, assume arbitrary $\alpha,\alpha',\beta \in \SIZE$ and show
$t(\eta,\alpha) = t'(\eta',\alpha') \in T(\rho,\beta)$.
Since $(\eta,\alpha) = (\eta',\alpha') \eeq (\rho,\beta) \in \erext \Gamma \Size$,
we conclude by induction hypothesis.

\nextcase $\forall$-elimination.
\[
  \ru{\Gamma \der t = t' : \forall T \qquad
      \Gamma \der a, a' : \Size \qquad
      \resurrect\Gamma \der b : \Size
    }{\Gamma \der t \ann a = t' \ann {a'} : T[b]}
\]
First, $\models \Gamma$ follows by induction hypothesis.
For goal $\resurrect \Gamma \models T[b]$,
assume $\eta = \eta' \eeq \rho \in \resurrect\Gamma$ and show
$T[b]\eta = T[b]\eta' \in \SET[\ell]$ for some $\ell$.
By induction hypothesis,  $b\eta = b\eta' \in \SIZE$.
% , thus,
% $(\eta,b\eta) = (\eta',b\eta') \eeq (\rho,b\eta) \in \cext{\resurrect\Gamma}\Size$
By another induction hypothesis, $(\forall T)\eta = (\forall T)\eta' \in \SET[\ell]$,
which by definition entails our goal $T(\eta, b\eta) = T(\eta', b\eta') \in \SET[\ell]$.


For the remaining main goal,
assume $\eta = \eta' \eeq \rho \in \Gamma$ and
show $t \ann a \eta = t' \ann{a'} \eta' \in T[b]\rho$.
By definition of substitution, it suffices to show
$t \eta \ann{a \eta} = t' \eta' \ann{a' \eta'} \in T(\rho, b \rho)$.
By induction hypothesis,
$t \eta = t' \eta' : (\forall T) \rho$, thus, by definition of this PER,
$t \eta \ann {\alpha_1} = t' \eta' \ann{\alpha_2} \in T(\rho, b')$ for any size values $\alpha_1$, $\alpha_2$, and $b'$.
We conclude by choosing $\alpha_1 = a \eta$ and $\alpha_2 = a' \eta'$ and $b' = b \rho$.

We now argue that this choice is possible,
namely that $a \eta, a'\eta, b\rho \in \SIZE$.
Note that the induction hypothesis gives us
$a \eta  = a  \eta' \in \SIZE$ and
$a' \eta = a' \eta' \in \SIZE$.
By resurrection (Lemma~\ref{lem:resenv}) we have $\rho \in \resurrect\Gamma$,
thus, by induction hypothesis, $b \rho \in \SIZE$.
\qed
\end{caselist}
\end{proof*}
} % END LONGVERSION

\subsection{Completeness of NbE}
\label{sec:compl}

From the fundamental theorem, we harvest completeness of NbE in this
section, \ie, we show that definitionally equal terms have the same
normal form.
We may write simply $\Gamma$ for its length $|\Gamma|$ when there is no
danger of confusion, for instance in de Bruijn level $\var\Gamma$ or
in read back $\tR_{\Gamma}$.
%We write $\var\Gamma$ for $\var{|\Gamma|}$.
We define the \emph{identity environment} \fbox{$\rho_\Gamma$} by induction on $\Gamma$,
setting $\rho_{\cempty} = \sempty$ and
$\rho_{\eext \Gamma \Size} = (\rho_\Gamma, \var\Gamma)$ and
$\rho_{\cext \Gamma T} = (\rho_\Gamma, \up{T\rho_\Gamma} \var\Gamma)$.
% \[
% \begin{array}{lll}
%   \rho_{\cext \Gamma T} & = & (\rho_\Gamma, \up{T\rho_\Gamma} \var\Gamma) \\
%   \rho_{\eext \Gamma \Size} & = & (\rho_\Gamma, \var\Gamma) \\
% \end{array}
% \]
\begin{lemma}[Identity environment]
  If\/ $\der \Gamma$ then
  $\rho_\Gamma \in \Gamma$.
  % $\rho_\Gamma = \rho_\Gamma \eeq \rho_\Gamma \in \Gamma$
\end{lemma}
\LONGVERSION{
\begin{proof*}
By induction on $\der \Gamma$.
\begin{caselist}

\nextcase
\vspace{-3ex}
\[
  \ru{\der \Gamma \qquad \resurrect\Gamma \der T
    }{\der \cext\Gamma T}
\]
By induction hypothesis $\rho_\Gamma \in \Gamma$.
By resurrection (Lemma~\ref{lem:resenv}) $\rho_\Gamma \in \resurrect\Gamma$.
By the fundamental theorem (Thm.~\ref{thm:fund}) we have $A := T\rho_\Gamma \in \SET[\ell]$ for some $\ell$.
By reflection (Cor.~\ref{cor:rere}) it follows that $\up A \var\Gamma \in A$, thus
$(\rho_\Gamma, \up A \var\Gamma) \in \cext \Gamma T$.

\nextcase
\vspace{-3ex}
\[
  \ru{\der \Gamma
    }{\der \eext\Gamma \Size}
\]
By induction hypothesis $\rho_\Gamma \in \Gamma$.  Since $\var\Gamma \in \SIZE$ we conclude
$(\rho_\Gamma, \var\Gamma) \in \eext\Gamma \Size$.
\qed
\end{caselist}
\end{proof*}
} % END LONGVERSION

We now define the normalization relation
$\fbox{$\nbe \Gamma T t \evalsto v$} \defas \R {\Gamma} {\down{T \rho_\Gamma} (t \rho_\Gamma)} v$.
Whenever $\nbe \Gamma T t \evalsto v$, we may write $\nbe \Gamma T t$ for $v$.

\begin{theorem}[Completeness of NbE]
  % If\/ $\Gamma \der t = t' : T$ then there is a normal form $v$ such that
  % $\nbe \Gamma T t \evalsto v$ and $\nbe \Gamma T {t'} \evalsto v$.
  If\/ $\Gamma \der t = t' : T$ then there are normal forms $v \nfeq v'$ such that
  $\nbe \Gamma T t \evalsto v$ and $\nbe \Gamma T {t'} \evalsto v'$.
\end{theorem}
\begin{proof}
  By the fundamental theorem, $T \rho_\Gamma \in \SET[\ell]$ for some $\ell$ and
  $t \rhog = t' \rhog \in T\rhog$.  By reification (Cor.~\ref{cor:rere}) we have
  $\down{T\rhog} (t\rhog) = \down{T\rhog}(t'\rhog) \in \NF$ which implies the theorem
  by read back with $k = |\Gamma|$.
\end{proof}



\section{Soundness  of Normalization by Evaluation}
\label{sec:soundnbe}

In this section, we show that NbE is sound for judgmental equality,
i.e., that \emph{same normal form} implies \emph{definitional equality}.  The proof
follows \citet{abelCoquandDybjer:lics07} and
\citet{fridlenderPagano:tlca13} and defines a Kripke logical relation
$\LR \Gamma t T f A$ between a well-typed term $\Gamma \der t : T$ and
a value $f \in A$.
\LONGVERSION{
However, in contrast to the cited works,
the logical relation defined in the following will also yield a weak
head normalization theorem.
} % END LONG VERSION

First, let us define some auxiliary judgements that relate a
well-formed syntactic object to a value, via read back.
They will constitute the logical relation for base types,
but need to be strengthened for function types.
\begin{alignat*}{8}
& \Gamma \der a && \doteq \tRsize\, \alpha
  && \quad\defas\quad
  && \forall \xi : \Gamma' \leq \Gamma.\ \
  && \mathrlap{ \RSize {\Gamma'} \alpha {a\xi} }
\\[-0.6ex]
& \Gamma \der T && \doteq \tRty\, A  : s
  && \quad\defas\quad
  && \forall \xi : \Gamma' \leq \Gamma.\ \
  && \exists V.\
  && \RTy{\Gamma'} A V
  && ~\mand~ \Gamma' \der T\xi = V : s
\\[-0.6ex]
& \Gamma \der t && \doteq \tR\, d  : T
  && \quad\defas\quad
  && \forall \xi : \Gamma' \leq \Gamma.\ \
  && \exists v.\
  && \R{\Gamma'} d v
  && ~\mand~ \Gamma' \der t\xi = v : T\xi
\\[-0.6ex]
& \Gamma \der t && \doteq \tRne\, n  : T
  && \quad\defas\quad
  && \forall \xi : \Gamma' \leq \Gamma.\ \
  && \exists m.\
  && \RNe{\Gamma'} n m
  && ~\mand~ \Gamma' \der t\xi = m : T\xi
\end{alignat*}
% \[
% \begin{array}{lll}
% \Gamma \der a \doteq \tRsize\, \alpha
%   & \defas &
%   \forall \xi : \Gamma' \leq \Gamma.\ \ \RSize {\Gamma'} \alpha {a\xi}
% \\
% \Gamma \der T \doteq \tRty\, A : s
%   & \defas &
%   \forall \xi : \Gamma' \leq \Gamma.\ \
%   \exists V.\
%   \RTy{\Gamma'} A V \mand
%   \Gamma' \der T\xi = V : s
% \\
% \Gamma \der t \doteq \tR\, d : T
%   & \defas &
%   \forall \xi : \Gamma' \leq \Gamma.\ \
%   \exists v.\
%   \R{\Gamma'} d v \mand
%   \Gamma' \der t\xi = v : T\xi
% \\
% \Gamma \der t \doteq \tRne\, n : T
%   & \defas &
%   \forall \xi : \Gamma' \leq \Gamma.\ \
%   \exists m.\
%   \RNe{\Gamma'} n m \mand
%   \Gamma' \der t\xi = m : T\xi
% \end{array}
% \]
% \[
%   \fbox{$\LRSize \Gamma a \alpha$} \defas
%   \forall \xi : \Gamma' \leq \Gamma.\ \
%   \RSize {\Gamma'} \alpha {a\xi}
%   % \exists a'.\
%   % \RSize {\Gamma'} \alpha a' \mand
%   % \Gamma' \der a\xi = a' : \Size
% \]
By definition, these relations are closed under subsumption and
weakening, e.g., if\/ $\RD \Gamma t d T$ and $\Gamma \der T \leq T'$ then $\RD \Gamma t d T'$,
and if\/ $\xi : \Gamma' \leq \Gamma$ then $\RD{\Gamma'}{t\xi}d{T\xi}$.
\LONGVERSION{
\begin{lemma}[Fresh variable readback]
  \label{lem:freshread}
  If\/ $\Gamma \der U$ then $\RNE{\cext \Gamma U} {\ind 0} {\var \Gamma} {U \slift}$.
\end{lemma}
\begin{proof}
  Assume $\xi : \Gamma' \leq \cext \Gamma U$.
  Note that $\RNe{\Gamma'} {\var\Gamma} {\ind i}$ where
  $i = |\Gamma'| - |\cext \Gamma U|$ is the length of the context extension.
  Since $\ind 0 \xi = \ind i$, we conclude
  $\Gamma' \der \ind 0 \xi = \ind i : U \slift \xi$
  by weakening of the judgement $\cext \Gamma U \der \ind 0 = \ind 0 : U \slift$.
\end{proof}
} % END LONGVERSION
\begin{lemma}[Closure properties for neutrals]
\label{lem:rclosne}
\bla
\begin{enumerate}
\item If\/ $\RNE \Gamma t n \piT U T$ and $\RD \Gamma u d U$ then $\RNE \Gamma {t\,u} {n\,d} {T[u]}$.
\item If\/ $\RNE \Gamma t n \piT \Size T$ and $\RSIZE \Gamma a \alpha$ then $\RNE \Gamma {t\,a} {n\,\alpha} {T[a]}$.
\item \label{it:closneall}
If\/ $\RNE \Gamma t n \forallT T$ and $\resurrect\Gamma \der a,b : \Size$ and $\alpha \in \SIZE$ then $\RNE \Gamma {t\,\ann a} {n\,\ann \alpha} {T[b]}$.
%% TOO WEAK:
% \item If\/ $\RNE \Gamma t n \forallT T$ and $\RSIZE {\resurrect\Gamma} a \alpha$ then $\RNE \Gamma {t\,\ann a} {n\,\ann \alpha} {T[a]}$.
\end{enumerate}
\end{lemma}
\LONGVERSION{
\begin{proof*}
For (\ref{it:closneall}), assume
$\xi : \Gamma' \leq \Gamma$.
We have to show that there exists a neutral normal form $m'$ such that
$\RNe {\Gamma'} {n\, \ann \alpha} m'$ and
$\Gamma' \der (t\, \ann a)\xi = m' : T[b]\xi$.
Sizes can always be read back, thus, let $\RSize {\Gamma'} \alpha {a_0}$,
which guarantees $\resurrect{\Gamma'} \der a_0 : \Size$.
By assumption $\RNE \Gamma t n {\forallT T}$, there is an $m$ with
$\RNe {\Gamma'} n m$ and
$\Gamma' \der t\xi = m : (\forallT T)\xi$.
The latter equation implies
$\Gamma' \der t\xi \ann {a\xi} = m \ann {a_0} : T(\xi,b\xi)$
by irrelevant size application to
$\resurrect{\Gamma'} \der a\xi, a_0, b \xi : \Size$,
thus we are done with $m' := m \ann{a_0}$.
\qed
\end{proof*}
} % END LONGVERSION

Let \fbox{$\Gamma \der T \evalsto W : s$} denote the conjunction of $T \evalsto W$ and $\Gamma \der T = W : s$.
We simultaneously define
\fbox{$\LRTS \Gamma {T'} {A'} s$} for $\Gamma \der T' : s$
and \fbox{$\LR \Gamma t {T'} f {A'}$} for $\Gamma \der t : T'$ and $f \in A'$
by induction on ${A'} \in s$.

\begin{caselist}
\fleq
\newlength{\colw}
\setlength{\colw}{\widthof{$\LR{\Gamma}{U}{T'}{B}{A'}$}}

\vspace{2ex}
\nextcase $A' \evalsto N$ neutral.
\[
\begin{array}{p{\colw}ll}
  $\LRTS{\Gamma}{T'}{A'} s$ & \defiff &
  \mbox{$\Gamma \der T' \evalsto n : s$ for some neutral $n$ and
  $\Gamma \der T' \doteq \tRty\,A' : s$.}
\\
  $\LR{\Gamma}{t}{T'}{f}{A'}$ & \defiff &
  \Gamma \der t \doteq \tR \, \down {A'} f : T' .
\end{array}
\]

%   \noindent
%   $\LRTS{\Gamma}{T'}{A'} s$ iff
%   $\Gamma \der T' \evalsto n : s$ for some neutral $n$ and
%   $\Gamma \der T' \doteq \tRty\,A' : s$.
%   %$\forall \xi : \Gamma' \leq \Gamma.\ \ \exists M.\ \ \RTy{\Gamma'}{A'}M \mand \Gamma' \der T'\xi = M : \Set[\ell]$.

%   \noindent
%   $\LR{\Gamma}{t}{T'}{f}{A'}$ iff
%   $\Gamma \der t \doteq \tR \, \down {A'} f : T'$.
%   % $\forall \xi : \Gamma' \leq \Gamma.\ \
%   %  \exists m. \ \
%   %  \R {\Gamma'} {\down {A'} f} m \mand
%   %  \Gamma' \der t\xi = m : T'\xi$.

\vspace{0ex}
\nextcase $A' \evalsto \Nat \alpha$.
\[
\begin{array}{p{\colw}ll}
  $\LRTS{\Gamma}{T'}{A'} s$ & \defiff &
    \mbox{$\Gamma \der T' \evalsto \Nat a : s$ for some $a$ and $\LRSize \Gamma a \alpha$.}
\\
  $\LR{\Gamma}{t}{T'}{f}{A'}$ & \defiff &
    \mbox{$\resurrect\Gamma \der T' \evalsto \Nat a : s$ for some $a$ and
  $\LRSize {\resurrect\Gamma} a \alpha$}
\\
\multicolumn 3 {@{\qquad}l} {
   \mand \Gamma \der t \doteq \tR\,\down{A'} f : \Nat a.
  }
\end{array}
\]
%   \noindent
%   $\LRTS{\Gamma}{T'}{A'} s$ iff $\Gamma \der T' \evalsto \Nat a : s$ for some $a$ and $\LRSize \Gamma a \alpha$.

%   \noindent
%   $\LR{\Gamma}{t}{T'}{f}{A'}$ iff $\resurrect\Gamma \der T' \evalsto \Nat a$ for some $a$ and
%   $\LRSize {\resurrect\Gamma} a \alpha$ and
%   $\Gamma \der t \doteq \tR\,\down{A'} f : \Nat a$.
%   % \\
%   % $\forall \xi : \Gamma' \leq \Gamma.\ \
%   %  \exists v. \ \
%   %  \R {\Gamma'} {\down {A'} f} v \mand
%   %  \Gamma' \der t\xi = v : \Nat\,a\xi$.


\vspace{0ex}
\nextcase $A' \evalsto \Set[\ell']$.
\[
\begin{array}{p{\colw}ll}
  $\LRTS {\Gamma} {T'} {A'} s$ & \defiff & \Gamma \der T' \evalsto \Set[\ell'] : s.
\\
  $\LR \Gamma U {T'} B {A'}$  & \defiff &
  \resurrect\Gamma \der T' \evalsto \Set[\ell'] : s \mand \LRT \Gamma U B {\ell'}.
\end{array}
\]
  % \noindent
  % $\LRTS {\Gamma} {T'} {A'} s$ iff $\Gamma \der T' \evalsto \Set[\ell'] : s$.

  % \noindent
  % $\LR \Gamma U {T'} B {A'}$ iff
  % $\resurrect\Gamma \der T' \evalsto \Set[\ell'] : s$ and $\LRT \Gamma U B {\ell'}$.

\vspace{0ex}
\nextcase $A' \evalsto \piT A B$.
\[
\begin{array}{p{\colw}ll}
$\LRTS \Gamma {T'} {A'} s$ & \defiff &
  \Gamma \der T' \evalsto \piT U T : s \mforsome U, T \mand \LRTS \Gamma U A s \\
\multicolumn 3 {@{\qquad}l} {
  \mand \forall \xi : \Gamma' \leq \Gamma.\ \
  \LR {\Gamma'} u {U\xi} a A \implies \LRTS {\Gamma'} {T(\xi,u)} {B[a]} s
  .
}
\\[1ex]
$\LR \Gamma t {T'} f {A'}$ & \defiff &
  \resurrect\Gamma \der T' \evalsto \piT U T : s \mforsome U, T \mand \LRTS {\resurrect\Gamma} U A s \\
\multicolumn 3 {@{\qquad}l} {
  \mand \forall \xi : \Gamma' \leq \Gamma.\ \
  \LR {\Gamma'} u {U\xi} a A \implies \LR {\Gamma'} {t\xi\,u} {T(\xi,u)} {f\,a} {B[a]}
  .
}
\end{array}
\]
% \noindent
% $\LRTS \Gamma {T'} {A'} s$ iff
% \(
% \begin{array}[t]{l}
% \Gamma \der T' \evalsto \piT U T : s \mforsome U, T \mand \LRTS \Gamma U A s \mand \\
% \forall \xi : \Gamma' \leq \Gamma.\ \
% \LR {\Gamma'} u {U\xi} a A \implies \LRTS {\Gamma'} {T(\xi,u)} {B[a]} s
% . \\
% \end{array}
% \) \\
% $\LR \Gamma t {T'} f {A'}$ iff
% \(
% \begin{array}[t]{l}
% \resurrect\Gamma \der T' \evalsto \piT U T : s \mforsome U, T \mand \LRTS {\resurrect\Gamma} U A s \mand \\
% \forall \xi : \Gamma' \leq \Gamma.\ \
% \LR {\Gamma'} u {U\xi} a A \implies \LR {\Gamma'} {t\xi\,u} {T(\xi,u)} {f\,a} {B[a]}
% .
% \end{array}
% \)

\vspace{0ex}
\nextcase $A' \evalsto \piT \Size B$.
\[
\begin{array}{p{\colw}ll}
$\LRTS \Gamma {T'} {A'} s$ & \defiff &
  \Gamma \der T' \evalsto \piT \Size T : s \mforsome T
\\
\multicolumn 3 {@{\qquad}l} {
  \mand \forall \xi : \Gamma' \leq \Gamma.\ \
  \LRSize {\Gamma'} a \alpha
  \implies \LRTS {\Gamma'} {T(\xi,a)} {B[\alpha]} s
  .
}
\\[1ex]
$\LR \Gamma t {T'} f {A'}$ & \defiff &
\resurrect\Gamma \der T' \evalsto \piT \Size T : s \mforsome T
\\
\multicolumn 3 {@{\qquad}l} {
  \mand
  \forall \xi : \Gamma' \leq \Gamma.\ \
  \LRSize {\Gamma'} a \alpha
  \implies \LR {\Gamma'} {t\xi\,a} {T(\xi,a)} {f\,\alpha} {B[\alpha]}
  .
}
\end{array}
\]
% \noindent
% $\LRTS \Gamma {T'} {A'} s$ iff
% \(
% \begin{array}[t]{l}
% \Gamma \der T' \evalsto \piT \Size T : s \mforsome T\\
% \forall \xi : \Gamma' \leq \Gamma.\ \
% \LRSize {\Gamma'} a \alpha
% \implies \LRTS {\Gamma'} {T(\xi,a)} {B[\alpha]} s
% .
% \end{array}
% \) \\
% $\LR \Gamma t {T'} f {A'}$ iff
% \(
% \begin{array}[t]{l}
% \resurrect\Gamma \der T' \evalsto \piT \Size T : s \mforsome T\\
% \forall \xi : \Gamma' \leq \Gamma.\ \
% \LRSize {\Gamma'} a \alpha
% \implies \LR {\Gamma'} {t\xi\,a} {T(\xi,a)} {f\,\alpha} {B[\alpha]}
% .
% \end{array}
% \)

\vspace{0ex}
\nextcase $A' \evalsto \forallT B$.
\[
\begin{array}{p{\colw}ll}
$\LRTS \Gamma {T'} {A'} s$ & \defiff &
  \Gamma \der T' \evalsto \forallT T : s \mforsome T
\\
\multicolumn 3 {@{\qquad}l} {
  \mand
  \forall \xi : \Gamma' \leq \Gamma,\
  {\Gamma'} \der b : \Size,\
  \beta \in \SIZE. \ \
  \LRSize {\Gamma'} b \beta
  \implies \LRTS {\Gamma'} {T(\xi,b)} {B[\beta]} s
  .
}
\\[1ex]
$\LR \Gamma t {T'} f {A'}$ & \defiff &
  \resurrect\Gamma \der T' \evalsto \forallT T : s \mforsome T
\\
\multicolumn 3 {@{\qquad}l} {
  \mand
  \forall \xi : \Gamma' \leq \Gamma,\
  %\Gamma' \der a : \Size,\
  \resurrect{\Gamma'} \der a,b : \Size,\
  \alpha,\beta \in \SIZE. \
}
\\
\multicolumn 3 {@{\qquad\qquad}l} {
  \LRSize {\resurrect{\Gamma'}} b \beta
  \implies \LR {\Gamma'} {t\xi\,\ann a} {T(\xi,b)} {f\,\ann\alpha} {B[\beta]}
  .
}
\end{array}
\]
% \noindent
% $\LRTS \Gamma {T'} {A'} s$ iff
% \(
% \begin{array}[t]{l}
% \Gamma \der T' \evalsto \forallT T : s \mforsome T\\
% \forall \xi : \Gamma' \leq \Gamma,\
% {\Gamma'} \der b : \Size,\
% \beta \in \SIZE. \ \
% \LRSize {\Gamma'} b \beta
% \implies \LRTS {\Gamma'} {T(\xi,b)} {B[\beta]} s
% .
% \end{array}
% \) \\
% $\LR \Gamma t {T'} f {A'}$ iff
% \(
% \begin{array}[t]{l}
% \resurrect\Gamma \der T' \evalsto \forallT T : s \mforsome T\\
% \forall \xi : \Gamma' \leq \Gamma,\
% %\Gamma' \der a : \Size,\
% \resurrect{\Gamma'} \der a,b : \Size,\
% \alpha,\beta \in \SIZE. \ \\ \qquad
% \LRSize {\resurrect{\Gamma'}} b \beta
% \implies \LR {\Gamma'} {t\xi\,\ann a} {T(\xi,b)} {f\,\ann\alpha} {B[\beta]}
% .
% \end{array}
% \)
\end{caselist}
We may prove theorems ``by induction on $\LRTS \Gamma T A s$'', even if in reality this will be proofs by induction on $A \in s$ and cases on $\LRTS \Gamma T A s$.
We write \fbox{$\RG \Gamma T A$} if\/ $\LRTS \Gamma T A s$ for some sort $s$.
\SHORTVERSION{The logical relations are closed under weakening.}
\LONGVERSION{ % BEGIN LONG
\begin{lemma}[Weakening]
  Let $\xi : \Gamma' \leq \Gamma$.
  \begin{enumerate}
  %% SEE ABOVE
  % \item If\/ $\LRSize \Gamma a \alpha$ then $\LRSize{\Gamma'}{a\xi}\alpha$.
  \item If\/ $\LRTS {\Gamma} T A s$ then $\LRTS{\Gamma'}{T\xi}A s$.
  \item If\/ $\LR \Gamma t T f A$ then $\LR{\Gamma'}{t\xi}{T\xi} f A$.
  \end{enumerate}
\end{lemma}
} % END LONG

%% NO LONGER TRUE AT THIS POINT
% \begin{lemma}[Compatibility with definitional equality]
%   Let $\Gamma \der T = T'$.
%   \begin{enumerate}
%   \item If\/ $\LRT \Gamma T A \ell$ then $\LRT \Gamma {T'} A \ell$.
%   \item If\/ $\LR \Gamma t T f A$ and $\Gamma \der t = t' : T$ then $\LR \Gamma {t'}{T'} f A$.
%   \end{enumerate}
% \end{lemma}

\begin{theorem}[Into and out of the logical relation]
\label{thm:into}
\bla
Let $\LRTS{\Gamma} T A s$ and $A \shape S$. Then:
%Let $A \in s$.
\begin{enumerate}

\item \label{it:into}
   If\/ $\Gamma \der t \doteq \tRne\,n : T$ then
   $\LR \Gamma t T {\up S n} A$.

\item \label{it:out}
  If\/ $\LR \Gamma t T f A$ then
  $\Gamma \der t \doteq \tR\,\down S f : T$.

\item \label{it:outty}
   %If\/ $\LRTS{\Gamma} T A s$ then
   $\Gamma \der T \doteq \tRty\,A : s$.

% \item \label{it:into}
%    $\LR \Gamma t T {\up A n} A$ if for all $\xi : \Gamma' \leq \Gamma$ there is an $m$ such that
%    $\RNe{\Gamma'}n m$ and\/ $\Gamma' \der t\xi = m : T$.

% \item \label{it:outty}
%    If\/ $\LRT{\Gamma} T A \ell$ then for all $\xi : \Gamma' \leq \Gamma$
%    there is some normal form $V$ such that
%    $\Rty{\Gamma'} A V$ and $\Gamma' \der T\xi = V : \Set[\ell]$.

% \item \label{it:out}
%   If\/ $\LR \Gamma t T f A$ then for all $\xi : \Gamma' \leq \Gamma$
%   there is some normal form $v$ such that
%   $\R{\Gamma'} {\down A f} v$ and $\Gamma' \der t\xi = v : T\xi$.

\end{enumerate}
\end{theorem}
\SHORTVERSION{
\begin{proof}
Simultaneously by induction on $\LRTS \Gamma T A s$.
\end{proof}
} % END SHORT VERSION
\LONGVERSION{
\begin{proof*}
We prove the propositions for $A'$, $S'$, and $T'$ (instead of $A$, $S$, and $T$)
simultaneously by induction on $A' \in s$.
\begin{caselist}

\nextcase $A' \evalsto \piT A B$ and $S' \evalsto \piT R S$
and $\resurrect\Gamma \der T' = \piT U T$.

\begin{enumerate}
\item % into
The premise is, after type conversion, $\Gamma \der t \doteq \tRne\, n : \piT U T$.
To demonstrate $\LR \Gamma t {T'} {\up {S'} n} {A'}$ we assume
$\xi : \Gamma' \leq \Gamma$ and $\LR{\Gamma'}{u}{U\xi} a A$ and show
$\LR{\Gamma'} {(t\xi\,u)} {T(\xi,u)} {\up{S[a]}(n\,\down A a)} {B[a]}$.
By induction hypothesis (\ref{it:out}) we have $\RD {\Gamma'} u {\down R a} {U\xi}$, and
together with the weakened premise $\Gamma' \der t\xi \doteq \tRne\, n : (\piT U T) \xi$ we get
$\Gamma' \der t\xi\, u \doteq \tRne\, (n\,\down R a) : T(\xi,u)$.
The goal follows by induction hypothesis (\ref{it:into}) for
% $B[a] \in s$.
$\LRTS{\Gamma'}{T(\xi,u)}{B[a]} s$.
% This follows by induction hypothesis (\ref{it:into}) for $B[a] \in \SET[\ell]$ if
% we can prove that for all $\xi' : \Gamma'' \leq \Gamma'$ there is a neutral normal form $m$
% such that $\RNe{\Gamma''} {(n\,\down A a)} m$ and $\Gamma'' \der (t\xi\,u)\xi' = m : T(\xi,u)\xi'$.
% Note that the last goal can be rewritten to $\Gamma'' \der t\xi\xi'\,(u\xi') = m : T(\xi\xi',u\xi')$.
% We know that $\RNe{\Gamma''} n {m_0}$ with $\Gamma'' \der t\xi\xi' = m_0 : T'\xi\xi'$.
% Thus, it is sufficient to show that there is some normal form $v$ such that
% $\R{\Gamma''} {\down A a} v$ and $\Gamma'' \der u\xi' = v : U\xi\xi'$.
% However, this follows by induction hypothesis (\ref{it:out}) on
% assumption $\LR{\Gamma'}{u}{U\xi} a A$ with $\xi'$.

\item % out of
The premise is $\LR \Gamma t {T'} f {A'}$,
which means that for all $\xi : \Gamma' \leq \Gamma$ and
$\LR {\Gamma'} u {U\xi} a A$ we have
$\LR {\Gamma'} {t\xi\,u} {T(\xi,u)} {f\,a} {B[a]}$.

To show $\Gamma \der t \doteq \tR\,\down {S'} f : {T'}$
we assume $\xi : \Gamma' \leq \Gamma$ and produce a normal form $v$
such that $\R {\Gamma'} {\down{S'} f} {\lambda v}$ and
$\Gamma' \der t\xi = \lambda v : T'\xi$.
Induction hypothesis (\ref{it:into}) on
$\RNE {\cext{\Gamma'}{U\xi}} {\ind 0} {\var{\Gamma'}} {U\xi\slift}$
gives us $\LR {\cext{\Gamma'}{U\xi}} {\ind 0} {U\xi\slift} a A$
with $a := \up R {\var{\Gamma'}}$.
Thus, we can instantiate the assumption $\LR \Gamma t {T'} f {A'}$
to obtain
$\LR {\cext{\Gamma'}{U\xi}} {(t\xi\slift)\,\ind 0} {T(\xi\slift,\ind 0)} {f\,a} {B[a]}$.
Now induction hypothesis (\ref{it:out}) yields a normal form $v$ such that
$\R {\cext{\Gamma'}{U\xi}} {\down {S[a]} (f\,a)} v$
and
$\cext{\Gamma'}{U\xi} \der (t\xi\slift)\,\ind 0 = v : T(\xi\slift,\ind 0)$.
Since $a$ is the semantic version of the last bound variable,
$\R {\Gamma'} {\down{S'} f} {\lambda v}$ follows by definition of reification.
For the final goal, we $\lambda$-abstract the definitional equality to
$\Gamma' \der \lambda.\, (t\xi\slift)\,\ind 0 = \lambda v : \piT{(U\xi)} {(T(\xi\slift,\ind 0))}$
and with $\eta$-equality and the substitution laws we get
$\Gamma' \der t\xi = \lambda v : (\piT U T)\xi$.
\end{enumerate}

\nextcase $A' \evalsto \forallT A$ and $S' \evalsto \forallT S$ and
$\resurrect\Gamma \der T' = \forallT T$.

\begin{enumerate}

\item % into
We assume $\xi : \Gamma' \leq \Gamma$ and
$\resurrect{\Gamma'} \der a, b : \Size$ and $\alpha,\beta \in \SIZE$ with
$\LRSize {\resurrect{\Gamma'}} b \beta$ and show
$\LR {\Gamma'} {t\xi\ann a} {T(\xi,b)} {(\up {S'} n) \ann \alpha} {A[\beta]}$.
By the evaluation rules for reflection, it is sufficient to show
% It is sufficient to show
$\LR {\Gamma'} {t\xi\ann a} {T(\xi,b)} {\up {S[\alpha]} (n \ann \alpha)} {A[\beta]}$.
This follows by induction hypothesis (\ref{it:into}) if
$\LRTS {\Gamma'} {T(\xi,b)} {A[\beta]} s$ and $A[\beta] \shape S[\alpha]$ and
$\RNE {\Gamma'} {t\xi\ann a} {n \ann \alpha} {T(\xi,b)}$.
The first two of these subgoals are immediate.
The third follows by Lemma~\ref{lem:rclosne} (\ref{it:closneall}) from the
weakened assumption $\RNE {\Gamma'} {t\xi} n {T'\xi}$.
% For the third, assume
% $\xi' : \Gamma'' \leq \Gamma'$.
% We have to show that there exists a neutral normal form $m'$ such that
% $\RNe {\Gamma''} {n \ann \alpha} m'$ and
% $\Gamma'' \der (t\xi \ann a)\xi' = m' : (T(\xi,b))\xi'$.
% Sizes can always be read back, thus, let $\RSize {\Gamma''} \alpha {a_0}$.
% By assmption $\RNE \Gamma t n {T'}$, there is an $m$ with
% $\RNe {\Gamma''} n m$ and
% $\Gamma'' \der t\xi\xi' = m : T'\xi\xi'$.
% The latter equation implies
% $\Gamma'' \der t\xi\xi' \ann {a\xi'} = m \ann {a_0} : T(\xi\xi',b\xi')$
% by irrelevant size application to
% $\resurrect{\Gamma''} \der a\xi', a_0, b \xi' : \Size$,
% thus we are done by choosing $m' : = m \ann{a_0}$.
%

\item % out of
To show $\RD \Gamma t {\down{S'} f} {T'}$ we assume $\xi : \Gamma' \leq \Gamma$ and
produce a normal form $v$ such that $\R{\Gamma'} {\down{S'}f} {\lambda v}$ and
$\Gamma' \der t\xi = \lambda v : T'\xi$.
It is sufficient to show
$\R{\erext{\Gamma'}\Size} {\down{S[\var{\Gamma'}]}(f \ann{\var{\Gamma'}})} v$
and
$\erext{\Gamma'}\Size \der (t\xi\slift)\,\ind 0 = v : T(\xi\slift,\ind 0)$.
These goals, in turn, follow by induction hypothesis (\ref{it:out}) on
$\LR{\erext{\Gamma'}\Size}{(t\xi\slift)\,\ind 0}{T(\xi\slift,\ind 0)}{f \ann{\var{\Gamma'}}}{A[\var{\Gamma'}]}$ which is an instance of our assumption
$\LR \Gamma t {T'} f {A'}$.
\qed
\end{enumerate}
%
\end{caselist}
\end{proof*}
%\begin{corollary}[Fresh variable injection]
\begin{corollary}[Fresh variable]
  \label{cor:fresh}
  If\/ $\der \cext \Gamma T$ and %$A \in \SET[\ell]$
  $\RG \Gamma T A$
  then $\LR {\cext \Gamma T} {\ind 0} {(T \slift)} {(\up A \var\Gamma)} A$.
\end{corollary}
\begin{proof}
  Since $\RNE {\cext \Gamma T} {\ind 0} {\var \Gamma} {T \slift}$
  by Lemma~\ref{lem:freshread},
  the goal follows from Thm.~\ref{thm:into} part (\ref{it:into}).
  % Assume $\xi : \Gamma' \leq \cext \Gamma T$.
  % Note that for the length
  % $i = |\Gamma'| - |\cext \Gamma T|$ of the context extension
  % we have $\ind i = \ind 0 \xi$, thus
  % $\Gamma' \der \ind 0 \xi = \ind i : T \slift \xi$.
  % Since $\RNe{\Gamma'} {\var\Gamma} {\ind i}$,
  % the goal follows now from Thm.~\ref{thm:into} part (\ref{it:into}).
\end{proof}
} % END LONGVERSION


\LONGVERSION{
\begin{corollary}[One-to-one]
\label{cor:oneone}
\bla
\begin{enumerate}
\item
If\/ $\LRSize \Gamma a \alpha$ and $\LRSize \Gamma {a'} \alpha$ then $a = a'$.
\item
If\/ $\LRT \Gamma T A \ell$ and $\LRT \Gamma {T'} A {\ell'}$ then $\Gamma \der T = T'$.
\end{enumerate}
\end{corollary}
} % END LONGVERSION

%\begin{lemma}[Semantic subtyping implies judgmental subtyping \cite{fridlenderPagano:tlca13}]
\begin{lemma}[Semantic implies judgmental subtyping \cite{fridlenderPagano:tlca13}]
\label{lem:lrsub}
\bla
\begin{enumerate}
\item
   If\/ $\LRSize \Gamma a \alpha$ and $\LRSize \Gamma {b} \beta$ and $\alpha \leq \beta$ then $a \leq b$.
\item
   If\/ $\RG \Gamma T A$ and $\RG \Gamma {T'} {A'}$ and $A \leq A' \in \TYPE$ then $\Gamma \der T \leq T'$.
   % If\/ $\LRT \Gamma T A \ell$ and $\LRT \Gamma {T'} {A'} {\ell'}$ and $A \leq A' \in \TYPE$ then $\Gamma \der T \leq T'$.
\end{enumerate}
\end{lemma}
\LONGVERSION{
\begin{proof}
  The proof is analogous to the one  for algorithmic subtyping to come (Lemma~\ref{lem:lrasub}).
\end{proof}
}

\begin{lemma}[Subsumption for the logical relation \cite{fridlenderPagano:tlca13}]
\label{lem:lrsump}
   If\/ $\RG \Gamma T A$ and $\RG \Gamma {T'} {A'}$ and $A \leq A' \in \TYPE$ then
   $\LR \Gamma t T f A$ implies $\LR \Gamma t {T'} f {A'}$.
   % If\/ $\LRT \Gamma T A \ell$ and $\LRT \Gamma {T'} {A'} {\ell'}$ and $A \leq A' \in \TYPE$ then
   % $\LR \Gamma t T f A$ implies $\LR \Gamma t {T'} f {A'}$.
\end{lemma}


\begin{figure}[htbp]
\hrulefill
\begin{gather*}
  \ru{\der \Gamma
    }{\LRSub \Gamma {\sempty} {\sempty} {\cempty} {\sempty} {\sempty}}
\qquad
  \ru{\LRSub \Gamma \sigma \tau \Delta \eta \rho \qquad
      \Gamma \der a : \Size \qquad
      \LRSize \Gamma a \alpha
    }{\LRSub \Gamma {(\sigma,a)} {(\tau,a)} {\cext \Delta \Size} {(\eta,\alpha)} {(\rho,\alpha)}}
\\[2ex]
  \ru{\LRSub \Gamma \sigma \tau \Delta \eta \rho \qquad
      \resurrect \Gamma \der a, b : \Size \qquad
      \alpha,\beta \in \SIZE \qquad
      \LRSize {\resurrect\Gamma} b \beta
    }{\LRSub \Gamma {(\sigma,a)} {(\tau,b)} {\erext \Delta \Size} {(\eta,\alpha)} {(\rho,\beta)}}
\\[2ex]
  \ru{\LRSub \Gamma \sigma \tau \Delta \eta \rho \qquad
      \resurrect \Delta \der T \qquad
      \Gamma \der u = t : T\tau \qquad
      \LR \Gamma t {T \tau} f {T \rho} \qquad
      f = g \in T\rho
    }{\LRSub \Gamma {(\sigma,u)} {(\tau,t)} {\cext \Delta T} {(\eta,f)} {(\rho,q)}}
\end{gather*}
\hrulefill
\caption{Logical relation for substitutions
  \fbox{$\LRSub \Gamma \sigma \tau \Delta \eta \rho$}.}
\label{fig:lrsub}
\end{figure}

Fig.~\ref{fig:lrsub} defines a logical relation for substitutions
\fbox{$\LRSub \Gamma \sigma \tau \Delta \eta \rho$}.
We write \fbox{$\LRS \Gamma \tau \Delta \rho$} for $\LRSub \Gamma \tau \tau \Delta \rho \rho$.

\LONGVERSION{ % BEGIN LONGVERSION
\begin{lemma}[Properties of the logical relation for substitutions]
  \label{lem:wklrsub}
  \bla \\
  Let $\LRSub \Gamma \sigma \tau \Delta \eta \rho$. Then:
  \begin{enumerate}
  \item Well-typedness: $\Gamma \der \sigma : \Delta$
   and $\Gamma \der \sigma = \sigma \eeq \tau : \Delta$
   [which in turn implies $\Gamma \der \tau : \Delta$].
  \item Weakening:
  If\/ $\xi : \Gamma' \leq \Gamma$ then
  $\LRSub{\Gamma'}{\sigma\xi}{\tau\xi}{\Delta}\eta\rho$.
  \item Resurrection:
  $\LRS {\resurrect\Gamma} \tau {\resurrect\Delta} \rho$.
  % $\LRSub {\resurrect\Gamma} \tau \tau {\resurrect\Delta} \rho \rho$.
  \item \label{it:sizesub} Size substitution:
  If\/ $\resurrect\Delta \der a : \Size$ then $a\eta \in \SIZE$.
  \end{enumerate}
\end{lemma}
} % END LONGVERSION
\LONGVERSION{
\begin{proof}
  For part (\ref{it:sizesub}), the only interesting case $a = \ind i + o$ can be proved by observing that $\eta(i) \in \SIZE$.
\end{proof}
} % END LONGVERSION
% \begin{lemma}[Typing of constructed data]
% \label{lem:invdata} \bla
% If\/ $\Gamma \der c : \Nat b$ then $\resurrect\Gamma \der b : \Size$ and $b > 0$.
% \end{lemma}

The following judgements are used to state the fundamental theorem of typing.
\[
\begin{array}{l@{\quad}l@{\quad}l}
  \Gamma \valid t : T & \defas & %\valid \Gamma \mand
    % \resurrect\Gamma \valid T \mand
    % \valid \cext \Gamma T \mand
    \LR {\Gamma'} {t \sigma} {T \tau} {t \eta} {T \rho}
    \mforall \LRSub {\Gamma'} \sigma \tau \Gamma \eta \rho
\\[1ex]
  \Gamma \valid \sigma_0 : \Delta & \defas &
    \LRSub {\Gamma'} {\sigma_0 \sigma} {\sigma_0 \tau} \Delta {\sigma_0 \eta} {\sigma_0 \rho}
    \mforall \LRSub {\Gamma'} {\sigma} {\tau} \Gamma {\eta} {\rho}
\end{array}
\]

\begin{theorem}[Fundamental theorem of typing]
\label{thm:fundty}
\bla
\begin{enumerate}
\item
If\/ $\Gamma \der t : T$ then $\Gamma \valid t : T$.
\item
If\/ $\Gamma \der \sigma : \Delta$ then
$\Gamma \valid \sigma : \Delta$.
\end{enumerate}
\end{theorem}
\begin{proof*}
Each by induction on the derivation.
\SHORTLONG{\qed}{ % LONGVERSION
\begin{caselist}

\nextcase $\forall$-introduction.
\[
  \ru{\erext \Gamma \Size \der t : T
    }{\Gamma \der \lambda t : \forall T}
\]
Assume $\LRSub {\Delta} {\sigma} {\tau} \Gamma {\eta} {\rho}$ and show
$\LR \Delta {(\lambda t)\sigma} {(\forall T)\tau} {(\lambda t)\eta} {(\forall T)\rho}$.
To this end, assume a weakening $\xi : \Delta' \leq \Delta$ and
size expressions % $\Delta' \der a : \Size$ and
$\resurrect{\Delta'} \der a, b : \Size$ and size values $\alpha,\beta$ with
$\LRSize {\resurrect{\Delta'}} b \beta$ and show
$\LR {\Delta'} {(\lambda t)\sigma\xi \ann a} {T(\tau \slift, \ind 0)(\xi,b)} {(\lambda t)\eta \ann \alpha} {T(\rho\slift, \ind 0)[\beta]}$.
It suffices to show (weak head reduction, substitution laws) that
$\LR {\Delta'} {t(\sigma\xi,a)} {T(\tau\xi,b)} {t(\eta,\alpha)} {T(\rho,\beta)}$.
This follows from the induction hypothesis, since
$\LRSub {\Delta'} {(\sigma\xi,a)} {(\tau\xi,b)} {\erext \Gamma \Size} {(\eta,\alpha)} {(\rho,\beta)}$
by Lemma~\ref{lem:wklrsub} and substitution extension.

\nextcase $\forall$-elimination.
\[
  \ru{\Gamma \der t : \forall T \qquad % \Gamma \der a : \Size \qquad
      \resurrect \Gamma \der a,b : \Size
    }{\Gamma \der t \ann a : T[b]}
\]
Assume $\LRSub {\Delta} {\sigma} {\tau} \Gamma {\eta} {\rho}$ and show
$\LR \Delta {t \ann a \sigma} {T[b]\tau} {t \ann a \eta} {T[b]\rho}$.
By induction hypothesis we have $\LR \Delta {t \sigma} {(\forall T)\tau} {t \eta} {(\forall T) \rho}$.
It suffices to show the following:
\begin{enumerate}
\item $\resurrect\Delta \der a\sigma : \Size$: follows from $\resurrect\Gamma \der a : \Size$
  via $\Delta \der \sigma : \Gamma$ and $\resurrect\Delta \der \sigma : \resurrect\Gamma$
  and substitution.
%\item $\resurrect\Delta \der b\tau : \Size$.
\item $a\eta \in \SIZE$: follows from $\resurrect\Gamma \der a : \Size$
  by Lemma~\ref{lem:wklrsub}, part (\ref{it:sizesub}).
%\item $b\rho \in \SIZE$.
\item $\LRSize {\resurrect \Delta} {b\tau} {b\rho}$: follows from induction hypothesis on $\resurrect \Gamma \der b : \Size$ via $\LRSub {\resurrect \Delta} \tau \tau {\resurrect\Gamma} \rho \rho$ (from Lemma~\ref{lem:wklrsub}).
\qed
\end{enumerate}
\end{caselist}
} % END LONGVERSION
\end{proof*}

\begin{lemma}[Identity environment]
  \label{lem:idenv}
  If\/ $\der \Gamma$ then
  $\LRS \Gamma \sid \Gamma \rhog$.
\end{lemma}
\LONGVERSION{ % BEGIN LONGVERSION
\begin{proof*}
  By induction on $\der \Gamma$.
  Consider case:
% \begin{caselist}
% \nextcase
\[
  \ru{\der \Gamma \qquad \resurrect\Gamma \der T
    }{\der \cext \Gamma T}
\]
Let $f = \up{T\rhog} \var\Gamma$.
We have to show $\LRS{\cext \Gamma T} \sid {\cext\Gamma T} {(\rhog, f)}$.
Note that $\sid = (\slift,\ind0)$, thus it remains to show that
$\LRS {\cext \Gamma T} {\slift} \Gamma \rhog$ and
$\LR {\cext \Gamma T} {\ind0} {T\slift} f {T\rhog}$.
The first goal follows by weakening from the induction hypothesis
$\LRS \Gamma \sid \Gamma \rhog$.
%Further, by resurrection we get
%$\LRS {\cext \Gamma T} {\slift} \Gamma \rhog$, and by resurrection
%$\LRS {\cext{\resurrect\Gamma}T}{\slift}{\resurrect\Gamma}\rhog$.
Since $\rhog \in \resurrect\Gamma$, we get $T \rhog \in \SET[\ell]$ for some $\ell$
by the first fundamental theorem (Thm.~\ref{thm:fund}).
Thus, the second goal follows by Cor.~\ref{cor:fresh}.
% Further note that for all $\Gamma' = \cext {\cext \Gamma T} {\Delta}$ and
% $\xi : \Gamma' \leq \cext \Gamma T$ we have that
% $\RNe{\Gamma'} {\var\Gamma} {\ind{|\Gamma'|\monus|\Gamma|}} = {\ind{|\Delta|}}$ and
% $\Gamma' \der \ind 0 \xi = \ind{|\Delta|} : T\xi$.
% This allows us to apply Thm.~\ref{thm:into} to get $\ind0$ into the logical relation as
% $\LR {\cext \Gamma T} {\ind0} T f {T\rhog}$.
\qed
%\end{caselist}
\end{proof*}
} % END LONGVERSION

\begin{corollary}[Soundness of NbE]
  \label{cor:soundnbe} \bla
  \begin{enumerate}
  \item \label{it:sound}
  If\/ $\Gamma \der t : T$ then $\Gamma \der t = \nbe \Gamma T t : T$.
  \item
  If\/ $\Gamma \der t,t' : T$ and $\nbe \Gamma T t \nfeq \nbe \Gamma T {t'}$ then
  $\Gamma \der t = t' : T$.
  \end{enumerate}
\end{corollary}
\begin{proof*}
\bla
\begin{enumerate}

\item For the identity environment $\LRS \Gamma \sid \Gamma \rhog$ (Lemma~\ref{lem:idenv})
the Fundamental Theorem for Typing gives $\LR \Gamma t T {t\rhog} {T\rhog}$.
This implies $\R \Gamma {\down{(T\rhog)} (t\rhog)} v$ for some normal form $v$ and
$\Gamma \der t = v : T$ by Thm.~\ref{thm:into}.

\item %By transitivity of judgmental equality from
  From (\ref{it:sound}), using Lemma~\ref{lem:erase}:
  $\Gamma \der t = \nbe \Gamma T t = \nbe \Gamma T {t'} = t' : T$.
   % Here we use that the computed normal forms are identical because
   % we erase all size annotations $\ann\alpha$ to $\ann\infty$ during read back.
\qed
\end{enumerate}
\end{proof*}

\begin{corollary}[Decidability of judgemental equality]
  If\/ $\Gamma \der t,t' : T$ then the test whether $\nbe\Gamma T t \nfeq \nbe\Gamma T{t'}$
  terminates and
  decides $\Gamma \der t = t' : T$.
\end{corollary}
\LONGVERSION{
\begin{proof}
  Follows directly from soundness (including termination) and completeness of NbE.
\end{proof}
} % END LONGVERSION

\LONGVERSION{
\input{sec-sr}
} % END LONG VERSION
\SHORTVERSION{
From correctness of NbE and the logical relations we can further prove
injectivity of type constructors, inversion of subtyping, and subject reduction.
The proofs follow roughly \citet{fridlenderPagano:tlca13}, for
details, see the long version of this article.
} % END SHORTVERSION

\section{Algorithmic Subtyping}
\label{sec:asub}

\input{sec-asub}
% \LONGVERSION{
% \input{sec-asub}
% } % END LONG VERSION
% \SHORTVERSION{
% Subtyping is decidable, for instance by full normalization
% and comparison of normal forms
% \cite{fridlenderPagano:tlca13}.
% Alternatively, we can define the usual incremental subtyping algorithm
% based on weak head evaluation, which checks equality of neutral types
% by NbE.  For details, see the long version of this article.
% } % END SHORTVERSION


\section{Type Checking}
\label{sec:tycheck}

\input{sec-tycheck}
% \LONGVERSION{
% \input{sec-tycheck}
% } % END LONG VERSION
% \SHORTVERSION{
% It is now straightforward to define a bidirectional type-checking
% algorithm which decides typing for normal forms, and succeeds for
% those that rely only on the following restricted rule for irrelevant
% size application:
% \[
%   \ru{\Gamma \ders t : \forall T \qquad
%       \resurrect\Gamma \der a : \Size
%     }{\Gamma \ders t\, \ann a : T[a]}
% \]
% For lack of space, we delegate definition and soundness proof to the
% long version of this article.
% } % END SHORTVERSION

\section{Discussion and Conclusions}
\label{sec:concl}

In this article, we have described the first successful integration of higher-rank size polymorphism into a core type theory with dependent function types, a sized type of natural numbers, a predicative hierarchy of universes, subtyping, and $\eta$-equality.  This is an important stepping stone for the smooth integration of sized types into dependently-typed proof assistants.
In these final paragraphs, we discuss some questions and insights that follow from our work and go beyond it.

It is now straightforward to add a unit type $\One$ with extensional equality $t = {*} : \One$ for all $t : \One$.  We simply extend reification such that $\down\One a = {*}$.  Further, $\One$ is a new type shape with rule $\One \shape \One$.

% Reification erases all irrelevant size arguments to $\infty$.  We have also considered to keep the sizes there, and define equality $v \approx v'$ of normal forms up to differences in erased arguments.  However, it seems difficult to prove that equal normal forms are judgmentally equal, \ie, that $\Gamma \der v,v' : T$ and $v \approx v'$ imply $\Gamma \der v = v' : T$.  Proving this statement seems to be the key to an incremental equality check; but
% the usual bidirectional argument \cite{abelScherer:types10} does not seem to go through as we lack uniqueness of types.

In the long run, we wish for a type-directed equality check that does
not normalization in one go, but interleaves weak head normalization
with structural comparison.
Such a equality test is at the heart of Agda's type
checker and it generates constraints for meta variables
involved in type reconstruction \cite{norell:PhD}.  However, the usual
bidirectional construction \cite{abelScherer:types10} does not seem to
go through as we lack uniqueness of types (and even principal types).

For now, we have only exploited shape-irrelevance of sized types, but this directly extends to universe levels.  If we consider all universes as a single shape $\Set[\ell_1] \shape \Set[\ell_2]$, we can quantify over levels irrelevantly, as $\Set$ is a shape-irrelevant type constructor.  This is a stepping stone for integrating universe cumulativity with Agda's explicit universe-polymorphism.  If levels are no longer unique (because of subsumption), they will get in the way of proofs, analogously to sizes.  With an irrelevant quantifier we can ignore levels where they do not matter.  We will still respect them where they matter, thus, we keep consistency.

Our reflections on level irrelevance lead us to the question: can a type theory $T$ with a stratified universe hierarchy be understood as a sort of refinement of the inconsistent System~$U$ (Type:Type)?  Intuitively, when checking two terms of $T$ for equality, could we ignore the stratification in the type $A$ which directs the equality check (thus, consider $A$ coming from $U$)?
Such a perspective would put stratification in one pot with size assignment:  Size annotations and levels are both just annotations for the termination checker, but do not bear semantic relevance.  We could switch the universe checker temporarily off as we do with the termination checker---cf.\ the work of \citet{stumpSjobergWeirich:par10} on \emph{termination casts}.

Finally, we would like a general theory of shape-irrelevance that
extends beyond size-indexed types.  For instance, any data type
constructor could be considered shape-irrelevant in all its
indices, with the consequence that index arguments in the data constructors
could be declared irrelevant.
However, our notion of judgmental equality does not support
irrelevant arguments of dependent type.
It works for the non-dependent type $\Size$, but we also
relied on having a closed inhabitant $\infty$ in $\Size$.
More research is needed to tell a more general story of shape-irrelevance.

% Finally, we would like a general theory of shape-irrelevance that
% extends beyond size-indexed types.  For instance, any data type
% constructor could be considered shape-irrelevant in all its
% parameters.
% However, the current reification algorithm which erases
% irrelevant size arguments to $\infty$ would need some patching.
% \citet{abelCoquandPagano:lmcs11} erase all proofs of a proposition $P$
% to a canonical element $\star$ which inhabits any proposition $P$ that
% is already inhabited.  A similar technique could work in our setting
% and would be necessary unless we can justify the incremental equality
% check (see above).






%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  Swedish Research Council (Vetenskapsr\aa{}det)
  under Grant
  No.~621-2014-4864 \emph{Termination Certificates for Dependently-Typed Programs and Proofs via Refinement Types}.
  The first author is grateful for recent discussions with Thierry Coquand, Nils Anders Danielsson, and Sandro Stucki
  which helped clarifying the thoughts leading to this work.
  He also acknowledges past discussions with Christoph-Simon Senjak.
  The incentive to write this article came during the EU Cost Action CA15123 EUTYPES meeting in Ljubljana in January 2017; thanks to Andrej Bauer for organizing it.
\end{acks}

% \clearpage

%% Bibliography
\bibliography{auto-icfp17-long}


% %% Appendix
% \appendix
% \section{Appendix}

% Text of appendix \ldots

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "icfp17"
%%% End:
