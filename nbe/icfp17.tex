%% For double-blind review submission
\documentclass[acmlarge,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission
%\documentclass[acmlarge,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission
%\documentclass[acmlarge]{acmart}\settopmatter{}

% For having two versions of a paper in one file.
% Stuff that does not fit into the short version can be encosed in \LONGVERSION{...}
\ifdefined\LONGVERSION
  \relax
\else
% short version:
\newcommand{\LONGVERSION}[1]{}
\newcommand{\SHORTVERSION}[1]{#1}
% % long version:
% \newcommand{\LONGVERSION}[1]{#1}
% \newcommand{\SHORTVERSION}[1]{}
% \newcommand{\SHORTVERSION}[1]{BEGIN~SHORT\ #1 \ END~SHORT}
\fi
\newcommand{\LONGSHORT}[2]{\LONGVERSION{#1}\SHORTVERSION{#2}}
\newcommand{\SHORTLONG}[2]{\SHORTVERSION{#1}\LONGVERSION{#2}}
\newcommand{\EXTENDED}[1]{}

\usepackage[right]{showlabels}\renewcommand{\showlabelfont}{\small\ttfamily\color{gray}}

\usepackage{mathtools} %mathrlap
\usepackage[all]{xy}

\usepackage[cal=boondoxo]{mathalfa}

\usepackage{latex/agda}

% NO EFFECT:
% \renewcommand{\AgdaOperator}    [1]
%     {\AgdaNoSpaceMath{\AgdaFontStyle{\textcolor{AgdaOperator}{\mathbf{#1}}}}}

%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format should change 'acmlarge' to
%% 'sigplan,10pt'.


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption


\makeatletter\if@ACM@journal\makeatother
%% Journal information (used by PACMPL format)
%% Supplied to authors by publisher for camera-ready submission
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2017}
\acmMonth{1}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\else\makeatother
%% Conference information (used by SIGPLAN proceedings format)
%% Supplied to authors by publisher for camera-ready submission
\acmConference[PL'17]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2017}{New York, NY, USA}
\acmYear{2017}
\acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\fi

\makeatletter
\newenvironment{proof*}[1][\proofname]{\par
  \normalfont \topsep6\p@\@plus6\p@\relax
  \trivlist
  \item[\@proofindent\hskip\labelsep
        {\@proofnamefont #1\@addpunct{.}}]\ignorespaces
}{%
  \endtrivlist\@endpefalse
}
\makeatother

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission
\setcopyright{none}             %% For review submission
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear


%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations

\input{macros}


\begin{document}

%% Title information
\title[NbE for Sized Types]{Normalization by Evaluation for Sized Dependent Types}
%\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Andreas Abel}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{0000-0003-0420-4492}             %% \orcid is optional
\affiliation{
  \department{Department of Computer Science and Engineering}
  \institution{Gothenburg University}
  \streetaddress{Rännvägen 6b}
  \city{Göteborg}
%  \state{State1}
  \postcode{41296}
  \country{Sweden}
}
\email{andreas.abel@gu.se}          %% \email is recommended

%% Author with two affiliations and emails.
\author{Andreas Vezzosi}
\affiliation{
  \department{Department of Computer Science and Engineering}
  \institution{Chalmers}
  \streetaddress{Rännvägen 6b}
  \city{Göteborg}
%  \state{State1}
  \postcode{41296}
  \country{Sweden}
}
\email{vezzosi@chalmers.se}          %% \email is recommended

\author{Theo Winterhalter}
\affiliation{
  \institution{École Normale Supérieure de Cachan}
}
\email{theo.winterhalter@gmail.com}

%% Paper note
%% The \thanks command may be used to create a "paper note" ---
%% similar to a title note or an author note, but not explicitly
%% associated with a particular element.  It will appear immediately
%% above the permission/copyright statement.
%\thanks{with paper note}                %% \thanks is optional
                                        %% can be repeated if necesary
                                        %% contents suppressed with 'anonymous'


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Sized types have been developed to make termination checking more perspicuous, more powerful, and more modular by integrating termination into type checking.  In dependently-typed proof assistants where proofs by induction are just recursive functional programs, the termination checker is an integral component of the trusted core, as validity of proofs depend on termination.  However, a rigorous integration of full-fledged sized types into dependent type theory is lacking so far.  Such an integration is non-trivial, as explicit sizes in proof terms might get in the way of equality checking, making terms appear distinct that should have the same semantics.

In this article, we integrate dependent types and sized types with higher-rank size polymorphism, which is essential for generic programming and abstraction.  We introduce a size quantifier $\forall$ which lets us ignore sizes in terms for equality checking, alongside with a second quantifier $\Pi$ for abstracting over sizes that do affect the semantics of types and terms.  Judgmental equality is decided by an adaptation of normalization-by-evaluation for our new type theory, which features \emph{type shape}-directed reflection and reification.  It follows that subtyping and type checking of normal forms are decidable as well, the latter by a bidirectional algorithm.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
 \begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003752.10003790.10011740</concept_id>
<concept_desc>Theory of computation~Type theory</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003752.10010124.10010125.10010130</concept_id>
<concept_desc>Theory of computation~Type structures</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003752.10010124.10010138.10010142</concept_id>
<concept_desc>Theory of computation~Program verification</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10003752.10010124.10010131.10010134</concept_id>
<concept_desc>Theory of computation~Operational semantics</concept_desc>
<concept_significance>100</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Type theory}
\ccsdesc[500]{Theory of computation~Type structures}
\ccsdesc[300]{Theory of computation~Program verification}
\ccsdesc[100]{Theory of computation~Operational semantics}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{dependent types, eta-equality, normalization-by-evaluation, proof irrelevance, sized types, subtyping, universes.}  %% \keywords is optional
%\keywords{Dependent Types, Normalization-by-Evaluation, Proof Irrelevance, Sized Types, Subtyping, Universes}  %% \keywords is optional


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}
\label{sec:intro}

% higher rank sized types
% Church-style and curry style
% The problem of size irrelevance
% Our solution (application rule)
% Shape-irrelevance middle ground between Pfenning, ICC,
% Agda's function types


Dependently-typed programming languages and proof assistants, such as Agda~\citeyearpar{agdawiki}, Coq~\cite{inria:coq86}, and Idris~\cite{brady:jfp13} require programs to be total, for two reasons.  First, for consistency:  since propositions are just types and proofs of a proposition just programs which inhabit the corresponding type, some types need to be empty; otherwise, each proposition would be true.  However, in a partial language with general recursion, each type is inhabited by the looping program $f = f$.  Secondly, totality is needed for decidability of type checking.  Since types can be the result of a computation, we need computation to terminate during type checking, even for \emph{open terms}, \ie, terms with free variables.

% \cite{boveKraussSozeau:mscs16}
Consequently, each of the aforementioned languages based on Type Theory comes with a termination checker, which needs to reject all non-terminating programs, and should accept sufficiently many terminating programs to allow the user to express her algorithms.  In current termination checkers, programs are required to terminate by structural descent \cite{gimenez:guardeddefinitions}; the structural order may be extended to a lexicographic \cite{abelAltenkirch:jfp02} or size-change termination criterion \cite{jones:sizeChange,wahlstedt:PhD}.  This is not a fundamental limitation, since Type Theory allows many functions to be expressed in a structurally recursive manner, if needed by the help of a well-founded relation \cite{nordstrom:genrec}, inductive domain predicates \cite{boveCapretta:mscs05}, or inductive descriptions of the function graph \cite{bove:entcs09}.  However, the syntactic termination check is very sensitive to reformulations of the program and hostile to abstraction \cite{abel:fics12}.

Sized types \cite{hughesParetoSabry:popl96} delegate the checking for structural descent to the type system by annotating data types with a size parameter.  The type checker can then ensure that in recursive calls, the size goes down, certifying termination.  In the simplest setting \cite{gimenez:typeBased,abel:lmcs07}, the size is just an upper bound on the tree height of the data structure; however, more sophisticated size annotations have also been considered \cite{xi:terminationHOSC,blanqui:rta04}.  Most sized type systems are non-dependent \cite{amadio:guardcondition,abelPientka:jfp16,bartheGregoireRiba:lernet08,bartheGregoireRiba:csl08,blanquiRiba:lpar06,dalLagoGrellois:probabilisticSizedTypes2017}, yet the combination of sized and dependent types has been studied as well \cite{blanqui:csl05,bartheGregoirePastawski:lpar06,gregoireSacchini:lpar10,sacchini:lics13,sacchini:flops14}.  However, to the best of our knowledge, no study combines \emph{higher-rank size polymorphism} with full-fledged dependent types.\footnote{\citet{xi:terminationHOSC} has first-class size polymorphism, but only indexed types, no universes or large eliminations.}

Higher-rank size quantification takes termination checking to the next level; it is necessary for abstraction and generic programming.  For instance, it allows us to write a generic tree traversal which applies a user-given preprocessor on subtrees before recursively descending into these trees.  The condition is that preprocessing does not increase the size of the subtree; otherwise, termination could not be guaranteed.  Concretely, assume a type $\tT\,i$ of trees of size $< i$ with a constructor $\tnode : \forall i.\, \List\,(\tT\,i) \to \tT\,(i+1)$ which takes a finite list of subtrees to form a new tree.
In the following definition of $\ttrav$, the preprocessing $\vpre : \forall i.\, \tT\,i \to \tT\,i$ can be safely applied to input tree $t$ because the type of $\vpre$ bounds the size of $\vpre\,t$ by the size of $t$.
In case $\vpre\,t = \tnode\,\vts$, the trees in the list $\vts$ are still guaranteed to be of strictly smaller size than $t$, thus, the recursive call to $\ttrav$, communicated via the $\tmap$ function for lists, is safe.
\[
\begin{array}{l}
  \ttrav : (\vpre : \forall i.\, \tT i \to \tT i) (\vpost : \tT \infty \to \tT \infty) \to \forall i.\, \tT\,i \to \tT\,\infty
  \\
  \ttrav \; \vpre \; \vpost \; t = \vpost\;(\tcase\;\vpre\,t\;\tof \, \{ \, \tnode\,\vts \to \tnode\,(\tmap \; (\ttrav \, \vpre \, \vpost) \; \vts)\, \})
\end{array}
\]
The display shows the \emph{Curry}-style program as provided by the user, but state-of-the-art type checkers elaborate the program from surface syntax into an internal \emph{Church}-style syntax with explicit type abstractions and type applications.\footnote{Agda, Coq, Idris, and Haskell \cite{sulzmannChakravartyPeythonJonesDonnelly:tldi07} all have Church-style internal languages.}  With implicit type and size applications elaborated, $\ttrav$ would look as follows:
\[
\begin{array}{l}
  \ttrav \; \vpre \; \vpost \; i\; t = \vpost\;(\tcase\;\vpre\,i\,t\;\tof \, \{ \, \tnode\,j\,\vts \to \tnode\,\infty\,(\tmap \; (\tT\,j) \; (\tT\,\infty) \; (\ttrav \, \vpre \, \vpost \, j) \; \vts) \})
\end{array}
\]
Church-style syntax is the basis for all program analyses and transformations to follow and should be considered as the \emph{true} syntax.
However, from a dependent-type perspective, explicit size applications
in terms can be problematic when the type checker compares terms for
equality---which is necessary as types can depend on values.  Inferred
sizes may not be unique, as we have subtyping $\tT\,i \leq \tT\,j$ for
$i \leq j$: we can always weaken an upper bound.  For instance, given
$\vts : \List\,(\tT\,i)$, any of the terms
$\tnode\,i\,\vts$, $\tnode\,(i+1)\,\vts$, $\dots$, $\tnode\,\infty\,\vts$
%$\tnode\,i\,\vts$ or $\tnode\,(i+1)\,\vts$ or $\dots$ or $\tnode\,\infty\,\vts$
has type
$\tT\,\infty$.  Yet semantically, all these trees are equal,
thus, the syntactic equality check should ignore the size argument to
$\tnode$.  Similarly, in the application $\vpre\,i\,t$ the size
argument $i$ should be ignored by the equality check.  Yet
$\vpre\,i : \tT\,i \to \tT\,i$ and $\vpre\,j : \tT\,j \to \tT\,j$ have
different types for $i \not= j$, and moreover these function types are
not in the subtyping relation due to the mixed-variant occurrence of the
size parameter.  It seems that during equality checking we have to
consider terms of different types, at least for a while.  Once we apply
$\vpre\,i$ and $\vpre\,j$ to the same tree $t : \tT\,k$, which
determines $i = j = k$, we are back to safety.  However, allowing
types to differ during an equality check can be hazardous, especially
when the equality-check is type directed.

Consider the analogous situation for the polymorphic lambda calculus System~F, be it the predicative variant or not, extended by a unit type $\One$.
For Church-style, we can give a type-directed $\beta\eta$-equality test which equates all terms at the unit type.  The most interesting rules are the $\eta$-rules for unit and function type and the congruence rule for type application:
\begin{gather*}
\renewcommand{\jchk}{:}
\renewcommand{\jinf}{:}
  \ru{}{\Gamma \der t = t' \jchk \One}
\qquad
  \ru{\Gamma, x \of A \der t\,x = t'\,x \jchk B
    }{\Gamma \der t = t' \jchk A \to B}
\qquad
  \ru{\Gamma \der t = t' \jinf \forall X. B
    }{\Gamma \der t\,A = t'\,A \jinf B[A/X]}
\end{gather*}
The Curry-style version replaces the last conclusion by $\Gamma \der t = t' : B[A/X]$ where the type $A$ to instantiate $X$ has to be guessed.  However, in Curry-style more terms are equated than in Church-style, as for instance the Church-style terms $t\,A\,(\lambda x \of A.\, x)$ and $t\,B\,(\lambda x \of B.\, x)$ map to the same Curry-style term $t\,(\lambda x.\,x)$.  How would we adapt the algorithm for Church-style such that it equates all terms that are equal in Curry-style?  The conclusion of the last rule could be changed to $\Gamma \der t\,A = t'\,A' : B[A/X]$, but then the second term $t'\,A'$ does not have the ascribed type $B[A/X]$, and $\eta$-laws applied to this term would be unsound.  For instance, the algorithm would yield $t\,\One\,x = t\,(A \to A)\,y$ even for $x \not= y$.
We could also consider a heterogeneous check $(\Gamma \der t : A) = (\Gamma' \der t' : A')$ where each term is paired with its own type and context, but this leaves us with the dilemma of explaining the meaning of this judgement when $A$ and $A'$ are incompatible.

Does the literature offer a solution to this problem?
In fact, a Church-style calculus with Curry-style equality has been studied before, it is ICC$^*$ \cite{barrasBernardo:fossacs08,mishraLingerSheard:fossacs08} based on Miquel's Implicit Calculus of Constructions \citeyearpar{miquel:tlca01}.
In ICC$^*$, equality is checked by erasing all type abstractions and applications, and comparing the remaining untyped terms for $\beta\eta$-equality.  While this works for $\eta$-laws that can be formulated on untyped terms, such as $\eta$-contraction of functions $\lambda x.\,t\,x \redeta t$ (when $x$ not free in $t$), it does not extend to type-directed $\eta$-laws such as extensionality for the unit type.  Further, ICC$^*$ is not a type theory formulated with a typed equality judgement, which makes it hard to define its models \cite{miquel:lics00}---we wish not to go there, but stay within the framework of Martin-L\"of Type Theory \citeyearpar{martinlof:predicative75}.

%How can we have our cake and eat it, too?
Now, if the types of compared Curry-style terms are not equal, can they be sufficiently related to give a proper meaning to the algorithmic equality judgement?
It has already been observed that for a type-directed equality check the precise type is not necessary, a \emph{shape} or \emph{skeleton} is sufficient.  The skeleton informs the algorithm whether the terms under comparison are functions, inhabitants of the unit type, or something else, to possibly apply the appropriate $\eta$-law.  For the Logical Framework (LF), the simplest dependent lambda-calculus, the skeletons are simple types that can be obtained from the original dependent types by erasing the dependencies:  dependent function types map to non-dependent ones and indexed data types to simple data types. \citet{harperpfenning:equivalenceLF} present such an equality check for LF which is directed by simple types, and their technique should scale to other type theories that admit dependency erasure.\footnote{For instance, the types of the Calculus of Constructions erase to F$^\omega$-types \cite{geuvers:shortFlexibleSNCC}, and the latter could be used to direct the equality check. \citet{lovasPfenning:lmcs10} consider also \emph{refinement types for logical frameworks} which can be erased to simple types.}

By \emph{large eliminations} \cite{werner:types92} we refer to types computed by case distinction over values; they occur
in type theories that feature both universes and data types.
In the presence of large eliminations, dependency erasure fails, and it is not clear what the skeleton of a dependent type should be.  For instance consider the type $\funT n \NN \underbrace{A \to \dots \to A}_n \to A$ of $n$-ary functions; its shape is dependent on the value of $n$, thus cannot be determined statically.  Thus, the ``skeleton'' idea is also not directly applicable.

Going beyond the classical incremental equality check, there is a technique that can deal with dynamic $\eta$-expansion.  It is a type-directed normalization function inspired by normalization-by-evaluation (NbE) that computes $\eta$-long normal forms \cite{bergerSchwichtenberg:lics91,danvy:tdpe}.  We can check the computed normal forms for identity and, thus, decide definitional equality.
NbE has proven to be a robust method to decide equality in powerful type theories with non-trivial $\eta$-laws.  It scales to universes and large eliminations \cite{abelCoquandDybjer:lics07}, topped with singleton types or proof irrelevance \cite{abelCoquandPagano:lmcs11}, and even impredicativity \cite{abel:flops10}.  At its heart there are reflection $\up T$ and reification $\down T$ functions directed by type $T$ and orchestrating just-in-time $\eta$-expansion.  Reflection $\up T x$ maps variables $x$ into the realm of values of type $T$ and let's us compute with open terms.  Reification $\down T a$ takes a value $a$ of type $T$ and computes its long normal form.  For instance, the normal form of a closed function $f : U \to T$ would be $\lambda x.\,\down{T} (f\,(\up U x))$, and for its dependently-typed variant $f : \funT x U T[x]$ it would be $\lambda x.\,\down{T[\up U x]} (f\,(\up U x))$.

% In the solution we present in this article, we do not introduce a new syntax for shapes, just a relation $T \shape S$ stating that type $S$ qualifies as shape for type $T$.  We use a normalization function inspired by normalization-by-evaluation (NbE) that computes the $\eta$-long normal form of the terms under comparison, which we then check for identity.

The central technical observation is that reflection and reification do not need the precise type $T$, they work the same for any \emph{shape} $S$ of $T$.
We managed, while not introducing a new syntax for shapes, to define a relation $T \shape S$ on type values stating that type $S$ qualifies as shape for type $T$.
Shapes unfold dynamically during reflection and reification.
For example, when reflecting a variable $x$ into the polymorphic function type $\forall i.\, F\,i$ where $F\,i = \Nat\,i \to \Nat\,i$, we obtain
$(\up{\forall i.\/ F\,i}x)\,i = \up{F\,i} (x\,i)$ for size $i$ and
$(\up{\forall i.\/ F\,i}x)\,j = \up{F\,j} (x\,j)$ for size $j$.  The new types $F\,i$ and $F\,j$ we reflect at are no longer equal (and they are not subtypes of each other), but they still have the same shape, $\Nat\_ \to \Nat\_$.  This means they will still move in lock-step in respect to $\eta$-expansion, which is sufficient to prove NbE correct for judgmental equality.
We call the enabling property of $F$ \emph{shape irrelevance}, meaning that for any pair $i$, $j$ of legal arguments, $F\,i$ and $F\,j$ have the same shape.  Whenever we form a irrelevant function type $\forall x \of U.\, T[x]$, we require $T[x]$ to be shape-irrelevant in $x$.  This is the middle ground between ICC$^*$, where no restriction is placed on $T$ but $\eta$ for unit types is out of reach (at least for the moment), and Pfenning's \citeyearpar{pfenning:intextirr} irrelevance modality, adapted to full dependent types by \citet{abelScherer:types10}, which requires $T$ to be irrelevant in $x$ and, thus, has type equality $T[i] = T[j]$.

For the time being, we do not (and cannot) develop a general theory of shape irrelevance.  We confine ourselves to size-irrelevant function types $\forall i.\, T[i]$.  This relieves us from defining a special shape-irrelevance modality, since all size-indexed types $T[i]$ \emph{are} shape irrelevant in $i$, simply because there is no case distinction on size, and sizes appear relevantly only under a sized type constructor such as $\tNat$.  Our technique would not extend to the polymorphic types $\forall X.\,B[X]$ of System~F.  Even though there is no case distinction on types, shape irrelevance of $B[X]$ fails in general, as $X$ could appear as a type on the top-level, e.g. in %$B[X] = X$ or
$B[X] = X \to X$, and then $B[\One]$ and $B[A \to A]$ would have distinct shapes.

To summarize, this article makes the following novel contributions:
\begin{enumerate}

\item We present the first integration of a dependent type theory with higher-rank size polymorphism.
Concretely, we consider a type theory \`a la Martin-L\"of with dependent function types, cumulative universes, subtyping, a judgmental equality with $\eta$-laws, a sized type of natural numbers and two size quantifiers: an irrelevant one $(\forall)$ for binding of sizes in irrelevant positions, and a relevant one $(\Pi)$ for binding of sizes in shape-irrelevant positions (Section~\ref{sec:syntax}).  Judgmental equality features a ``Curry-style'' rule for irrelevant size application which ignores the size arguments, and consequently, the corresponding typing rule will also ignore the size argument.
\[
\ru{\Gamma \der t = t' : \forall i.\, T
  }{\Gamma \der t\,a = t\,a' : T[b/i]}
\qquad
\ru{\Gamma \der t : \forall i.\, T
  }{\Gamma \der t\,a : T[b/i]}
\qquad
\qquad
\ru{\Gamma \der t = t' : \Pi i.\, T
  }{\Gamma \der t\,a = t\,a : T[a/i]}
\qquad
\ru{\Gamma \der t : \Pi i.\, T
  }{\Gamma \der t\,a : T[a/i]}
\]

\item We adapt normalization-by-evaluation (NbE) to sized types and size quantification and show that it decides judgmental equality (sections~\ref{sec:sem} and \ref{sec:soundnbe}).  The novel technical tool is a relation $T \shape S$ which relates a type $T$ to its possible shapes $S$.  This approximation relation allows reflection and reification at size-polymorphic types $\forall i.\, T$.
As usual for the meta-theory of Type Theory with large eliminations, the machinery is involved, but we just require the usual two logical relations:  First, a PER model to define the semantics of types and prove the completeness of NbE (Section~\ref{sec:sem}).  Secondly, a relation between syntax and semantics to prove soundness of NbE (Section~\ref{sec:soundnbe}).

\item We present an bidirectional type checking algorithm \cite{coquand:type} which takes the irrelevant size argument as reliable hint for the type checker (sections~\ref{sec:asub} and \ref{sec:tycheck}).  It is complete for normal forms which can be typed with the restricted rule for $\forall$-elimination:
\[
\ru{\Gamma \der t : \forall i.\, T
  }{\Gamma \der t\,a : T[a/i]}
\]
The algorithm employs the usual lazy reduction for types, \ie, just-in-time weak-head evaluation, in type and sub-type checker
\cite{huet:wsscs89}.  In this, it improves on \citet{fridlenderPagano:tlca13} which instruments full normalization (NbE) at every step.
\end{enumerate}
This article is accompanied by a prototypical type checker \textsf{Sit} which implements the type system and type checking algorithm as described in the remainder of the paper.
But before going into the technical details, we will motivate our type system from a practical perspective: reasoning about programs involving sized types in Agda.


\section{Size Irrelevance in Practice}
\label{sec:informal}

In this section, we show how the lack of size irrelevance prevents us from reasoning naturally about programs involving sized types in Type Theory.  We focus on Agda, at the time of writing the only mature implementation of Type Theory with an experimental integration of sized types.

\input{latex/SubDiagError}

\input{latex/SubDiag}

\section{A Type System With Irrelevant Size Application}
\label{sec:syntax}

In this section, we give syntax and \emph{declarative} typing, equality, and subtyping judgements.  The typing relation $\Gamma \der t : T$ will \emph{not} be decidable; instead, we present algorithmic typing $\Gamma \der t \jchk T$ in Section~\ref{sec:tycheck}.  However, equality and subtyping will be decidable for well-formed input, see sections~\ref{sec:sem}--\ref{sec:asub}.

We present our type theory as \emph{pure type system} \cite{barendregt:lambdacube} with extra structure.
\emph{Sorts} $s$ are drawn from an infinite predicative hierarchy of universes $\Set[\ell]$ for $\ell \in \NN$.  Universes provide us with polymorphism and the capability to define types by recursion on values.  Whether we have just two universes $\Set[0]$ and $\Set[1]$ or infinitely many, does not matter for the technical difficulty of the meta theory.  The present setup have the advantage that every sort has again a sort since $\Set[\ell] : \Set[\ell+1]$, thus, we do not have to introduce a separate judgement $\Gamma \der T$ for well-formedness of types, we can define it as $\exists s.\ \Gamma \der T : s$.

\begin{figure}[htbp]
  \centering
\[
\begin{array}{lllrl@{\qquad}l}
\Sort & \ni & s
    & ::= & \Set[\ell] ~(\ell \in \NN)& \mbox{sort (universe)} \\
% \Ann & \ni & \star & ::= & \erased \mid \nonstrict \mid \noterased & \mbox{annotation (irrelevant, shape-irrelevant, relevant)}\\
\Ann & \ni & \star & ::= & \erased \mid \noterased & \mbox{annotation (irrelevant, relevant)}\\
\Exp & \ni & t,u,T,U
    & ::= & w \mid t\,e & \mbox{expressions} \\
\Whnf & \ni & w, W
    & ::= & n \mid s \mid \Size \mid \epiT U T % \mid \piSizeT T
    % \mid \forallT T
    \mid \lambda t% & \mbox{functions} \\ &&
    \mid \Nat a \mid c & \mbox{weak head normal forms} \\ % \mbox{natural numbers} \\
\Data & \ni & c
   & ::= & \zero a \mid \suc a t & \mbox{constructed data} \\
\Ne & \ni & n
    & ::= & \ind i \mid n \, e & \mbox{neutral expressions} \\
\Elim & \ni & e
    & ::= & t \mid a \mid \ann a \mid \case[\ell] T {t_z} {t_s} \mid \fix[\ell] T t & \mbox{eliminations} \\
\SizeExp & \ni & a,b & ::= & \infty \mid o \mid \ind i + o ~(o \in \NN) & \mbox{size expressions} \\
\Cxt & \ni & \Gamma, \Delta & ::= & \cempty \mid \erext[\noterased] \Gamma T \mid \erext \Gamma \Size
   & \mbox{contexts} \\
\Subst & \ni & \eta,\rho,\sigma,\tau,\xi & ::= & \sempty \mid (\sigma,t)
  & \mbox{substitutions} \\
\end{array}
\]
  \caption{Syntax.}
  \label{fig:syntax}
\end{figure}

For the expression syntax (see Fig.~\ref{fig:syntax}), we use de~Bruijn \citeyearpar{deBruijn:nameless} indices $\ind i$ to represent variables.  Binders are lambda abstraction $\lambda t$ and dependent function types $\epiT U T$, which bind the $0$th index in $t$ and $T$, resp.  The notation $\epiT U T$ is an umbrella for three kinds of function types, where $\evar \in \{ \erased, \noterased \}$ is a relevance annotation borrowed from \citet{pfenning:intextirr}: $\erpiT[\noterased] U T$, the ordinary dependent function type, $\erpiT[\noterased] \Size T$ for relevant size quantification, and $\erpiT \Size T$ for irrelevant size quantification.
We omit the ``$\noterased$''-markers from $\Gamma$ and $\Pi$ by default and write $\forallT T$ for $\erpiT \Size T$.
%
Examples for relevant size quantification $\piT \Size T$, in syntax with named variables, are $\Size \to \Set[0]$ or $\funT i \Size \Nat i \to \Set[0]$.  An instance of irrelevant quantification $\forall T$ would be $\forall i.\, \Nat i \to \Nat i$.  Herein, $\Nat i$ denotes the type of natural numbers below $i$. The expression $\Size$ is a possible instance of $U$ in $\epiT U T$, or a possible type of a variable in a typing context $\Gamma$, but not a first-class type, \ie, we cannot construct our own function on sizes.

Canonical natural numbers $c$ are constructed by $\zero a$ and $\suc a t$.
Size expression $a$ is either a constant $o \in \NN$, a variable
$\ind i + o$ possibly with increment $o$, or the limit ordinal
$\infty$ which stands for $\omega$.  The size argument $a$ in the
constructors is a suggestion for the type checker but bears no
semantic significance.  For example, in the declarative typing
presented here, we can have $\der \zero 5 : \Nat 1$.
In the algorithmic typing however, $\der \zero 5 \jchk \Nat 1$ will be an error.

Besides with regular application $t\,u$, relevant size application $t\,a$, and irrelevant size application $t \, \ann a$,
we can eliminate a term $t$ by a case distinction $e = \case[\ell] T {t_z}{t_s}$ or a recursive function application $e' = \fix[\ell'] {T'} {t'}$.  In both cases, the term should denote a natural number.  Application of case distinction $\zero a \, e$ will reduce to the zero-branch $t_z$, and $\suc a t \,e$ to the instantiation of the successor branch $t_s\,t$.  The type annotation $T$ in $\tcase$ allows us to infer the type of the whole case statement $t\,e$ as $T\,t$.  The function call $c\,e'$ for a canonical number reduces to $f'\,(\lambda x.\,x\,e')\,c$ where we allowed ourself the use of a named abstraction in the presentation to the reader.  The unfolding of fixed-points is thus restricted to application to canonical numbers; this is the usual reduction strategy which converges for terminating functions \cite{gimenez:typeBased}.

%We write $\sigma$ and $\tau$ for substitutions, which are lists of terms, and
For ordinary $\beta$-reduction we employ
\emph{substitutions} $\sigma$.  These are simply lists of terms that provide one term as replacement for each free de Bruijn index in a term $t$. We write \fbox{$t \sigma$} for the application of substitution $\sigma$ to term $t$ which is defined as usual.  Let \emph{lifting} \fbox{$\slift^k_m$} be the substitution $(\ind{k+m-1},\dots,\ind{k+1},\ind k)$ which accepts a term with $m$ free indices and increases each of them by $k$.  We write $\slift_m$ for the lifting $\slift^1_m$ and \fbox{$\sid_m$} for the identity substitution $ \slift^0_m$. In general, we refer to liftings by letter $\xi$.
The substitution \fbox{$[u]_m$}${} = (\sid_m, u)$ replaces free index $\ind 0$ by term $u$ and decrements the other $m$ free indices by $1$. We drop subscript $m$ from liftings when clear from the context.
Substitution composition \fbox{$\sigma\tau$} is the pointwise application of substitution $\tau$ to the list of terms $\sigma$.  In the proofs to follow, we freely use the following identities:
\begin{gather*}
  t\sid \equiv t
\quad
  (t\sigma)\tau \equiv t(\sigma\tau)
\qquad
  \sigma \sid \equiv \sigma
\quad
  \sid \tau \equiv \tau
\quad
  (\rho\sigma)\tau \equiv \rho(\sigma\tau)
\\
  \ind 0 (\sigma,t) \equiv t
\quad
  \slift(\sigma,t) \equiv \sigma
\qquad
  [t]\sigma \equiv (\sigma, t\sigma)
\quad
  \slift[t] \equiv \sid
%  (\sigma\slift)[t] \equiv \sigma
\end{gather*}

For concrete function types and terms, we may use a named dependent function type notation as syntactic sugar for the corresponding de Bruijn representation.  For instance, $\funT i \Size \Nat i \to \Set[\ell]$ is sugar for $\piT \Size \piT {(\Nat\,\ind 0)} \Set[\ell]$.  We abbreviate this type by \fbox{$\FixK\,\ell$}, and let \fbox{$\FixT\,T$} stand for
$\forall i.\ (\funT x {\Nat i} T\, i\, x) \to \funT x {\Nat (i + 1)} T \,(i+1)\, x$.
% $\allT i \Size (\funT x {\Nat i} T\, i\, x) \to \funT x {\Nat (i + 1)} T \,(i+1)\, x$.
Similar as for $\Pi$, we use named lambda abstraction as sugar for de Bruijn abstraction.  Named abstraction takes care of proper lifting of de Bruijn indices, for instance, $\lambda x.\, t x = \lambda. (t \slift)\,\ind 0$ if $t$ is outside the scope of $x$.
We may also use names when we construct concrete contexts, for instance, if\/ $T$ is well-formed in context $\Gamma$, we may write $T\,i\,x$ in context $\Gamma.i\of\Size.x\of\Nat i$ to mean $T\slift^2\,\ind 1\,\ind 0$ in context
$\Gamma.\Size.\Nat \ind 0$.

\input{figjudge}

In typing contexts $\Gamma$, we distinguish relevant $(\noterased)$ and irrelevant $(\erased)$ bindings.
When type checking a variable, it needs to be bound in the context relevantly.  However, when entering a irrelevant position, for instance when checking size $a$ in term $\suc a t$ we declare previously irrelevant variables as relevant.
This operation on the context has been coined
\emph{resurrection} by \citet{pfenning:lics01}; formally \fbox{$\resurrect\Gamma$} removes
the ``$\erased$''-markers from all bindings in $\Gamma$, \ie, replaces
them by ``$\noterased$''-markers.  Note that, trivially, resurrection is idempotent: $\resurrecttwice\Gamma = \resurrect{\Gamma}$.

Size increment \fbox{$a + o'$} for $o' \in \NN$ extends addition by $\infty + o' = \infty$ and $(\ind i + o) + o' = \ind i + (o + o')$.  Sizes are partially ordered; size comparison \fbox{$a \leq b$} holds as expected if either $b = \infty$ or  $o \leq o'$ where either $a = o$ and $b = o'$ or $a \in \{ o, \ind i + o \}$ and $b = \ind i + o'$.
Different size variables are incomparable.

\input{figty}
\input{figeq}

Fig.~\ref{fig:judge} lists the inductive and derived judgements of our type theory and
figures~\ref{fig:ty} and \ref{fig:eq} the inference rules.
In the typing judgement $\Gamma \der t : T$, the term $t$ is in scope of
$\Gamma$, \ie, may not mention irrelevant variables in relevant
positions.  However, the type $T$ is in scope of the resurrected
context $\resurrect\Gamma$, hence, can mention all variables declared
in $\Gamma$.  The other judgements are organized similarly.  To
understand this distinction, consider judgement
$i \div \Size \der \Nat i$.  This would mean that $i$ is irrelevant in
$\Nat i$ and thus, $\Gamma \der \Nat a = \Nat {a'}$ for all sizes
$\resurrect\Gamma \der a,a' : \Size$.  But this is exactly wrong!  However,
judgement $i \div \Size \der \zero i : \Nat (i + 1)$ is fine, it
implies $\Gamma \der \zero a = \zero {a'} : \Nat (b+1)$ for all
$\resurrect\Gamma \der a,a',b : \Size$.

Our substitution theorem
needs to reflect the distinct scope of things left of the colon vs.\
things right of the colon.  In the last example we have applied the
substitution triple $\Gamma \der [a] = [a'] \eeq [b] : (i \div \Size)$
to judgement $i \div \Size \der \zero i : \Nat (i + 1)$.
The first two substitutions apply to the term side while the third
substitution applies to the type side.  The fact that we replace an
irrelevant variable $i$ allows $a,a',b$ to refer to irrelevant
variables from $\Gamma$, thus, they are in scope of $\resurrect\Gamma$.

%% COULD BE A LEMMA INSTEAD OF A RULE
% \begin{lemma}[Reflexivity]
%   If\/ $\Gamma \der t : T$ then $\Gamma \der t = t : T$.
% \end{lemma}

In the following, we list syntactic properties of our judgements.  To
this end, let $J$ %, $L$, and $R$
match a part of a judgement.

\begin{lemma}[Context well-formedness]
\label{lem:cxtwf}\bla
  \begin{enumerate}
  \item If\/ $\der \cext \Gamma \Delta$ then $\der \Gamma$
  \item If\/ $\Gamma \der J$ then $\der \Gamma$.
  \end{enumerate}
\end{lemma}

All types in a context are considered in the resurrected context,
which justifies the first statement of the following lemma.
A resurrected context is more permissive, as it brings more variable
into scope.  As such, it is comparable to an extended context or a
context where types have been replaced by subtypes.  This intuition
accounts for the remaining statments but (\ref{it:ressubst}).  The
latter is a defining property of substitutions: only replacement for
irrelevant sizes may refer to irrelevant size variables.
\begin{lemma}[Resurrection]
\label{lem:res} \bla
\begin{enumerate}
\item \label{it:reswf} $\der \Gamma$ iff $\der \resurrect\Gamma$;  then $\resurrect \Gamma \der \sid : \Gamma$.
  % Consequently, if\/ $\Gamma \der J$ then $\resurrect \Gamma \der J$.
  % Further, if\/ $\Gamma \der J : \resurrect\Delta$ then $\Gamma \der J : \Delta$.
\item If\/ $\Gamma \der J$ then $\resurrect \Gamma \der J$.
\item If\/ $\Gamma \der J : \resurrect \Delta$ % and $\der \Delta$
  then $\Gamma \der J : \Delta$.
\item \label{it:ressubst} If\/ $\Gamma \der \sigma : \Delta$ % then $\Gamma \der \sigma : \resurrect\Delta$.
  then $\resurrect\Gamma \der \sigma : \resurrect\Delta$.
\end{enumerate}
\end{lemma}

\begin{lemma}[Substitution]
\label{lem:sub}\bla
\begin{enumerate}
\item
  If\/ $\Gamma \der \sigma : \Delta$ and $\Delta \der J$ then $\Gamma \der J\sigma$.
\item
  If\/ $\Gamma \der \sigma = \sigma' \eeq \tau : \Delta$ and $\Delta \der t : T$ then
  $\Gamma \der t\sigma : T\tau$ and $\Gamma \der t\sigma' : T\tau$.
\end{enumerate}
\end{lemma}

\begin{lemma}[Specific substitutions]
\label{lem:specsub}\bla
\begin{enumerate}
\item If\/ $\der \cext \Gamma \Delta$ then $\cext \Gamma \Delta \der \slift_{|\Gamma|}^{|\Delta|} : \Gamma$.
      If\/ $\der \cext \Gamma T$ then $\cext \Gamma T \der \slift : \Gamma$.
\item If\/ $\der \Gamma$ then $\Gamma \der \sid : \Gamma$.
\item If\/ $\Gamma \der u : U$ then $\Gamma \der \sg u : \cext \Gamma U$.
\end{enumerate}
\end{lemma}

The relation $\sueq \Gamma \sigma {\sigma'} \tau \Delta$ is a partial equivalence
relation (PER) on term-side substitutions $\sigma,\sigma'$. Note that
we cannot resurrect this judgement to
$\sueq{\resurrect\Gamma}{\sigma}{\sigma'}\tau \Delta$ in general!
The type-side substitution $\tau$ can be converted to one that is
equal in and for resurrected contexts.
\begin{lemma}[Substitution equality]
\label{lem:subeq}\bla
\begin{enumerate}
\item Conversion: If\/ $\sueq \Gamma \sigma {\sigma'} {\tau_1} \Delta$ and $\sueq {\resurrect\Gamma} {\tau_1} {\tau_2} {\tau} {\resurrect\Delta}$ then $\sueq \Gamma \sigma {\sigma'} {\tau_2} \Delta$.
\item Reflexivity: If\/ $\Gamma \der \sigma : \Delta$ then $\sueq \Gamma \sigma \sigma \sigma \Delta$.
\item Symmetry:  If\/ $\sueq \Gamma \sigma {\sigma'} {\tau} \Delta$ then $\sueq \Gamma {\sigma'} {\sigma} {\tau} \Delta$.
\item Transitivity:  If\/ $\sueq \Gamma {\sigma_1} {\sigma_2} {\tau} \Delta$ and $\sueq \Gamma {\sigma_2} {\sigma_3} {\tau} \Delta$ then $\sueq \Gamma {\sigma_1} {\sigma_3} {\tau} \Delta$.
\item Functionality: Let $\sueq \Gamma \sigma {\sigma'} \tau \Delta$.
  \begin{enumerate}
  \item
  If\/ $\Delta \der t : T$ then $\Gamma \der t\sigma = t\sigma' : T\tau$.
  \item
  If\/ $\Delta \der t = t' : T$ then $\Gamma \der t\sigma = t'\sigma' : T\tau$.
  \item
  Corollary: If\/ $\Delta \der T \leq T'$ then $\Gamma \der T\sigma \leq T\sigma'$.
  \end{enumerate}
\end{enumerate}
\end{lemma}

\LONGVERSION{
\begin{corollary}[Partial resurrection for substitution equality]
  If\/ $\sueq \Gamma \sigma {\sigma'} {\tau} \Delta$ then
  $\sueq {\resurrect \Gamma} \tau \tau \tau {\resurrect \Delta}$.
\end{corollary}
}

\begin{lemma}[Inversion of typing]
\label{lem:invty} \bla
\begin{enumerate}
\item If\/ $\Gamma \der \Nat a : T'$ then $\Gamma \der a : \Size$ and $\resurrect\Gamma \der \Set[0] \leq T'$.
\item If\/ $\Gamma \der \Set[\ell] : T'$ then $\resurrect\Gamma \der \Set[\ell+1] \leq T'$.
\item If\/ $\Gamma \der \piT U T : T'$ then $\Gamma \der U : s$ and $\cext \Gamma U \der T : s$ and $\resurrect\Gamma \der s \leq T'$ for some $s$.
\item If\/ $\Gamma \der \epiT \Size T : T'$ then $\cext\Gamma \Size \der T : s$ and $\resurrect\Gamma \der s \leq T'$.
\item If\/ $\Gamma \der \ind i : T'$ then $\Gamma(i) = \erann[\noterased] T$ and $\resurrect\Gamma \der T \leq T'$ for some $T$.
\item If\/ $\Gamma \der \lambda t : T'$ then either
  $\cext \Gamma U \der t : T$
  and
  $\resurrect\Gamma \der \piT U T \leq T'$
  for some $U,T$ or
  $\eext \Gamma \Size \der t : T$
  and
  $\resurrect\Gamma \der \epiT\Size T \leq T'$
  for some $T$.
\item If\/ $\Gamma \der t\,u : T'$ then $\Gamma \der t : \piT U T$ and $\Gamma \der u : U$ and $\resurrect\Gamma \der T[u] \leq T'$ for some $U$, $T$.
\item If\/ $\Gamma \der t\,a : T'$ then $\Gamma \der t : \piT \Size T$ and $\Gamma \der a : \Size$ and $\resurrect\Gamma \der T[a] \leq T'$ for some $T$.
\item If\/ $\Gamma \der t\,\ann a : T'$ then $\Gamma \der t : \forallT T$ and $\resurrect\Gamma \der a : \Size$ and $\resurrect\Gamma \der T[a] \leq T'$ for some $T$.
\item If\/ $\Gamma \der \zero a : T'$ then $\resurrect \Gamma \der a,b : \Size$ and $\resurrect\Gamma \der \Nat (b + 1) \leq T'$ for some $b$.
\item If\/ $\Gamma \der \suc a t : T'$ then $\resurrect \Gamma \der a,b : \Size$ and $\Gamma \der t : \Nat b$ and $\resurrect\Gamma \der \Nat(b+1) \leq T'$.
\item If\/ $\Gamma \der u \case[\ell] T {t_z} {t_s} : T'$ then $\Gamma \der u : \Nat (a+1)$ and $\Gamma \der T : \Nat(a+1) \to \Set[\ell]$ and $\Gamma \der t_z : T\,(\zero a)$ and $\Gamma \der t_s : \funT x {\Nat a} {T\,(\suc a x)}$ and $\resurrect\Gamma \der T\,u \leq T'$ for some $a$.
\item If\/ $\Gamma \der u \fix[\ell] T t : T'$ then $\Gamma \der u : \Nat a$ and $\Gamma \der T : \Adm\,\ell$ and $\Gamma \der t : \FixT\,T$ and $\resurrect\Gamma \der T\,a\,u \leq T'$.
\end{enumerate}
\end{lemma}
\begin{proof}
  Each by induction on the typing derivation, gathering applications of the conversion rule via transitivity of subtyping.
\end{proof}



\section{Semantics and Completeness of Normalization by Evaluation}
\label{sec:sem}

We extend the syntax by de Bruijn levels $\lev k$
to be used as generic values (unknowns) and type annotations
$\up T t$ and $\down T t$ for lazy realizations of the
reflection and reification operations of NbE.
\[
\begin{array}{lllrl@{\qquad}l}
%  \Exp  & \ni & t & ::= & \dots \mid \lev k \mid \up T t \mid \down T t \\
  \Ne   & \ni & n & ::= & \dots \mid \lev k \\
  \tUp  & \ni & N & ::= & \up T n \\
  \Whnf & \ni & w & ::= & \dots \mid N \\
  \tDown & \ni & d & ::= & \down T t \\
  \Exp  & \ni & t & ::= & \dots \mid d \\
%  \Whnf & \ni & w,d,f,g,A,B,F,G & ::= & \dots \mid  \up T n \mid \down T t \\
\end{array}
\]


\begin{figure}
$$
\xymatrix@R=12ex@C=12ex{
\mathrlap{\mbox{Semantics ($\beta$)}} &
  &                f \in \D   \ar@[red][d]_{\down A}
\\
\mathrlap{\mbox{Semantics ($\beta\eta$)}} &
  &                d \in \DNf \ar@[red][d]_{\tR_k{}}
  &                n \in \DNe \ar[d]_{\tRne_k} \ar@[blue][ul]_{\up A}
  & \ar@[blue][l]_{\var{}} j \in \Level \ar@{<->}[d]_{k\dotminus(1+\_)}
\\
\mathrlap{\mbox{Syntax}} &
t \in \Exp \ar@[red]@(u,dl)[uur]^{\_\color{blue}\eta} %\ar@/^/[uur]^{\den\_}
  & \ar[l]_{\supseteq}  v \in \Nf
  & \ar[l]_{\supseteq}  m \in \Ne
  & \ar[l]_{\ind{}}     i \in \Index
  &
}
$$
\caption{Type-assignment NbE in locally nameless
    style.\label{fig:typedchart}}
\end{figure}

Figure~\ref{fig:typedchart}, adapted from \citet{abel:habil} shows the syntactic categories and main operations involved in NbE in what we call \emph{locally nameless style}.  The red path $\Exp \to \D \to \Dnf \to \Nf$ decomposes $\beta\eta$-normalization into three steps.
\begin{enumerate}
\item
First, we close the term $t$ with an environment $\eta$ that maps the free de Bruijn indices of $t$ to reflected de Bruijn levels.  Reflection of de Bruijn levels follows the blue path $\Level \to \Dne \to \D$: Levels embed via constructor $\var{}$ into semantic neutrals $\DNe$ which are labeled with their type $A \in \D$ to become and element $\up A \lev j \in \D$.

\item
Then, we label value $t \eta \in \D$ with its type $A$ to obtain $\down A t \eta \in \Dnf$.
\item
Finally, \emph{read back} %% $\tR_k$
$\tR_k \down{A} t\eta$ produces a long normal form $v \in \Nf$, converting de Bruijn levels back to indices.
Herein, $k$ should be the length of the context the original term $t$ lived in.
If this is the case, each de Bruijn level encountered during read back is below $k$ and can be safely converted to a de Bruijn index.
\end{enumerate}

\subsection{Operational semantics}

Judgements.
\[
\begin{array}{l@{\qquad}l}
  t \evalsto w & \mbox{term $t$ evaluates to weak head normal form $w$} \\
  w @ e \evalsto w' & \mbox{eliminating $w$ with $e$ evaluates to $w'$} \\
%  w @ \vec e \evalsto w' & \mbox{applying $w$ to eliminations $\vec e$ evaluates to $w'$} \\
\end{array}
\]

\fbox{$t \evalsto w$}
\begin{gather*}
  \ru{}{w \evalsto w}
\qquad
  \ru{t \evalsto w \qquad w @ e \evalsto w'}{t\,e \evalsto w'}
\end{gather*}

% \fbox{$w @ \vec e \evalsto w'$}
% \begin{gather*}
%   \ru{}{w @ () \evalsto w}
% \qquad
%   \ru{w @ e \evalsto w' \qquad
%       w' @ \vec e \evalsto w''
%     }{w @ (e, \vec e) \evalsto w''}
% \end{gather*}

\fbox{$w @ e \evalsto w'$}
\begin{gather*}
  \ru{t[u] \evalsto w
    }{(\lambda t) @ u \evalsto w}
\qquad
  \ru{t[\alpha] \evalsto w
    }{(\lambda t) @ \alpha \evalsto w}
\qquad
  \ru{t[\alpha] \evalsto w
    }{(\lambda t) @ \ann \alpha \evalsto w}
\\[2ex]
  \ru{t_z \evalsto w
    }{(\zero \alpha) @ \casett \evalsto w}
\qquad
  \ru{t_s\, t \evalsto w
    }{(\suc \alpha t) @ \casett \evalsto w}
\\[2ex]
  \ru{t\,\ann \alpha\,(\lambda x.\, x\, \fixtt)\,c \evalsto w
     }{c @ \fixtt \evalsto w
     }{c\in \{ \zero \alpha, \suc \alpha u \}}
\end{gather*}
The rules added for NbE deal with elimination of delayed reflection:
\begin{gather*}
  \ru{T' \evalsto \piT U T
    }{(\up {T'} n) @ u \evalsto \up{T[u]} (n \, \down U u) }
\qquad
  \ru{T' \evalsto \piT \Size T
    }{(\up {T'} n) @ \alpha \evalsto \up{T[\alpha]} (n \, \alpha)}
\qquad
  \ru{T' \evalsto \forallT T
    }{(\up {T'} n) @ \ann \alpha \evalsto \up{T[\alpha]} (n \ann \alpha)}
%   \ru{T \evalsto \piT A B \qquad
%       \up{B[u]} (n \, \down A u) \evalsto w
%     }{(\up T n) @ u \evalsto w}
% \qquad
%   \ru{T \evalsto \piT \Size B \qquad
%       \up{B[u]} (n \, \alpha) \evalsto w
%     }{(\up T n) @ \alpha \evalsto w}
% \qquad
%   \ru{T \evalsto \forallT B \qquad
%       \up{B[\alpha]} (n \ann \alpha) \evalsto w
%     }{(\up T n) @ \ann \alpha \evalsto w}
\\[2ex]
  \ru{%T' \evalsto \Nat \beta \qquad
    }{(\up {T'} n) @ \case[\ell] T {t_z} {t_s} \evalsto
      \up{T\,(\up{T'} n)}\,
      % \up{T\,(\up{\Nat \infty} n)}
         n\,\case[\ell]
             {(\down {\Nat \infty \to \Set[\ell]} T)}
             {(\down {T\,{\zero\infty}} t_z)}
             {(\down {\funS x {\Nat \infty} T\,(\suc \infty x)} t_s)}
    }
\\[2ex]
  \ru{%T' \evalsto \Nat \beta \qquad
    }{(\up {T'} n) @ \fix[\ell] T t \evalsto
      n\,\fix[\ell] {(\down {\FixK} T)} {(\down {\FixT\, T} t)}
    }
\end{gather*}

\subsection{Read back}
\label{sec:read}

Judgements.
\[
\begin{array}{l@{\qquad}l}
   \R k d  v     & \mbox{} \\
   \RTy k T  V  & \mbox{} \\
   \RNat k t  v & \mbox{} \\
   \RNe k t  m  & \mbox{} \\
\end{array}
\]
\fbox{$\R k d v$}
\begin{gather*}
  \ru{U \evalsto s \qquad
      \RTy k T V
    }{\R k {\down{U} T} V}
\qquad
  \ru{U \evalsto \Nat \alpha \qquad
      \RNat k u v
    }{\R k {\down{U} u} v}
\qquad
  \ru{U \evalsto N \qquad
      \RUp k u m
      % u \evalsto \up{T} n \qquad \RNe k n m
    }{\R k {\down{U} u} m}
\\[2ex]
  \ru{U \evalsto \piT A B \qquad
      \R{k+1} {\down{B[\up A \lev k]} (f\,\up A \lev k)} v
    }{\R k {\down{U} f} {\lambda v}}
\\[2ex]
  \ru{U \evalsto \piT \Size B \qquad
      \R{k+1} {\down{B[\lev k]} (f\,\lev k)} v
    }{\R k {\down{U} f} {\lambda v}}
\qquad
  \ru{U \evalsto \forallT B \qquad
      \R{k+1} {\down{B[\lev k]} (f\,\ann{\lev k})} v
    }{\R k {\down{U} f} {\lambda v}}
\end{gather*}

\fbox{$\RUp k t m$}\ \  Read back neutrals under annotation, which is ignored.
\begin{gather*}
  \ru{t \evalsto \up T n \qquad
      \RNe k n m
    }{\RUp k t m}
\end{gather*}

\fbox{$\RNat k t v $}
\begin{gather*}
  \ru{% t \evalsto \up {\Nat \alpha} n \qquad
      %t \evalsto \up {T} n \qquad \RNe k n m
      \RUp k t m
    }{\RNat k t m}
\qquad
  \ru{t \evalsto \zero{\alpha} \qquad
      \RSize k {\alpha} a
    }{\RNat k t {\zero a}}
\qquad
  \ru{t \evalsto \suc{\alpha}u \qquad
      \RSize k {\alpha} a \qquad
      \RNat k u v
    }{\RNat k t {\suc a v}}
\end{gather*}

\fbox{$\RSize k {\alpha} a$}
\begin{gather*}
  \ru{
    }{\RSize k \infty \infty}
\qquad
  \ru{
    }{\RSize k o o}
\qquad
  \ru{
    }{\RSize k {\lev j + o} {\ind{k\dotminus(1+j)} + o}}
\end{gather*}

\fbox{$\RNe k n m$} and \fbox{$\RElim k e e^v$}
\begin{gather*}
%   \ru{t \evalsto \lev j
%     }{\RNe k t {\ind{k-1-j}}}
% \qquad
  \ru{%t \evalsto \lev j\,\vec e \qquad
      \RElim k {e_i} {e^v_i} \mforall i
    }{\RNe k {\lev j\,\vec e} {\ind{k \monus (1+j)}\,\vec e^v}}
\qquad
% \end{gather*}
% \begin{gather*}
  \ru{\R k d v
    }{\RElim k d v}
\qquad
  \ru{\RSize k \alpha b
    }{\RElim k \alpha b}
\qquad
  \ru{
    }{\RElim k {\ann \alpha} {\ann \infty}}
  % \ru{\RSize k \alpha b
  %   }{\RElim k {\ann \alpha} {\ann b}}
\\[2ex]
  \ru{\R k D V \qquad
      \R k {d_z} {v_z} \qquad
      \R k {d_s} {v_s}
    }{\RElim k {(\case[\ell] D {d_z} {d_s})} {\case[\ell] V {v_z} {v_s}}}
\qquad
  \ru{\R k D V \qquad
      \R k d v
    }{\RElim k {(\fix[\ell] D d)} {\fix[\ell] V v}}
\end{gather*}
\fbox{$\RTy k T V$}
\begin{gather*}
  \ru{T \evalsto \Set[\ell]
    }{\RTy k T {\Set[\ell]}}
\qquad
  \ru{T \evalsto \Nat \alpha \qquad
      \RSize k \alpha b
    }{\RTy k T {\Nat b}}
\qquad
  \ru{% T \evalsto \up{U}n \qquad \RNe k n m
      \RUp k T m
    }{\RTy k T m}
\\[2ex]
  \ru{T \evalsto \piT A B \qquad
      \RTy k A {V_a} \qquad
      \RTy {k+1} B {V_b}
    }{\RTy k T {\piT {V_a} V_b}}
\qquad
  \ru{T \evalsto \epiT \Size B \qquad
      \RTy {k+1} B {V}
    }{\RTy k T {\epiT \Size V}}
\end{gather*}

% We write \fbox{$t \approx t'$} iff $t$ and $t'$ are syntactically equal if we ignore sizes $\ann a$ in irrelevant positions.  For example, $\suc a \tzero \approx \suc 0 \tzero$, but $\Nat a \not\approx \Nat 0$.



\subsection{Partial equivalence relations}
\label{sec:per}

A type $T$ will be interpreted as a partial equivalence relation (PER) $\A$ on terms, \ie, a relation which is symmetric and transitive. The domain $\dom(\A)$ of the relation can be thought of as the set of terms which define the extension of the type; on $\dom(\A) = \{a \mid \exists a'.\ (a,a') \in \A \}$ the relation $\A$ is in fact an equivalence relation.  We write $a = a' \in \A$ for relatedness in $\A$ and $a \in \A$ if $a \in \dom(\A)$.

The PERs $\NE$ characterizes neutral reifiable terms.
% \[
% \begin{array}{lll}%{l@{\quad}l@{\quad}l@{~}l@{~}l@{~}l@{~}l@{~}l}
%   \fbox{$\up T n = \up {T'} {n'} \in \NE$}
%     & \defas &
%     T \evalsto N \mand T' \evalsto N' \mand
%     \mforall k \mboth
%     \RNe k n m \mand \RNe k {n'} {m'} \mand m \nfeq m'
%     .\\
% \end{array}
% \]
The PERs $\NE$ and $\NF$ characterize (neutral) normalizing terms.
\[
\begin{array}{l@{\quad}l@{\quad}l@{~}l@{~}l@{~}l@{~}l@{~}l}
  \fbox{$n = n' \in \NE$}
    & \defas &
    \RNe k n m &\mand& \RNe k {n'} {m} &\mforall k \\
  \fbox{$d = d' \in \NF$}
    & \defas &
    \R k d v &\mand& \R k {d'} {v} &\mforall k \\
  \fbox{$e = e' \in \ELIM$}
    & \defas &
    \RElim k e e_v &\mand& \R k {e'} {e_v} &\mforall k \\
  \fbox{$A = A' \in \TY$}
    & \defas &
    \RTy k A V &\mand& \RTy k {A'} {V} &\mforall k \\
\end{array}
% \begin{array}{l@{\quad}l@{\quad}l@{~}l@{~}l@{~}l@{~}l@{~}l}
%   \fbox{$n = n' \in \NE$}
%     & \defas &
%     \RNe k n m &\mand& \RNe k {n'} {m'} &\mand& m \nfeq m' &\mforall k \\
%   \fbox{$d = d' \in \NF$}
%     & \defas &
%     \R k d v &\mand& \R k {d'} {v'} &\mand& v \nfeq v' &\mforall k \\
%   \fbox{$e = e' \in \ELIM$}
%     & \defas &
%     \RElim k e e_v &\mand& \R k {e'} {e_v'} &\mand& e_v \nfeq e_v' &\mforall k \\
%   \fbox{$A = A' \in \TY$}
%     & \defas &
%     \RTy k A V &\mand& \RTy k {A'} {V'} &\mand& V \nfeq V' &\mforall k \\
% \end{array}
  % \ru{\RNe k t m \mand \RNe k {t'} {m'} \mand m \nfeq m' \mforall k
  %   }{t = t' \in \NE}
  % \ru{t \evalsto \up N n \qquad t' \evalsto \up{N'}{n'} \qquad n \nfeq n'
  %   }{t = t' \in \NE}
\]
%All PERs $\A$ we consider are sandwiched $\NE \subseteq \A \subseteq \NF$ between $\NE$ and $\NF$.

\begin{lemma}[Closure properties of $\NE$]
  \label{lem:closne}
  \bla
  \begin{enumerate}
  \item $\lev k = \lev k \in \NE$.
  \item If\/ $n = n' \in \NE$ and $e = e' \in \ELIM$ then $n\,e = n'\,e' \in \NE$.
  \end{enumerate}
\end{lemma}

\begin{lemma}[Closure properties of $\ELIM$]
  \label{lem:closelim}
  \bla
  \begin{enumerate}
  \item If\/ $d = d' \in \NF$ then $d = d' \in \ELIM$.
  \item If\/ $\alpha \in \SIZE$ then $\alpha = \alpha \in \ELIM$.
  \item $\ann \alpha = \ann{\alpha'} \in \ELIM$.
  \item If\/ $A = A' \in \TY$ and $d_z = d_z' \in \NF$ and $d_s = d_s' \in \NF$
        then $\case[\ell] A {d_z}{d_s} = \case[\ell]{A'}{d_z'}{d_s'} \in \ELIM$.
  \item If\/ $D = D' \in \NF$ and $d = d' \in \NF$ then $\fix[\ell] D d = \fix[\ell]{D'}{d'} \in \ELIM$.
  \end{enumerate}
\end{lemma}

Now we define some PERs and PER constructors on values.  All these PERs $\A$ are closed under weak head equality, meaning if $a = b \in \A$ and $a'$ has the same weak head normal form as $a$, then $a' = b in \A$.  (By symmetry, $\A$ is also closed under weak head equality on the second argument.)

Neutrals in the value world $\D$.
\[
\fbox{$t = t' \in \NEE$} \defas
  t \evalsto \up T n \mand t' \evalsto \up{T'}{n'} \mand
  n = n' \in \NE
% \fbox{$\NEE$} \defas \{ (\up T n, \up{T'}{n'})
%   % \msuchthat T \evalsto N \mand T' \evalsto N' \mand
%   \mid n = n' \in \NE \}
\]
\fbox{$\NAT(\alpha)$}
\begin{gather*}
  \ru{% t \evalsto \up{\Nat \alpha} n \qquad
      % t' \evalsto \up{\Nat \alpha'} n' \qquad
      % n = n' \in \NE
      t = t' \in \NEE
    }{t = t' \in \NAT(\beta)}
\qquad
  \ru{t \evalsto \zero \alpha \qquad
      t' \evalsto \zero{\alpha'}
    }{t = t' \in \NAT(\beta+1)}
\qquad
  \ru{t \evalsto \suc \alpha u \qquad
      t' \evalsto \suc {\alpha'} {u'} \qquad
      u = u' \in \NAT(\beta)
    }{t = t' \in \NAT(\beta+1)}
\end{gather*}

\fbox{$\SIZE$} is a discrete PER of size values:
\begin{gather*}
  \ru{
    }{\infty = \infty \in \SIZE}
\qquad
  \ru{
    }{o = o \in \SIZE}
\qquad
  \ru{
    }{\lev k + o = \lev k + o \in \SIZE}
\end{gather*}

Let $\A$ be a PER and $\F$ a family of PERs over $\A$ such that
$\F(u) = \F(u')$ whenever $u = u' \in \A$.  We define
\[
  \fbox{$\PIAF$} \defas \{(t,t') \mid t\,u = t'\,u' \in \F(u) \mforall u = u' \in \A \}
  .
\]
This works also for $\A = \SIZE$.
For a family $\F$ over $\SIZE$ we also have the irrelevant function space
\[
  \fbox{$\FORALL\,\F$} \defas
  \{(t,t') \mid t \ann \alpha = t' \ann{\alpha'} \in \F(\beta) \mforall \alpha,\alpha',\beta \in \SIZE \}
  .
\]

% \begin{lemma}[PER Subsumption]
% \label{lem:subsump} \hfill
% \begin{enumerate}
% \item If\/ $\alpha \leq \beta$ then $\NAT(\alpha) \subseteq \NAT(\beta)$.
% \item If\/ $\F(\alpha) \leq \F'(\alpha)$ for all $\alpha \in \SIZE$, then $\FORALL \F \subseteq \FORALL \F'$.
% \item IF\/ $\A' \subseteq \A$ and $\F(u) \subseteq \F'(u)$ for all $u \in \A'$, then $\PIAF \subseteq \PI\,\A'\,\F'$.
% \end{enumerate}
% \end{lemma}



\subsection{PER model}
\label{sec:permode}

By induction on $\ell \in \NN$ we define the PER family
$\_ = \_ \in \Set[\ell]$ of types
together with the extension $\EL[\ell] T$ (for $T = T' \in \Set[\ell]$)
which is a PER of values of type $A$.
The rules for \fbox{$T = T' \in \SET[\ell]$} are:
\[
\begin{array}{l@{\qquad}l}
  \ru{% T \evalsto \up{\Set[\ell']} n \qquad
      % T' \evalsto \up{\Set[\ell'']} n' \qquad
      % n = n' \in \NE
      T = T' \in \NEE
    }{T = T' \in \SET[\ell]}
  & \EL[\ell](T) = \NEE
\\[3ex]
  \ru{T \evalsto \Nat\,\alpha \qquad T' \evalsto \Nat\,\alpha
    }{T = T' \in \SET[\ell]}
  & \EL[\ell](T) = \NAT(\alpha)
\\[3ex]
  \rux{T \evalsto \Set[\ell'] \qquad T' \evalsto \Set[\ell']
     }{T = T' \in \SET[\ell]
     }{\ell'{<}\ell}
  & \EL[\ell](T) = \SET[\ell']
\\[3ex]
  \rul{T \evalsto \piT A B \qquad
      T' \evalsto \piT{A'}{B'} \\
      A = A' \in \SET[\ell] \qquad
      B[u] = B'[u'] \in \SET[\ell] \mforall u = u' \in \EL[\ell](A)
    }{T = T' \in \SET[\ell]}
  & \EL[\ell](T) = \PI(\EL[\ell](A),\;u \mapsto \EL[\ell](B[u]))
\\[3ex]
  \rul{T \evalsto \piT \Size B \quad
      T' \evalsto \piT{\Size}{B'} \quad
      B[\alpha] = B'[\alpha] \in \SET[\ell] \mforall \alpha \in \SIZE
    }{T = T' \in \SET[\ell]}
  & \EL[\ell](T) = \PI(\SIZE,\; \alpha \mapsto \EL[\ell](B[\alpha]))
\\[3ex]
  \rul{T \evalsto \forallT B \quad
      T' \evalsto \forallT{B'} \quad
      B[\alpha] = B'[\alpha] \in \SET[\ell] \mforall \alpha \in \SIZE
    }{T = T' \in \SET[\ell]}
  & \EL[\ell](T) = \FORALL(\alpha \mapsto \EL[\ell](B[\alpha]))
\end{array}
\]
All relations involved here are closed under weak head equality.
\begin{lemma}[Well-definedness]
  Let $\DD :: T_1 = T_2 \in \SET[\ell]$.
  \begin{enumerate}
  \item Symmetry: $T_2 = T_1 \in \SET[\ell]$.
  \item Transitivity: If\/ $T_2 = T_3 \in \SET[\ell]$ then $T_1 = T_3 \in \SET[\ell]$.
  \item Extension: $\EL[\ell](T_1) = \EL[\ell](T_2)$ and ``both'' are PERs.
  \end{enumerate}
\end{lemma}
\begin{proof}
  Simultaneously by induction on $\DD$.
\end{proof}

% The PER model has the usual properties, one of them being that $\EL[\ell](T)$ does not depend $\ell$ nor the derivation that introduced $T = T' \in \SET[\ell]$.  Thus, we simply write $t = t' \in \EL(T)$ or even $t = t' \in T$.
\begin{lemma}[Derivation independence of extension]
\label{lem:indep}
  If\/ $\DD_1 :: T = T_1 \in \SET[\ell_1]$
  and $\DD_2 :: T_2 = T \in \SET[\ell_2]$ then $\EL[\ell_1](T) = \EL[\ell_2](T)$.
\end{lemma}
\begin{proof}
  By induction on $\DD_1$ and cases on $\DD_2$.
\end{proof}
Sine $\EL[\ell](T)$ does not depend $\ell$ nor the derivation that introduced $T = T' \in \SET[\ell]$,  we may simply write $t = t' \in \EL(T)$ or even $t = t' \in T$.


\subsection{Subtyping}
\label{sec:subty}

The semantic types (PERs) admit subsumption:

\begin{lemma}[Subsumption]
\label{lem:subsump} \hfill
\begin{enumerate}
\item \label{it:natsub} If\/ $\alpha \leq \beta$ then $\NAT(\alpha) \subseteq \NAT(\beta)$.
\item \label{it:allsub} If\/ $\F(\alpha) \subseteq \F'(\alpha)$ for all $\alpha \in \SIZE$, then $\FORALL \F \subseteq \FORALL \F'$.
\item \label{it:pisub}  If\/ $\A' \subseteq \A$ and $\F(u) \subseteq \F'(u)$ for all $u \in \A'$, then $\PIAF \subseteq \PI\,\A'\,\F'$.
\item \label{it:usub}  If\/ $\ell \leq \ell'$ then $\SET[\ell] \subseteq \SET[\ell']$.
\end{enumerate}
\end{lemma}
\begin{proof}
  Propositions (\ref{it:natsub}--\ref{it:pisub}) are clear.
  For (\ref{it:usub}), prove $T = T' \in \SET[\ell']$ by induction on $T = T' \in \SET[\ell]$.
  For the base types this is direct, let us look at the function space.
\[
  \rul{T \evalsto \piT A B \qquad
      T' \evalsto \piT{A'}{B'} \qquad
      A = A' \in \SET[\ell] \qquad
      B[u] = B'[u'] \in \SET[\ell] \mforall u = u' \in \EL[\ell](A)
    }{T = T' \in \SET[\ell]}
\]
  By induction hypothesis, $A = A' \in \SET[\ell']$, and we have $\EL[\ell'](A) = \EL[\ell](A)$ by Lemma~\ref{lem:indep}.  Assuming $u = u' \in \EL(A)$, we get $B[u] = B'[u'] \in \SET[\ell']$ by induction hypothesis on $B[u] = B'[u'] \in \SET[\ell]$.
\end{proof}
We can define subtyping of type values \fbox{$T \leq T' \in \TYPE$} by induction on $T \in \SET[\ell]$ and $T' \in \SET[\ell']$.
Simultaneously, we need to prove correctness, namely that $T \leq T' \in \TYPE$ implies $\EL(T) \subseteq \EL(T')$.  The correctness follows from Lemma~\ref{lem:subsump} and we do not spell it out here.
\begin{gather*}
  \ru{T = T' \in \NEE
    }{T \leq T' \in \TYPE}
\qquad
  \ru{T \evalsto \Nat \alpha \qquad
      T' \evalsto \Nat \alpha' \qquad
      \alpha \leq \alpha'
    }{T \leq T' \in \TYPE}
\qquad
  \ru{T \evalsto \Set[\ell_0] \qquad
      T' \evalsto \Set[\ell_0'] \qquad
      \ell_0 \leq \ell_0'
    }{T \leq T' \in \TYPE}
\\[2ex]
  \ru{T \evalsto \piT A B \qquad
      T' \evalsto \piT {A'}{B'} \qquad
      A' \leq A \in \TYPE \qquad
      B[u] \leq B'[u'] \in \TYPE \mforall u = u' \in A'
    }{T \leq T' \in \TYPE}
\\[2ex]
  \ru{T \evalsto \epiT \Size B \qquad
      T' \evalsto \epiT {\Size}{B'} \qquad
      B[\alpha] \leq B'[\alpha] \in \TYPE \mforall \alpha \in \SIZE
    }{T \leq T' \in \TYPE}
\end{gather*}
\begin{lemma}[Subtyping is preorder]
\label{lem:preord}
\bla
\begin{enumerate}
\item If\/ $T = T' \in \SET[\ell]$ then $T \leq T' \in \TYPE$.
\item If\/ $T_1 \leq T_2 \in \TYPE$ and $T_2 \leq T_3 \in \TYPE$ then $T_1 \leq T_3 \in \TYPE$.
\end{enumerate}
\end{lemma}


% \begin{lemma}[Universe subsumption]
%   \label{lem:usubsump}
%   If\/ $\ell \leq \ell'$ then $\SET[\ell] \subseteq \SET[\ell']$.
% \end{lemma}
% \begin{proof}
%   Prove $T = T' \in \SET[\ell']$ by induction on $T = T' \in \SET[\ell]$.
%   For the base types this is direct, let us look at the function space.
% \[
%   \rul{T \evalsto \piT A B \qquad
%       T' \evalsto \piT{A'}{B'} \qquad
%       A = A' \in \SET[\ell] \qquad
%       B[u] = B'[u'] \in \SET[\ell] \mforall u = u' \in \EL[\ell](A)
%     }{T = T' \in \SET[\ell]}
% \]
%   By induction hypothesis, $A = A' \in \SET[\ell']$, and we have $\EL[\ell'](A) = \EL[\ell](A)$ by Lemma~\ref{lem:indep}.  Assuming $u = u' \in \EL(A)$, we get $B[u] = B'[u'] \in \SET[\ell']$ by induction hypothesis on $B[u] = B'[u'] \in \SET[\ell]$.
% \end{proof}



\subsection{Type shapes}
\label{sec:shape}

Reflection and reification perform $\eta$-expansion such that we arrive at an $\eta$-long $\beta$-normal form.  To perform the $\eta$-expansion, not the precise type is needed, just the approximate shape, in particular, whether it is a function type (do expand) or a base type (do not expand).
For the logical framework, the shape of a dependent type is just its underlying simple type \cite{harperPfenning:equivalenceLF}. However, in the presence of universes and large eliminations, there is no underlying simple type.  Of course, we can take a type as its own shape, but we want at least that $\Nat \alpha$ and $\Nat \beta$ have the same shape even for different $\alpha, \beta$.  Thus, we define a relation $T \shape S$ to express that $S$ is a possible shape of type $T$.

\fbox{$T \shape S$} for $T \in \SET[\ell]$.  We call $T$ the \emph{template} and $S$ one of its possible \emph{shapes}.
\begin{gather*}
  \ru{T \evalsto N \qquad
      S \evalsto N'
    }{T \shape S}
\qquad
  \ru{T \evalsto \piT A B \qquad
      S \evalsto \piT{A'}{B'} \qquad
      A \shape A' \qquad
      B[u] \shape B'[u'] \mforall u = u' \in A
    }{T \shape S}
\\[2ex]
   \ru{T \evalsto \Set[\ell] \qquad
       S \evalsto \Set[\ell]
    }{T \shape S}
\qquad
  \ru{T \evalsto \piT \Size B \qquad
      S \evalsto \piT{\Size}{B'} \qquad
      B[\alpha] \shape B'[\alpha] \mforall \alpha \in \SIZE
    }{T \shape S}
\\[2ex]
  \ru{T \evalsto \Nat \alpha \qquad
      S \evalsto \Nat \beta
    }{T \shape S}
\qquad
  \ru{T \evalsto \forallT B \qquad
      S \evalsto \forallT{B'} \qquad
      B[\alpha] \shape B'[\alpha'] \mforall \alpha,\alpha' \in \SIZE
    }{T \shape S}
\end{gather*}
% The last rule is the crucial one

Note that $T \in \SET[\ell]$ and $T \shape S$ do not imply $S \in \SET[\ell]$.
Type shapes are not well-defined types in general.
For instance, assume a term $F : \Nat 0 \to \Set[0]$ which diverges if applied to a successor term.
Then $T := \funT x {\Nat 0} {F\,x}$ is a well-defined type; we have $T \in \SET[0]$.
Now consider $S := \funT x {\Nat \infty} {F\,x}$.
We have $T \shape S$, but $S$ is not well-defined; $S \not\in \SET[0]$.
% $\funT x {\Nat 0} {F\,x} \shape , but the latter one is not a well-defined type.

\begin{lemma}[Types are their own shapes]
  If\/ $T = T' \in \SET[\ell]$ then $T \shape T'$.
\end{lemma}

\begin{lemma}[Equal types make equally good templates]
  If\/ $T = T' \in \SET[\ell]$ and $T' \shape S$ then $T \shape S$.
\end{lemma}

However, templates are not closed under subtyping in either direction because of contravariance.

Further, it is not true that equal types make equally good shapes.  We do not have that
$T \shape S$ and $S = S' \in \SET[\ell]$ imply $T \shape S'$.  This property fails for function types.
Given $\piT U T \shape \piT R S$ and $\piT R S = \piT {R'}{S'} \in \SET[\ell]$ we would need to show that $T[u] \shape S'[u']$ for all $u = u' \in U$, but we only have $S[u] = S'[u'] \in \SET[\ell]$ for all $u = u' \in R$, thus the induction does not go through.  The fact that $U \shape R$ does not give us a handle on their inhabitants, we would need $U \leq R \in \TYPE$.
It is possible to construct an actual counterexample, using
$\piT {R'} S' =  \funT x {\Nat 0} {F\,x}$ from above and $\piT R S = \funT x {\Nat 0} {G\,x}$
such that $G$ is defined on all of $\Nat \infty$ but agrees with $F$ only on $x \in \Nat 0$.
Then $\piT U T = \funT x {\Nat \infty} {G\,x}$ gives the desired counterexample.

% Note that while such examples exist in the semantics, they probably do not exist in the syntax (where no well-typed term is diverging).  However, it is not clear to us how to define

% %% WRONG
% \begin{lemma}[Subtypes are valid templates]
%   Let $T \in \SET[\ell]$ and $T' \in \SET[\ell']$.
%   If\/ $T \leq T'$ and $T' \shape S'$ then $T \shape S'$.
% \end{lemma}
% \begin{proof}
% By induction on the derivations.
% \begin{caselist}

% \nextcase $T \evalsto \piT A B$ and $T' \evalsto \piT{A'}{B'}$ and $T' \evalsto \piT R S$.
% \\
% We have $A \shape R$ by induction hypothesis on $A' \leq A$ and $A' \shape R$.  No!
% \end{caselist}
% \end{proof}

Shapes are used to direct $\eta$-expansion when we reflect neutrals into semantic types and reify semantic values to long normal forms.  The following theorem is the heart of our technical development.

\begin{theorem}[Reflection and reification]
\label{thm:rere}
Let $T \in \SET[\ell]$ and $T \shape S_1$ and $T \shape S_2$.
\begin{enumerate}
\item If\/ $n_1 = n_2 \in \NE$ then $\up{S_1}{n_1} = \up{S_2}{n_2} \in T$.
\item If\/ $t_1 = t_2 \in T$ then $\down{S_1}{t_1} = \down{S_2}{t_2} \in \NF$.
\end{enumerate}
\end{theorem}
\begin{proof*}
By induction on $T \in \SET[\ell]$ and cases on $T \shape S_1$ and $T \shape S_2$.
\begin{caselist}

\nextcase $T \evalsto \piT A B$ with $A \in \SET[\ell]$ and
      $B[u] = B[u'] \in \SET[\ell] \mforall u = u' \in A$
\begin{gather*}
%   \ru{A \in \SET[\ell] \qquad
%       B[u] = B[u'] \in \SET[\ell] \mforall u = u' \in A
%     }{T \in \SET[\ell]}
% \\[2ex]
  \ru{S_1 \evalsto \piT{A_1}{B_1} \qquad
      A \shape A_1 \qquad
      B[u] \shape B_1[u'] \mforall u = u' \in A
    }{T \shape S_1}
\\[2ex]
  \ru{S_2 \evalsto \piT{A_2}{B_2} \qquad
      A \shape A_2 \qquad
      B[u] \shape B_2[u'] \mforall u = u' \in A
    }{T \shape S_2}
\end{gather*}
\begin{enumerate}
\item To show $\up{S_1}{n_1} = \up{S_2}{n_2} \in T$ assume arbitrary $u_1 = u_2 \in A$.
  Let $d_i = \down{A_i}{u_i}$.
  By induction hypothesis, $d_1 = d_2 \in \NF$.
  Thus, $n_1\,d_1 = n_2\,d_2 \in \NE$ by Lemma~\ref{lem:closne}, and
  by induction hypothesis,  $\up{B_1[u_1]}(n_1\,d_1) = \up{B_2[u_2]}(n_2\,d_2) \in B[u_1]$.
  With $(\up{S_i}{n_i})\,u_i \evalsto \up{B_i[u_i]}(n_i\,d_i)$ we are done by definition of $\EL(T)$.

\item We assume $k \in \NN$ and show $\R k {\down{S_i}{t_i}} \lambda v_i$ for some normal forms
$v_1,v_2$.  Let $u_i = \up{A_i} \lev k$.  Note that $u_1 = u_2 \in A$ by induction hypothesis.
It is sufficient to show
$\R{k+1}{\down{B_i[u_i]}{(t_i\,u_i)}} {v_i}$.
By definition of $\EL(T)$ we have $t_1\,u_1 = t_2\,u_2 \in B[u_1]$, thus, by induction hypothesis,
$\down{B_1[u_1]}(t_1\,u_1) = \down{B_2[u_2]}(t_2\,u_2) \in \NF$, which delivers $v_1$ and $v_2$ for $k+1$.
\end{enumerate}

\nextcase $T \evalsto \forallT B$ with $B[\alpha] \in \SET[\ell] \mforall \alpha \in \SIZE$
\begin{gather*}
%   \ru{B[\alpha] \in \SET[\ell] \mforall \alpha \in \SIZE
%     }{T \in \SET[\ell]}
% \\[2ex]
  \ru{S_1 \evalsto \forallT{B_1} \qquad
      B[\alpha] \shape B_1[\alpha'] \mforall \alpha, \alpha' \in \SIZE
    }{T \shape S_1}
%\\[2ex]
\qquad
  \ru{S_2 \evalsto \forallT{B_2} \qquad
      B[\alpha] \shape B_2[\alpha'] \mforall \alpha, \alpha' \in \SIZE
    }{T \shape S_2}
\end{gather*}
\begin{enumerate}
\item To show $\up{S_1}{n_1} = \up{S_2}{n_2} \in T$ assume arbitrary $\alpha_1,\alpha_2 \in \SIZE$.
  Since $n_1 \ann{\alpha_1} = n_2 \ann{\alpha_2} \in \NE$ by Lemma~\ref{lem:closne}, we obtain
  $\up{B_1[\alpha_1]}{(n_1 \ann{\alpha_1})} = \up{B_2[\alpha_2]}{(n_2 \ann{\alpha_2})} \in B[\alpha_1]$
  by induction hypothesis.
  Thus, $(\up{S_1}{n_1}) \ann{\alpha_1} = (\up{S_2}{n_2}) \ann{\alpha_2} \in B[\alpha_1]$
  by weak head expansion, which entails the goal by definition of $\EL(T)$.
\item Assume $k \in \NN$ and note that $\lev k = \lev k \in \SIZE$, hence,
  $t_1\,\ann{\lev k} = t_2\,\ann{\lev k} \in B[\lev k]$.  Thus, by induction hypothesis,
  $\R{k+1}{\down{B_i[\lev k]}(t_i\,\ann{\lev k})}{v_i}$, and finally
  $\R k {\down{S_i} t_i} {\lambda v_i}$ by definition of read back.
\qed
\end{enumerate}

\end{caselist}
\end{proof*}

\begin{corollary}
  \label{cor:rere}
  Let\/ $T \in \SET[\ell]$.
  \begin{enumerate}
  \item If\/ $n = n' \in \NE$ then $\up T n = \up T n' \in T$.
  \item If\/ $t = t' \in T$ then $\down T t = \down T {t'} \in \NF$.
  \end{enumerate}
\end{corollary}


\subsection{Computation}
\label{sec:comp}

The eliminations for natural numbers are accurately modeled.
\begin{lemma}[Case]
  \label{lem:case}
If\/ $a = a' \in \Nat (\alpha+1)$
and $B = B' \in \Nat (\alpha+1) \to \Set[\ell]$
and $f_z = f_z' \in B\,(\zero \beta)$
and $f_s = f_s' \in \funT x {\Nat \alpha} B\,(\suc \gamma x)$
then $a\,\case[\ell] B {f_z}{f_s} = a'\,\case[\ell] {B'} {f_z'}{f_s'} \in B\,a$.
\end{lemma}
\begin{proof*}
By induction on $a = a' \in \Nat(\alpha+1)$.
\begin{caselist}

\nextcase $a \evalsto \zero \beta$ and $a' \evalsto \zero{\beta'}$.
Since our PERs are closed under weak head equality,
and, for instance, $a\, \case[\ell] B {f_z}{f_s}$ has the same weak head normal form as $f_z$,
it suffices to show $f_z = f_z' \in B\,(\zero \beta)$, which is one of our assumptions.

\nextcase $a \evalsto \suc \beta b$ and $a' \evalsto \suc {\beta'}{b'}$ with $b = b' \in \Nat \alpha$.
Again, it suffices to show
$f_s\,b = f_s'\,b' \in B\,(\suc \beta b)$, which is an instance of our last assumption.

\nextcase $a \evalsto \up T n$ and $a' \evalsto \up {T'} n'$ with $n = n' \in \NE$.
Let $D = \down{\Nat \infty \to \Set[\ell]} B$
and $d_z = \down{B\,(\zero \infty)} f_z$
and $d_s = \down{\funS x {\Nat\,\infty} {B\,(\suc \infty x)}} f_s$
and $e = \case[\ell] D {d_z}{d_s}$.
% $e = \case[\ell]
%   {(\down{\Nat \infty \to \Set[\ell]} B)}
%   {(\down{B\,(\zero \infty)} f_z)}
%   {(\down{\funS x {\Nat\,\infty} {B\,(\suc \infty x)} f_s)}$
Let $D',d_z',d_s',e'$ be defined analogously from $B',f_z',f_s'$.  It suffices to show $e = e' \in \ELIM$, since then we have $n\,e = n'\,e' \in \NE$ by the closure properties of $\NE$ (Lemma~\ref{lem:closne}),
and $\up{B[a]} (n\,e) = \up{B'[a']} (n'\,e') \in B[a]$ by reflection (Theorem~\ref{thm:rere}).
The remaining goal $\case[\ell] D {d_z}{d_s} = \case[\ell] {D'} {d_z'}{d_s'} \in \ELIM$ follows by the closure properties for eliminations (Lemma~\ref{lem:closelim}), since $D = D' \in \NF$ and $d_z = d_z' \in \NF$ and $d_s = d_s' \in \NF$ all hold by reification (Theorem~\ref{thm:rere}).
\qed
\end{caselist}
\end{proof*}

\begin{lemma}[$\NAT$ is cocontinuous]
  \label{lem:limit}
  $\NAT(\infty) = \bigcup_{\alpha < \infty} \NAT(\alpha)$.
\end{lemma}
\begin{proof}
  By induction on $a = a' \in \NAT(\infty)$, we can easily show $a = a' \in \NAT(\alpha)$ for some $\alpha < \infty$.
  For instance, $\alpha$ could be number of uses of the successor rule plus one.
\end{proof}

%A type constructor $B \in \FixK\,\ell$ is \emph{admissible for recursion}, \fbox{$B \in \ADM$}, if
%$\bigcap_{
Let us write \fbox{$B = B' \in \Adm\ell$} iff $B = B' \in \FixK\,\ell$ and
for all $\beta \in \SIZE$ and $a \in \Nat \beta$ we have
$B\,\beta\, a \leq B\,\infty\,a \in \TYPE$ and
$B'\,\beta\, a \leq B'\,\infty\,a \in \TYPE$.
\begin{lemma}[Fix]
Let $g = a \, \fix[\ell] B f$ and $g' = a'\,\fix[\ell]{B'}{f'}$.
If\/ $a = a' \in \Nat \alpha$
and $B = B' \in \Adm\ell$
and $f = f' \in \FixT\,B$
then $g = g' \in B\,\alpha\,a$.
\end{lemma}
\begin{proof*}
By well-founded induction on $\alpha$.
\begin{caselist}

\nextcase $\alpha < \infty$ and $a \evalsto \up{T}n$ and $a' \evalsto \up{T'}{n'}$ and $n = n' \in \NE$.
In this case $g$ and $g'$ evaluate to neutral applications of $\tfix$.  The proof proceeds analogously to Lemma~\ref{lem:case}.

\nextcase $\alpha < \infty$ and $a \evalsto c$ and $a' \evalsto c'$.  Then $\alpha = \beta + 1$ with $\beta<\infty$.
The weak head normal form of $g$ equals the weak head normal form of
$h := f\,\ann \gamma\,(\lambda x.\,x\,\fix[\ell] B f)\,c$ where $\gamma$ is the size annotation of $c$.
It suffices to show $h = h' \in B\,\alpha\,a$ for $h'$ defined analogously from $B',f',c'$.
This follows from the assumption on $f, f'$ if we manage to show
$(\lambda x.\,x\,\fix[\ell] B f) = (\lambda x.\,x\,\fix[\ell] {B'} {f'}) \in
\funT x {\Nat\beta} {B\,\beta\,x}$.
To this end, assume $b = b' \in \Nat\beta$ and show
$b\,\fix[\ell] B f = b'\,\fix[\ell] {B'} {f'} \in B\,\beta\,b$.
However, this is an instance of the induction hypothesis thanks to $\beta < \alpha$.


\nextcase $\alpha = \infty$.
Note that $a = a' \in \Nat \alpha$ for some $\alpha < \infty$ by Lemma~\ref{lem:limit}.
By induction hypothesis, $g = g' \in B\,\alpha\,a$.  Since
$B\,\alpha\,a \leq B\,\infty\,a$ by assumption, the goal
$g = g' \in B\,\infty\,a$ follows by subsumption.
\qed
\end{caselist}
\end{proof*}

\subsection{Fundamental Theorem}
\label{sec:fund}

PER of substitutions
\fbox{$\eta = \eta' \eeq \rho \in \Gamma$}.
\begin{gather*}
  \ru{
    }{\sempty = \sempty \eeq \sempty \in \cempty}
\qquad
  \ru{\eta = \eta' \eeq \rho \in \Gamma \qquad
      T\rho \in \SET[\ell] \qquad
      u = u' = t \in T \rho
    }{\sext \eta u = \sext{\eta'}{u'} \eeq \sext{\rho}{t} \in \cext \Gamma T}
\\[2ex]
  \ru{\eta = \eta' \eeq \rho \in \Gamma \qquad \alpha \in \SIZE
    }{\sext \eta \alpha = \sext{\eta'}{\alpha} \eeq \sext{\rho}{\alpha} \in \cext \Gamma \Size}
\qquad
  \ru{\eta = \eta' \eeq \rho \in \Gamma \qquad \alpha,\alpha',\beta \in \SIZE
    }{\sext \eta \alpha = \sext{\eta'}{\alpha'} \eeq \sext{\rho}{\beta} \in \erext \Gamma \Size}
\end{gather*}
We write $\rho \in \Gamma$ for $\rho = \rho \eeq \rho \in \Gamma$.
\begin{lemma}[Resurrection]
  \label{lem:resenv}
  If\/ $\eta = \eta' \eeq \rho \in \Gamma$ then $\rho \in \resurrect\Gamma$.
\end{lemma}

Semantic judgements:
\[
\begin{array}{l@{\quad}l@{\quad}l}
  \models () & \defas & \mtrue \\
  \models \eext \Gamma \Size & \defas & \models \Gamma \\
  \models \cext \Gamma T     & \defas & \models \Gamma \mand \resurrect\Gamma \models T
\\[2ex]
  \Gamma \models s & \defas & \models \Gamma \\
%  \Gamma \models s & \defas & \mtrue \\
  \Gamma \models T & \defas & \Gamma \models T = T \\
  \Gamma \models T = T' & \defas & \Gamma \models T = T' : s \mforsome s %\Set[\ell] \mforsome \ell
\\[2ex]
  \Gamma \models T \leq T' & \defas & \Gamma \models T \mand \Gamma \models T' \mand
    T\eta \leq T'\eta' \in \TYPE
    % \EL(T\eta) \subseteq \EL(T'\eta')
    \mforall \eta = \eta' \eeq \rho \in \Gamma
\\[2ex]
  \Gamma \models t : T & \defas & \Gamma \models t = t : T \\
  \Gamma \models t = t' : T & \defas & %\models \Gamma \mand
    % \resurrect\Gamma \models T \mand
    \models \cext \Gamma T \mand
    t \eta = t' \eta' \in T \rho \mforall \eta = \eta' \eeq \rho \in \Gamma
\\[2ex]
  \Gamma \models \sigma : \Delta & \defas & \Gamma \models \sigma = \sigma \eeq \sigma : \Delta \\
  \Gamma \models \sigma = \sigma' \eeq \tau : \Delta & \defas &
    \models \Gamma \mand \models \Delta \mand
    \sigma \eta = \sigma' \eta' \eeq \tau \rho \in \Delta
    \mforall \eta = \eta' \eeq \rho \in \Gamma
\end{array}
\]

\begin{theorem}[Fundamental theorem]
  \label{thm:fund}
  \bla
  \begin{enumerate}
  \item
  If\/ $\der \Gamma$ then $\models \Gamma$.
  \item
  If\/ $\Gamma \der J$ then % $\models \Gamma$ and
  $\Gamma \models J$
  \end{enumerate}
\end{theorem}
\SHORTVERSION{
\begin{proof}
Simultaneously, by induction on the derivation.
\end{proof}
}
\LONGVERSION{  % BEGIN LONGVERSION
\begin{proof*}
Simultaneously, by induction on the derivation.
% The soundness of subtyping and the conversion rule is due to subsumption (lemmata \ref{lem:subsump} and \ref{lem:usubsump}).

\begin{caselist}
\nextcase $\forall$-introduction.
\[
  \ru{\erext \Gamma \Size \der t = t' : T
    }{\Gamma \der \lambda t = \lambda t' : \forall T}
\]
First $\models \Gamma$ follows from the induction hypothesis $\models {\erext \Gamma \Size}$.
To show $\resurrect\Gamma \models \forall T$,
assume $\eta = \eta' \eeq \rho \in \resurrect \Gamma$
and show $(\forall T)\eta = (\forall T)\eta' \in \SET[\ell]$ for some $\ell$.
To this end, assume $\alpha \in \SIZE$ and show $T(\eta,\alpha) = T(\eta',\alpha) \in \SET[\ell]$.
Note that $(\eta,\alpha) = (\eta',\alpha) \eeq (\rho,\alpha) \in
\resurrect {\erext \Gamma \Size} = \cext {\resurrect\Gamma}\Size$,
thus, we can instantiate the induction hypothesis and obtain our goal.

For the main goal,
assume $\eta = \eta' \eeq \rho \in \Gamma$ and
show $(\lambda t)\eta = (\lambda t')\eta' \in (\forall T)\rho$.
To this end, assume arbitrary $\alpha,\alpha',\beta \in \SIZE$ and show
$t(\eta,\alpha) = t'(\eta',\alpha') \in T(\rho,\beta)$.
Since $(\eta,\alpha) = (\eta',\alpha') \eeq (\rho,\beta) \in \erext \Gamma \Size$,
we conclude by induction hypothesis.

\nextcase $\forall$-elimination.
\[
  \ru{\Gamma \der t = t' : \forall T \qquad
      \Gamma \der a, a' : \Size \qquad
      \resurrect\Gamma \der b : \Size
    }{\Gamma \der t \ann a = t' \ann {a'} : T[b]}
\]
First, $\models \Gamma$ follows by induction hypothesis.
For goal $\resurrect \Gamma \models T[b]$,
assume $\eta = \eta' \eeq \rho \in \resurrect\Gamma$ and show
$T[b]\eta = T[b]\eta' \in \SET[\ell]$ for some $\ell$.
By induction hypothesis,  $b\eta = b\eta' \in \SIZE$.
% , thus,
% $(\eta,b\eta) = (\eta',b\eta') \eeq (\rho,b\eta) \in \cext{\resurrect\Gamma}\Size$
By another induction hypothesis, $(\forall T)\eta = (\forall T)\eta' \in \SET[\ell]$,
which by definition entails our goal $T(\eta, b\eta) = T(\eta', b\eta') \in \SET[\ell]$.


For the remaining main goal,
assume $\eta = \eta' \eeq \rho \in \Gamma$ and
show $t \ann a \eta = t' \ann{a'} \eta' \in T[b]\rho$.
By definition of substitution, it suffices to show
$t \eta \ann{a \eta} = t' \eta' \ann{a' \eta'} \in T(\rho, b \rho)$.
By induction hypothesis,
$t \eta = t' \eta' : (\forall T) \rho$, thus, by definition of this PER,
$t \eta \ann {\alpha_1} = t' \eta' \ann{\alpha_2} \in T(\rho, b')$ for any size values $\alpha_1$, $\alpha_2$, and $b'$.
We conclude by choosing $\alpha_1 = a \eta$ and $\alpha_2 = a' \eta'$ and $b' = b \rho$.

We now argue that this choice is possible,
namely that $a \eta, a'\eta, b\rho \in \SIZE$.
Note that the induction hypothesis gives us
$a \eta  = a  \eta' \in \SIZE$ and
$a' \eta = a' \eta' \in \SIZE$.
By resurrection (Lemma~\ref{lem:resenv}) we have $\rho \in \resurrect\Gamma$,
thus, by induction hypothesis, $b \rho \in \SIZE$.
\qed
\end{caselist}
\end{proof*}
} % END LONGVERSION

\subsection{Completeness of NbE}
\label{sec:compl}

We write $\var\Gamma$ for $\var{|\Gamma|}$.
We define the identity environment $\rho_\Gamma$ by induction on $\Gamma$.
We set $\rho_{\cempty} = \sempty$ and
\[
\begin{array}{lll}
  \rho_{\cext \Gamma T} & = & (\rho_\Gamma, \up{T\rho_\Gamma} \var\Gamma) \\
  \rho_{\eext \Gamma \Size} & = & (\rho_\Gamma, \var\Gamma) \\
\end{array}
\]
\begin{lemma}[Identity environment]
  If\/ $\der \Gamma$ then
  $\rho_\Gamma \in \Gamma$.
  % $\rho_\Gamma = \rho_\Gamma \eeq \rho_\Gamma \in \Gamma$
\end{lemma}
\begin{proof*}
By induction on $\der \Gamma$.
\begin{caselist}

\nextcase
\[
  \ru{\der \Gamma \qquad \resurrect\Gamma \der T
    }{\der \cext\Gamma T}
\]
By induction hypothesis $\rho_\Gamma \in \Gamma$.
By resurrection (Lemma~\ref{lem:resenv}) $\rho_\Gamma \in \resurrect\Gamma$.
By the fundamental theorem (Thm.~\ref{thm:fund}) we have $A := T\rho_\Gamma \in \SET[\ell]$ for some $\ell$.
By reflection (Cor.~\ref{cor:rere}) it follows that $\up A \var\Gamma \in A$, thus
$(\rho_\Gamma, \up A \var\Gamma) \in \cext \Gamma T$.

\nextcase
\[
  \ru{\der \Gamma
    }{\der \eext\Gamma \Size}
\]
By induction hypothesis $\rho_\Gamma \in \Gamma$.  Since $\var\Gamma \in \SIZE$ we conclude
$(\rho_\Gamma, \var\Gamma) \in \eext\Gamma \Size)$.
\qed
\end{caselist}
\end{proof*}

We can now define the normalization relation
$\fbox{$\nbe \Gamma T t \evalsto v$} \iff \R {\Gamma} {\down{T \rho_\Gamma} (t \rho_\Gamma)} v$.
Whenever $\nbe \Gamma T t \evalsto v$, we may write $\nbe \Gamma T t$ for $v$.

\begin{theorem}[Completeness of NbE]
  If\/ $\Gamma \der t = t' : T$ then there is a normal form $v$ such that
  $\nbe \Gamma T t \evalsto v$ and $\nbe \Gamma T {t'} \evalsto v$.
  % If\/ $\Gamma \der t = t' : T$ then there are normal forms $v \nfeq v'$ such that
  % $\nbe \Gamma T t \evalsto v$ and $\nbe \Gamma T {t'} \evalsto v'$.
\end{theorem}
\begin{proof}
  By the fundamental theorem, $T \rho_\Gamma \in \SET[\ell]$ for some $\ell$ and
  $t \rhog = t' \rhog \in T\rhog$.  By reification (Cor.~\ref{cor:rere}) we have
  $\down{T\rhog} (t\rhog) = \down{T\rhog}(t'\rhog) \in \NF$ which implies the theorem
  by read back with $k = |\Gamma|$.
\end{proof}



\section{Soundness  of Normalization by Evaluation}
\label{sec:soundnbe}

In this section, we show that NbE is sound for judgmental equality, i.e., that same normal form implies definitional equality.  The proof follows \citet{abelCoquandDybjer:lics07,abel:habil}.  However, the logical relation defined in the following will also yield a weak head normalization theorem.
\begin{alignat*}{8}
& \Gamma \der a && \doteq \tRsize\, \alpha
  && \quad\defas\quad
  && \forall \xi : \Gamma' \leq \Gamma.\ \
  && \mathrlap{ \RSize {\Gamma'} \alpha {a\xi} }
\\[-0.6ex]
& \Gamma \der T && \doteq \tRty\, A  : s
  && \quad\defas\quad
  && \forall \xi : \Gamma' \leq \Gamma.\ \
  && \exists V.\
  && \RTy{\Gamma'} A V
  && ~\mand~ \Gamma' \der T\xi = V : s
\\[-0.6ex]
& \Gamma \der t && \doteq \tR\, d  : T
  && \quad\defas\quad
  && \forall \xi : \Gamma' \leq \Gamma.\ \
  && \exists v.\
  && \R{\Gamma'} d v
  && ~\mand~ \Gamma' \der t\xi = v : T\xi
\\[-0.6ex]
& \Gamma \der t && \doteq \tRne\, n  : T
  && \quad\defas\quad
  && \forall \xi : \Gamma' \leq \Gamma.\ \
  && \exists m.\
  && \RNe{\Gamma'} n m
  && ~\mand~ \Gamma' \der t\xi = m : T\xi
\end{alignat*}
% \[
% \begin{array}{lll}
% \Gamma \der a \doteq \tRsize\, \alpha
%   & \defas &
%   \forall \xi : \Gamma' \leq \Gamma.\ \ \RSize {\Gamma'} \alpha {a\xi}
% \\
% \Gamma \der T \doteq \tRty\, A : s
%   & \defas &
%   \forall \xi : \Gamma' \leq \Gamma.\ \
%   \exists V.\
%   \RTy{\Gamma'} A V \mand
%   \Gamma' \der T\xi = V : s
% \\
% \Gamma \der t \doteq \tR\, d : T
%   & \defas &
%   \forall \xi : \Gamma' \leq \Gamma.\ \
%   \exists v.\
%   \R{\Gamma'} d v \mand
%   \Gamma' \der t\xi = v : T\xi
% \\
% \Gamma \der t \doteq \tRne\, n : T
%   & \defas &
%   \forall \xi : \Gamma' \leq \Gamma.\ \
%   \exists m.\
%   \RNe{\Gamma'} n m \mand
%   \Gamma' \der t\xi = m : T\xi
% \end{array}
% \]
% \[
%   \fbox{$\LRSize \Gamma a \alpha$} \defas
%   \forall \xi : \Gamma' \leq \Gamma.\ \
%   \RSize {\Gamma'} \alpha {a\xi}
%   % \exists a'.\
%   % \RSize {\Gamma'} \alpha a' \mand
%   % \Gamma' \der a\xi = a' : \Size
% \]
By definitions, these relations are closed under subsumption and
weakening, e.g., if\/ $\RD \Gamma t d T$ and $\Gamma \der T \leq T'$ then $\RD \Gamma t d T'$,
and if\/ $\xi : \Gamma \leq \Gamma'$ then $\RD{\Gamma'}{t\xi}d{T\xi}$.

\begin{lemma}[Closure properties for neutrals]
\label{lem:rclosne}
\bla
\begin{enumerate}
\item If\/ $\RNE \Gamma t n \piT U T$ and $\RD \Gamma u d U$ then $\RNE \Gamma {t\,u} {n\,d} {T[u]}$.
\item If\/ $\RNE \Gamma t n \piT \Size T$ and $\RSIZE \Gamma a \alpha$ then $\RNE \Gamma {t\,a} {n\,\alpha} {T[a]}$.
\item If\/ $\RNE \Gamma t n \forallT T$ and $\RSIZE {\resurrect\Gamma} a \alpha$ then $\RNE \Gamma {t\,\ann a} {n\,\ann \alpha} {T[a]}$.
\end{enumerate}
\end{lemma}

Let \fbox{$\Gamma \der T \evalsto W : s$} denote the conjunction of $T \evalsto W$ and $\Gamma \der T = W : s$.
We simultaneously define
\fbox{$\LRTS \Gamma {T'} {A'} s$} for $\Gamma \der T' : s$
and \fbox{$\LR \Gamma t {T'} f {A'}$} for $\Gamma \der t : T'$ and $f \in A'$
by induction on ${A'} \in s$.

\begin{caselist}

\vspace{2ex}
\nextcase $A' \evalsto N$ neutral.

  \noindent
  $\LRTS{\Gamma}{T'}{A'} s$ iff
  $\Gamma \der T' \evalsto n : s$ for some neutral $n$ and
  $\Gamma \der T' \doteq \tRty\,A' : s$
  %$\forall \xi : \Gamma' \leq \Gamma.\ \ \exists M.\ \ \RTy{\Gamma'}{A'}M \mand \Gamma' \der T'\xi = M : \Set[\ell]$.

  \noindent
  $\LR{\Gamma}{t}{T'}{f}{A'}$ iff
  $\Gamma \der t \doteq \tR \, \down {A'} f : T'$
  % $\forall \xi : \Gamma' \leq \Gamma.\ \
  %  \exists m. \ \
  %  \R {\Gamma'} {\down {A'} f} m \mand
  %  \Gamma' \der t\xi = m : T'\xi$.

\vspace{2ex}
\nextcase $A' \evalsto \Nat \alpha$.

  \noindent
  $\LRTS{\Gamma}{T'}{A'} s$ iff $\Gamma \der T' \evalsto \Nat a : s$ for some $a$ and $\LRSize \Gamma a \alpha$.

  \noindent
  $\LR{\Gamma}{t}{T'}{f}{A'}$ iff $\resurrect\Gamma \der T' \evalsto \Nat a$ for some $a$ and
  $\LRSize {\resurrect\Gamma} a \alpha$ and
  $\Gamma \der t \doteq \tR\,\down{A'} f : \Nat a$
  % \\
  % $\forall \xi : \Gamma' \leq \Gamma.\ \
  %  \exists v. \ \
  %  \R {\Gamma'} {\down {A'} f} v \mand
  %  \Gamma' \der t\xi = v : \Nat\,a\xi$.


\vspace{2ex}
\nextcase $A' \evalsto \Set[\ell']$.

  \noindent
  $\LRTS {\Gamma} {T'} {A'} s$ iff $\Gamma \der T' \evalsto \Set[\ell'] : s$.

  \noindent
  $\LR \Gamma U {T'} B {A'}$ iff
  $\resurrect\Gamma \der T' \evalsto \Set[\ell'] : s$ and $\LRT \Gamma U B {\ell'}$.

\vspace{2ex}
\nextcase $A' \evalsto \piT A B$.

\noindent
$\LRTS \Gamma {T'} {A'} s$ iff
\(
\begin{array}[t]{l}
\Gamma \der T' \evalsto \piT U T : s \mforsome U, T \mand \LRTS \Gamma U A s \mand \\
\forall \xi : \Gamma' \leq \Gamma.\ \
\LR {\Gamma'} u {U\xi} a A \implies \LRTS {\Gamma'} {T(\xi,u)} {B[a]} s
. \\
\end{array}
\) \\
$\LR \Gamma t {T'} f {A'}$ iff
\(
\begin{array}[t]{l}
\resurrect\Gamma \der T' \evalsto \piT U T : s \mforsome U, T \mand \LRTS {\resurrect\Gamma} U A s \mand \\
\forall \xi : \Gamma' \leq \Gamma.\ \
\LR {\Gamma'} u {U\xi} a A \implies \LR {\Gamma'} {t\xi\,u} {T(\xi,u)} {f\,a} {B[a]}
.
\end{array}
\)

\vspace{2ex}
\nextcase $A' \evalsto \piT \Size B$.

\noindent
$\LRTS \Gamma {T'} {A'} s$ iff
\(
\begin{array}[t]{l}
\Gamma \der T' \evalsto \piT \Size T : s \mforsome T\\
\forall \xi : \Gamma' \leq \Gamma.\ \
\LRSize {\Gamma'} a \alpha
\implies \LRTS {\Gamma'} {T(\xi,a)} {B[\alpha]} s
.
\end{array}
\) \\
$\LR \Gamma t {T'} f {A'}$ iff
\(
\begin{array}[t]{l}
\resurrect\Gamma \der T' \evalsto \piT \Size T : s \mforsome T\\
\forall \xi : \Gamma' \leq \Gamma.\ \
\LRSize {\Gamma'} a \alpha
\implies \LR {\Gamma'} {t\xi\,a} {T(\xi,a)} {f\,\alpha} {B[\alpha]}
.
\end{array}
\)

\vspace{2ex}
\nextcase $A' \evalsto \forallT B$.

\noindent
$\LRTS \Gamma {T'} {A'} s$ iff
\(
\begin{array}[t]{l}
\Gamma \der T' \evalsto \forallT T : s \mforsome T\\
\forall \xi : \Gamma' \leq \Gamma,\
{\Gamma'} \der b : \Size,\
\beta \in \SIZE. \ \
\LRSize {\Gamma'} b \beta
\implies \LRTS {\Gamma'} {T(\xi,b)} {B[\beta]} s
.
\end{array}
\) \\
$\LR \Gamma t {T'} f {A'}$ iff
\(
\begin{array}[t]{l}
\resurrect\Gamma \der T' \evalsto \forallT T : s \mforsome T\\
\forall \xi : \Gamma' \leq \Gamma,\
%\Gamma' \der a : \Size,\
\resurrect{\Gamma'} \der a,b : \Size,\
\alpha,\beta \in \SIZE. \ \\ \qquad
\LRSize {\resurrect{\Gamma'}} b \beta
\implies \LR {\Gamma'} {t\xi\,\ann a} {T(\xi,b)} {f\,\ann\alpha} {B[\beta]}
.
\end{array}
\)
\end{caselist}
We may prove theorems ``by induction on $\LRTS \Gamma T A s$'', even if in reality this will be proofs by induction on $A \in s$ and cases on $\LRTS \Gamma T A s$.
We write \fbox{$\RG \Gamma T A$} if\/ $\LRTS \Gamma T A s$ for some sort $s$.


\begin{lemma}[Weakening]
  Let $\xi : \Gamma' \leq \Gamma$.
  \begin{enumerate}
  \item If\/ $\LRSize \Gamma a \alpha$ then $\LRSize{\Gamma'}{a\xi}\alpha$.
  \item If\/ $\LRTS {\Gamma} T A s$ then $\LRTS{\Gamma'}{T\xi}A s$.
  \item If\/ $\LR \Gamma t T f A$ then $\LR{\Gamma'}{t\xi}{T\xi} f A$.
  \end{enumerate}
\end{lemma}

%% NO LONGER TRUE AT THIS POINT
% \begin{lemma}[Compatibility with definitional equality]
%   Let $\Gamma \der T = T'$.
%   \begin{enumerate}
%   \item If\/ $\LRT \Gamma T A \ell$ then $\LRT \Gamma {T'} A \ell$.
%   \item If\/ $\LR \Gamma t T f A$ and $\Gamma \der t = t' : T$ then $\LR \Gamma {t'}{T'} f A$.
%   \end{enumerate}
% \end{lemma}

\begin{theorem}[Into and out of the logical relation]
\label{thm:into}
\bla
Let $\LRTS{\Gamma} T A s$. Then:
%Let $A \in s$.
\begin{enumerate}

\item \label{it:into}
   If\/ $\Gamma \der t \doteq \tRne\,n : T$ then
   $\LR \Gamma t T {\up A n} A$.

\item \label{it:out}
  If\/ $\LR \Gamma t T f A$ then
  $\Gamma \der t \doteq \tR\,\down A f : T$.

\item \label{it:outty}
   %If\/ $\LRTS{\Gamma} T A s$ then
   $\Gamma \der T \doteq \tRty\,A : s$.

% \item \label{it:into}
%    $\LR \Gamma t T {\up A n} A$ if for all $\xi : \Gamma' \leq \Gamma$ there is an $m$ such that
%    $\RNe{\Gamma'}n m$ and\/ $\Gamma' \der t\xi = m : T$.

% \item \label{it:outty}
%    If\/ $\LRT{\Gamma} T A \ell$ then for all $\xi : \Gamma' \leq \Gamma$
%    there is some normal form $V$ such that
%    $\Rty{\Gamma'} A V$ and $\Gamma' \der T\xi = V : \Set[\ell]$.

% \item \label{it:out}
%   If\/ $\LR \Gamma t T f A$ then for all $\xi : \Gamma' \leq \Gamma$
%   there is some normal form $v$ such that
%   $\R{\Gamma'} {\down A f} v$ and $\Gamma' \der t\xi = v : T\xi$.

\end{enumerate}
\end{theorem}

\begin{proof*}
We prove the propositions for $A'$ and $T'$ (instead of $A$ and $T$)
simultaneously by induction on $A' \in s$.

\begin{caselist}

\nextcase $A' \evalsto \piT A B$ and $\resurrect\Gamma \der T' = \piT U T$.
\begin{enumerate}
\item
The premise is, after type conversion, $\Gamma \der t \doteq \tRne\, n : \piT U T$.
To demonstrate $\LR \Gamma t {T'} {\up {A'} n} {A'}$ we assume
$\xi : \Gamma' \leq \Gamma$ and $\LR{\Gamma'}{u}{U\xi} a A$ and show
$\LR{\Gamma'} {(t\xi\,u)} {T(\xi,u)} {\up{B[a]}(n\,\down A a)} {B[a]}$.
By induction hypothesis (\ref{it:out}) we have $\RD {\Gamma'} u {\down A a} {U\xi}$, and
together with the weakened premise $\Gamma' \der t\xi \doteq \tRne\, n : (\piT U T) \xi$ we get
$\Gamma' \der t\xi\, u \doteq \tRne\, (n\,\down A a) : T(\xi,u)$.
The goal follows by induction hypothesis (\ref{it:into}) for
% $B[a] \in s$.
$\LRTS{\Gamma'}{T(\xi,u)}{B[a]} s$.
% This follows by induction hypothesis (\ref{it:into}) for $B[a] \in \SET[\ell]$ if
% we can prove that for all $\xi' : \Gamma'' \leq \Gamma'$ there is a neutral normal form $m$
% such that $\RNe{\Gamma''} {(n\,\down A a)} m$ and $\Gamma'' \der (t\xi\,u)\xi' = m : T(\xi,u)\xi'$.
% Note that the last goal can be rewritten to $\Gamma'' \der t\xi\xi'\,(u\xi') = m : T(\xi\xi',u\xi')$.
% We know that $\RNe{\Gamma''} n {m_0}$ with $\Gamma'' \der t\xi\xi' = m_0 : T'\xi\xi'$.
% Thus, it is sufficient to show that there is some normal form $v$ such that
% $\R{\Gamma''} {\down A a} v$ and $\Gamma'' \der u\xi' = v : U\xi\xi'$.
% However, this follows by induction hypothesis (\ref{it:out}) on
% assumption $\LR{\Gamma'}{u}{U\xi} a A$ with $\xi'$.
\qed
\end{enumerate}
\end{caselist}
\end{proof*}

\begin{corollary}[One-to-one]
\label{cor:oneone}
\bla
\begin{enumerate}
\item
If\/ $\LRSize \Gamma a \alpha$ and $\LRSize \Gamma {a'} \alpha$ then $a = a'$.
\item
If\/ $\LRT \Gamma T A \ell$ and $\LRT \Gamma {T'} A {\ell'}$ then $\Gamma \der T = T'$.
\end{enumerate}
\end{corollary}

\begin{corollary}[Fresh variable]
  \label{cor:fresh}
  If\/ $\der \cext \Gamma T$ and %$A \in \SET[\ell]$
  $\RG \Gamma T A$
  then $\LR {\cext \Gamma T} {\ind 0} {(T \slift)} {(\up A \var\Gamma)} A$.
\end{corollary}
\begin{proof}
  Assume $\xi : \Gamma' \leq \cext \Gamma T$.
  Note that for the length
  $i = |\Gamma'| - |\cext \Gamma T|$ of the context extension
  we have $\ind i = \ind 0 \xi$, thus
  $\Gamma' \der \ind 0 \xi = \ind i : T \slift \xi$.
  Since $\RNe{\Gamma'} {\var\Gamma} {\ind i}$,
  the goal follows now from Thm.~\ref{thm:into} part (\ref{it:into}).
\end{proof}


\begin{lemma}[Semantic subtyping implies judgmental subtyping \cite{fridlenderPagano:tlca13}]
\label{lem:lrsub}
\bla
\begin{enumerate}
\item
   If\/ $\LRSize \Gamma a \alpha$ and $\LRSize \Gamma {b} \beta$ and $\alpha \leq \beta$ then $a \leq b$.
\item
   If\/ $\RG \Gamma T A$ and $\RG \Gamma {T'} {A'}$ and $A \leq A' \in \TYPE$ then $\Gamma \der T \leq T'$.
   % If\/ $\LRT \Gamma T A \ell$ and $\LRT \Gamma {T'} {A'} {\ell'}$ and $A \leq A' \in \TYPE$ then $\Gamma \der T \leq T'$.
\end{enumerate}
\end{lemma}
\begin{proof}
  The proof is analogous to the one  for algorithmic subtyping to come (Lemma~\ref{lem:lrasub}).
\end{proof}


\begin{lemma}[Subsumption for the logical relation \cite{fridlenderPagano:tlca13}]
\label{lem:lrsump}
   If\/ $\RG \Gamma T A$ and $\RG \Gamma {T'} {A'}$ and $A \leq A' \in \TYPE$ then
   $\LR \Gamma t T f A$ implies $\LR \Gamma t {T'} f {A'}$.
   % If\/ $\LRT \Gamma T A \ell$ and $\LRT \Gamma {T'} {A'} {\ell'}$ and $A \leq A' \in \TYPE$ then
   % $\LR \Gamma t T f A$ implies $\LR \Gamma t {T'} f {A'}$.
\end{lemma}


Logical relation for substitutions.
\fbox{$\LRSub \Gamma \sigma \tau \Delta \eta \rho$}.
\begin{gather*}
  \ru{\der \Gamma
    }{\LRSub \Gamma {\sempty} {\sempty} {\cempty} {\sempty} {\sempty}}
\qquad
  \ru{\LRSub \Gamma \sigma \tau \Delta \eta \rho \qquad
      \Gamma \der a : \Size \qquad
      \LRSize \Gamma a \alpha
    }{\LRSub \Gamma {(\sigma,a)} {(\tau,a)} {\cext \Delta \Size} {(\eta,\alpha)} {(\rho,\alpha)}}
\\[2ex]
  \ru{\LRSub \Gamma \sigma \tau \Delta \eta \rho \qquad
      \resurrect \Gamma \der a, b : \Size \qquad
      \alpha,\beta \in \SIZE \qquad
      \LRSize {\resurrect\Gamma} b \beta
    }{\LRSub \Gamma {(\sigma,a)} {(\tau,b)} {\erext \Delta \Size} {(\eta,\alpha)} {(\rho,\beta)}}
\\[2ex]
  \ru{\LRSub \Gamma \sigma \tau \Delta \eta \rho \qquad
      \resurrect \Delta \der T \qquad
      \Gamma \der u = t : T\tau \qquad
      \LR \Gamma t {T \tau} f {T \rho} \qquad
      f = g \in T\rho
    }{\LRSub \Gamma {(\sigma,u)} {(\tau,t)} {\cext \Delta T} {(\eta,f)} {(\rho,q)}}
\end{gather*}
We write \fbox{$\LRS \Gamma \tau \Delta \rho$} for $\LRSub \Gamma \tau \tau \Delta \rho \rho$.

\begin{lemma}[Properties of the logical relation for substitution]
  \label{lem:wklrsub}
  Let $\LRSub \Gamma \sigma \tau \Delta \eta \rho$. Then:
  \begin{enumerate}
  \item Well-typedness: $\Gamma \der \sigma : \Delta$
   and $\Gamma \der \sigma = \sigma \eeq \tau : \Delta$
   [which in turn implies $\Gamma \der \tau : \Delta$].
  \item Weakening:
  If\/ $\xi : \Gamma' \leq \Gamma$ then
  $\LRSub{\Gamma'}{\sigma\xi}{\tau\xi}{\Delta}\eta\rho$.
  \item Resurrection:
  $\LRS {\resurrect\Gamma} \tau {\resurrect\Delta} \rho$.
  % $\LRSub {\resurrect\Gamma} \tau \tau {\resurrect\Delta} \rho \rho$.
  \item \label{it:sizesub} Size substitution:
  If\/ $\resurrect\Delta \der a : \Size$ then $a\eta \in \SIZE$.
  \end{enumerate}
\end{lemma}
\LONGVERSION{
\begin{proof}
  For part (\ref{it:sizesub}), the only interesting case $a = \ind i + o$ can be proved by observing that $\eta(i) \in \SIZE$.
\end{proof}
} % END LONGVERSION
% \begin{lemma}[Typing of constructed data]
% \label{lem:invdata} \bla
% If\/ $\Gamma \der c : \Nat b$ then $\resurrect\Gamma \der b : \Size$ and $b > 0$.
% \end{lemma}

Validity judgements.
\[
\begin{array}{l@{\quad}l@{\quad}l}
  \Gamma \valid t : T & \defas & %\valid \Gamma \mand
    % \resurrect\Gamma \valid T \mand
    \valid \cext \Gamma T \mand
    \LR {\Gamma'} {t \sigma} {T \tau} {t \eta} {T \rho}
    \mforall \LRSub {\Gamma'} \sigma \tau \Gamma \eta \rho
\\[1ex]
  \Gamma \valid \sigma_0 : \Delta & \defas &
    \LRSub {\Gamma'} {\sigma_0 \sigma} {\sigma_0 \tau} \Delta {\sigma_0 \eta} {\sigma_0 \rho}
    \mforall \LRSub {\Gamma'} {\sigma} {\tau} \Gamma {\eta} {\rho}
\end{array}
\]

\begin{theorem}[Fundamental theorem of typing]
\label{thm:fundty}
\bla
\begin{enumerate}
\item
If\/ $\Gamma \der t : T$ then $\Gamma \valid t : T$.
\item
If\/ $\Gamma \der \sigma : \Delta$ then
$\Gamma \valid \sigma : \Delta$
\end{enumerate}
\end{theorem}
\begin{proof*}
Each by induction on the derivation.
\SHORTLONG{\qed}{ % LONGVERSION
\begin{caselist}

\nextcase $\forall$-introduction.
\[
  \ru{\erext \Gamma \Size \der t : T
    }{\Gamma \der \lambda t : \forall T}
\]
Assume $\LRSub {\Delta} {\sigma} {\tau} \Gamma {\eta} {\rho}$ and show
$\LR \Delta {(\lambda t)\sigma} {(\forall T)\tau} {(\lambda t)\eta} {(\forall T)\rho}$.
To this end, assume a weakening $\xi : \Delta' \leq \Delta$ and
size expressions % $\Delta' \der a : \Size$ and
$\resurrect{\Delta'} \der a, b : \Size$ and size values $\alpha,\beta$ with
$\LRSize {\resurrect{\Delta'}} b \beta$ and show
$\LR {\Delta'} {(\lambda t)\sigma\xi \ann a} {T(\tau \slift, \ind 0)(\xi,b)} {(\lambda t)\eta \ann \alpha} {T(\rho\slift, \ind 0)[\beta]}$.
It suffices to show (weak head reduction, substitution laws) that
$\LR {\Delta'} {t(\sigma\xi,a)} {T(\tau\xi,b)} {t(\eta,\alpha)} {T(\rho,\beta)}$.
This follows from the induction hypothesis, since
$\LRSub {\Delta'} {(\sigma\xi,a)} {(\tau\xi,b)} {\erext \Gamma \Size} {(\eta,\alpha)} {(\rho,\beta)}$
by Lemma~\ref{lem:wklrsub} and substitution extension.

\nextcase $\forall$-elimination.
\[
  \ru{\Gamma \der t : \forall T \qquad % \Gamma \der a : \Size \qquad
      \resurrect \Gamma \der a,b : \Size
    }{\Gamma \der t \ann a : T[b]}
\]
Assume $\LRSub {\Delta} {\sigma} {\tau} \Gamma {\eta} {\rho}$ and show
$\LR \Delta {t \ann a \sigma} {T[b]\tau} {t \ann a \eta} {T[b]\rho}$.
By induction hypothesis we have $\LR \Delta {t \sigma} {(\forall T)\tau} {t \eta} {(\forall T) \rho}$.
It suffices to show
\begin{enumerate}
\item $\resurrect\Delta \der a\sigma : \Size$: follows from $\resurrect\Gamma \der a : \Size$
  via $\Delta \der \sigma : \Gamma$ and $\resurrect\Delta \der \sigma : \resurrect\Gamma$
  and substitution.
%\item $\resurrect\Delta \der b\tau : \Size$.
\item $a\eta \in \SIZE$: follows from $\resurrect\Gamma \der a : \Size$
  by Lemma~\ref{lem:wklrsub}, part (\ref{it:sizesub}).
%\item $b\rho \in \SIZE$.
\item $\LRSize {\resurrect \Delta} {b\tau} {b\rho}$: follows from induction hypothesis on $\resurrect \Gamma \der b : \Size$ via $\LRSub {\resurrect \Delta} \tau \tau {\resurrect\Gamma} \rho \rho$ (from Lemma~\ref{lem:wklrsub}).
\qed
\end{enumerate}
\end{caselist}
} % END LONGVERSION
\end{proof*}

\begin{lemma}[Identity environment]
  \label{lem:idenv}
  If\/ $\der \Gamma$ then
  $\LRS \Gamma \sid \Gamma \rhog$.
\end{lemma}
\begin{proof*}
  By induction on $\der \Gamma$.
\SHORTLONG{\qed}{ % LONGVERSION
\begin{caselist}

\nextcase
\[
  \ru{\der \Gamma \qquad \resurrect\Gamma \der T
    }{\der \cext \Gamma T}
\]
Let $f = \up{T\rhog} \var\Gamma$.
We have to show $\LRS{\cext \Gamma T} \sid {\cext\Gamma T} {(\rhog, f)}$.
Note that $\sid = (\slift,\ind0)$, thus it remains to show that
$\LRS {\cext \Gamma T} {\slift} \Gamma \rhog$ and
$\LR {\cext \Gamma T} {\ind0} {T\slift} f {T\rhog}$.
The first goal follows by weakening from the induction hypothesis
$\LRS \Gamma \sid \Gamma \rhog$.
%Further, by resurrection we get
%$\LRS {\cext \Gamma T} {\slift} \Gamma \rhog$, and by resurrection
%$\LRS {\cext{\resurrect\Gamma}T}{\slift}{\resurrect\Gamma}\rhog$.
Since $\rhog \in \resurrect\Gamma$, we get $T \rhog \in \SET[\ell]$ for some $\ell$
by the first fundamental theorem (Thm.~\ref{thm:fund}).
Thus, the second goal follows by Cor.~\ref{cor:fresh}.
% Further note that for all $\Gamma' = \cext {\cext \Gamma T} {\Delta}$ and
% $\xi : \Gamma' \leq \cext \Gamma T$ we have that
% $\RNe{\Gamma'} {\var\Gamma} {\ind{|\Gamma'|\monus|\Gamma|}} = {\ind{|\Delta|}}$ and
% $\Gamma' \der \ind 0 \xi = \ind{|\Delta|} : T\xi$.
% This allows us to apply Thm.~\ref{thm:into} to get $\ind0$ into the logical relation as
% $\LR {\cext \Gamma T} {\ind0} T f {T\rhog}$.
\qed
\end{caselist}
} % END LONGVERSION
\end{proof*}

\begin{corollary}[Soundness of NbE]
  \label{cor:soundnbe} \bla
  \begin{enumerate}
  \item \label{it:sound}
  If\/ $\Gamma \der t : T$ then $\Gamma \der t = \nbe \Gamma T t : T$.
  \item
  If\/ $\Gamma \der t,t' : T$ and $\nbe \Gamma T t \equiv \nbe \Gamma T {t'}$ then
  $\Gamma \der t = t' : T$.
  \end{enumerate}
\end{corollary}
\begin{proof*}
\bla
\begin{enumerate}

\item For the identity environment $\LRS \Gamma \sid \Gamma \rhog$ (Lemma~\ref{lem:idenv})
the Fundamental Theorem for Typing gives $\LR \Gamma t T {t\rhog} {T\rhog}$.
This implies $\R \Gamma {\down{(T\rhog)} (t\rhog)} v$ for some normal form $v$ and
$\Gamma \der t = v : T$ by Thm.~\ref{thm:into}.

\item By transitivity of judgmental equality from (\ref{it:sound}).
   Here we use that the computed normal forms are identical because
   we erase all size annotations $\ann\alpha$ to $\ann\infty$ during read back.
\qed
\end{enumerate}
\end{proof*}

\begin{corollary}[Decidability of judgemental equality]
  If\/ $\Gamma \der t,t' : T$ then the test whether $\nbe\Gamma T t \equiv \nbe\Gamma T{t'}$
  terminates and
  decides $\Gamma \der t = t' : T$.
\end{corollary}
\LONGVERSION{
\begin{proof}
  Follows directly from soundness (which includes termination) and completeness of NbE.
\end{proof}
} % END LONGVERSION
For normalization of types, we introduce \fbox{$\Nbe \Gamma T$}
via the relation $\Nbe \Gamma T \evalsto V \defas \RTy \Gamma {T\rhog} V$.
Analogously, we show that the test $\Nbe \Gamma T \equiv \Nbe \Gamma T'$
decides type equality $\Gamma \der T = T'$.

\begin{corollary}[Type weak head normalization]
  If\/ $\Gamma \der T$ then $T \evalsto W$ for some $W$.
\end{corollary}
\LONGVERSION{
\begin{proof}
  By the fundamental theorem of typing, $\RG \Gamma T {T\rhog}$,
  which implies $T \evalsto W$ by definition of the logical relation.
\end{proof}
} % END LONGVERSION
\LONGVERSION{ % BEGIN LONGVERSION
\begin{corollary}[Type constructor injectivity]
\label{cor:piinj}
\bla
\begin{enumerate}
\item \label{it:setinj}
  If\/ $\Gamma \der \Set[\ell] = \Set[\ell'] : s$ then $\ell = \ell'$.
\item \label{it:natinj}
  If\/ $\Gamma \der \Nat a = \Nat b : s$ then $a = b$.
\item \label{it:piinj}
  If\/ $\Gamma \der \piT U T = \piT{U'}{T'} : s$ then
  $\Gamma \der U = U' : s$ and
  $\cext \Gamma U \der T = T' : s$.
\item \label{it:allinj}
  If\/ $\Gamma \der \epiT \Size T = \piT{\Size}{T'} : s$ then
  $\cext \Gamma \Size \der T = T' : s$.
\end{enumerate}
\end{corollary}
\begin{proof}
\bla
Statement (\ref{it:setinj}) follows by inversion on  $\Set[\ell] = \Set[\ell'] \in s$, which is a direct consequence of the fundamental theorem (Thm.~\ref{thm:fund}).

For (\ref{it:natinj}), observe that $\Nat (a\rhog) = \Nat (b\rhog) \in s$
by the fundamental theorem (Thm.~\ref{thm:fund}), which by definition implies $a\rhog = b\rhog$. % \in \SIZE$.
By the fundamental theorem of typing (Thm.~\ref{thm:fundty}), $\LRTS \Gamma {\Nat a} {\Nat (a\rhog)} s$
which by definition implies $\LRSize \Gamma a {a\rhog}$.  Analogously, we get $\LRSize \Gamma b {b\rhog}$.
By Cor.~\ref{cor:oneone}, $a = b$.


Last, we prove statement (\ref{it:piinj}), the last statement follows analogously.
By the fundamental theorem,
$(\piT U T)\rhog = (\piT{U'}{T'})\rhog \in s$ which by definition means
$U\rhog = U'\rhog \in s$ and $T(\rhog,u) = T'(\rhog,u') \in s$ for all $u = u' \in s$.
By reification (Thm.~\ref{thm:rere}),
$\RTy\Gamma {U\rhog} V$ and $\RTy\Gamma {U'\rhog} V$ for some normal form
$V$.
Since by inversion we have $\Gamma \der U,U' : s$ we get $\Gamma \der U = U' : s$ by soundness of NbE.
Now, choosing $u := u' := \up {U\rhog} \var\Gamma \in U$, we obtain
$T\rhogu = T' \rhogu \in s$, which analogously gives us $\cext\Gamma U \der T = T' : s$.
\end{proof}
} % END LONGVERSION
\begin{lemma}[Type constructor discrimination]
  \label{lem:discr}
  Different type constructors are not related by subtyping.  For instance,
  $\Gamma \der \Nat a \leq \piT U T$ and
  $\Gamma \der \erpiT \Size T \leq \piT \Size T'$ are both impossible.
%  There are $4\times4 = 16$ statements of that sort.
  % The following judgments are \emph{not} derivable.
  % \begin{enumerate}
  % \item $\Gamma \der \Nat a \leq \Set[\ell]$ and $\Gamma \der \
  % \end{enumerate}
\end{lemma}
\begin{proof}
  Follows directly by the fundamental theorem (Thm.~\ref{thm:fund}) and inversion on semantic subtyping.
\end{proof}
% \section{Algorithmic Subtyping}
% \label{sec:algosub}



\begin{lemma}[Inversion of subtyping \cite{fridlenderPagano:tlca13}]
\label{lem:invsubty}
\bla
\begin{enumerate}
\item \label{it:setinvsub}
  If\/ $\Gamma \der \Set[\ell] \leq \Set[\ell'] : s$ then $\ell \leq \ell'$.
\item \label{it:natinvsub}
  If\/ $\Gamma \der \Nat a \leq \Nat b : s$ then $a \leq b$.
\item \label{it:piinvsub}
  If\/ $\Gamma \der \piT U T \leq \piT{U'}{T'} : s$ then
  $\Gamma \der U' \leq U : s$ and
  $\cext \Gamma {U'} \der T \leq T' : s$.
\item \label{it:allinvsub}
  If\/ $\Gamma \der \epiT \Size T \leq \piT{\Size}{T'} : s$ then
  $\cext \Gamma \Size \der T \leq T' : s$.
\end{enumerate}
\end{lemma}
\begin{proof}
\LONGVERSION{Similar to the proof of Cor.~\ref{cor:piinj}, using
  Lemma~\ref{lem:lrsub}.} % END LONGVERSION
We recapitulate the proof for (\ref{it:piinvsub}).
By the fundamental theorems, we get
$\RG \Gamma {\piT U T} {(\piT U T)\rhog}$ and
$\RG \Gamma {\piT {U'} {T'}} {(\piT {U'} {T'})\rhog}$ and
${(\piT U T)\rhog} \leq {(\piT {U'} {T'})\rhog} \in \TYPE$.
By inversion, first
$\RG \Gamma U {U\rhog}$ and
$\RG \Gamma {U'} {U'\rhog}$ and
$U'\rhog \leq U\rhog \in \TYPE$ which imply $\Gamma \der U' \leq U$ by Lemma~\ref{lem:lrsub}.
Recall that
$\rhogup = (\rhog, u)$ where
$u = \up{U'\rhog} \var\Gamma \in U'\rhog$ and
$\LR {\cext \Gamma U'} {\ind0} {U'\slift} {u} {U'\rhog}$ by Cor.~\ref{cor:fresh}.
From
$\LRTS {\cext \Gamma U'} T {T(\rhogup)} s$ and
$\LRTS {\cext \Gamma U'} {T'} {T'(\rhogup)} s$ and
$T(\rhogup) \leq T'(\rhogup) \in s$, again by Lemma~\ref{lem:lrsub},
$\cext \Gamma {U'} \der T \leq T' : s$.
\end{proof}

\begin{lemma}[Strong inversion for abstraction]
  \label{lem:invabs}
  \bla
  \begin{enumerate}
  \item   If\/ $\Gamma \der \lambda t : \piT U T$ then
  $\cext \Gamma U \der t : T$.
  \item   If\/ $\Gamma \der \lambda t : \epiT \Size T$ then
  $\eext \Gamma \Size \der t : T$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  By inversion of typing (Lemma~\ref{lem:invty}), type constructor discrimination \label{lem:discr}
  and inversion of subtyping (Lemma~\ref{lem:invsubty}).

  For instance, inversion on $\Gamma \der \lambda t : \piT U T$ gives us $\cext \Gamma {U'} \der t : {T'}$ with $\Gamma \der \piT{U'}{T'} \leq \piT U T$ (the other case, $\epiT \Size T$ is excluded by discrimination).  By inversion of subtyping, $\Gamma \der U \leq U'$ and $\cext \Gamma {U} \der T' \leq T$.  Since $\sid : \cext \Gamma U \leq \cext \Gamma {U'}$, we have $\cext \Gamma U \der t : T'$ by weakening, and our goal follows by subsumption.
\end{proof}

\begin{lemma}[Strong inversion of redexes]
  \label{lem:stronginv}
  \bla
  \begin{enumerate}
  \item   If\/ $\Gamma \der (\lambda t)\,u : T'$ then
  $\cext \Gamma U \der t : T$ and $\Gamma \der u : U$ and $\Gamma \der T[u] \leq T'$
  for some $U,T$.
  \item   If\/ $\Gamma \der (\lambda t)\,a : T'$ then
  $\cext \Gamma \Size \der t : T$ and $\Gamma \der a : \Size$ and $\Gamma \der T[a] \leq T'$
  for some $T$.
  \item \label{it:sinvall}
  If\/ $\Gamma \der (\lambda t)\,\ann a : T'$ then
  $\erext \Gamma \Size \der t : T$ and $\resurrect \Gamma \der a : \Size$ and $\Gamma \der T[a] \leq T'$
  for some $T$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  For (\ref{it:sinvall}), from $\Gamma \der (\lambda t) \ann a : T'$ we get $\Gamma \der \lambda t : \forall T$ and $\resurrect \Gamma \der a,b : \Size$ and $\Gamma \der T[b] \leq T'$.  Strong inversion for abstraction gives us $\erext \Gamma \Size \der t : T$.  Since $\Gamma \der [a] = [a] \eeq [b] : \erext \Gamma \Size$,  the substitution lemma yields
$\Gamma \der t[a] : T[b]$, thus $\Gamma \der t[a] : T'$ by subsumption.
\end{proof}

\begin{theorem}[Subject reduction]
  \label{thm:sr}
  \bla
  \begin{enumerate}
  \item
  If\/ $\DD :: \Gamma \der t : T$ and $\DD' :: t \evalsto w$ then $\Gamma \der t = w : T$.
  \item
  If\/ $\DD :: \Gamma \der w\, e : T$ and $\DD' :: w @ e \evalsto w'$ then $\Gamma \der w\,e = w : T$.
  \end{enumerate}
\end{theorem}
\begin{proof}
  Simultaneously by induction on $\DD'$
  % By induction on $t \evalsto w$,
  using inversion (Lemma~\ref{lem:invty}) and strong inversion (Lemma~\ref{lem:stronginv})
  on the typing derivation $\DD$. % $\Gamma \der t : T$.
\end{proof}

\section{Algorithmic Subtyping}
\label{sec:asub}

Algorithmic subtyping \fbox{$\Gamma \der T \asub T'$}.
\begin{gather*}
  \ru{T \evalsto n \qquad
      T' \evalsto n' \qquad
      \Nbe \Gamma n \equiv \Nbe \Gamma n'
    }{\Gamma \der T \asub T'}
\\[2ex]
  \rux{T \evalsto \Set[\ell] \qquad
      T' \evalsto \Set[\ell']
    }{\Gamma \der T \asub T'
    }{\ell \leq \ell'}
\qquad
  \ru{T_1' \evalsto \piT{U_1}{T_1} \qquad
      T_2' \evalsto \piT{U_2}{T_2} \qquad
      \Gamma \der U_2 \asub U_1 \qquad
      \cext \Gamma {U_2} \der T_1 \asub T_2
    }{\Gamma \der T_1' \asub T_2'}
\\[2ex]
  \ru{T \evalsto \Nat a \qquad
      T' \evalsto \Nat a'
    }{\Gamma \der T \asub T'
    }{a \leq a'}
\qquad
  \ru{T_1' \evalsto \epiT\Size{T_1} \qquad
      T_2' \evalsto \epiT\Size{T_2} \qquad
      \cext \Gamma {\Size} \der T_1 \asub T_2
    }{\Gamma \der T_1' \asub T_2'}
\end{gather*}

\begin{lemma}[Soundness of algorithmic subtyping]
  \label{lem:asubsound}
  If\/ $\Gamma \der T \asub T'$ then $\Gamma \der T \leq T'$.
\end{lemma}
\begin{proof}
  By induction on $\Gamma \der T \asub T'$, using soundness of NbE and subject reduction (Thm.~\ref{thm:sr}).
\end{proof}

\begin{lemma}[Semantic subtyping implies algorithmic subtyping]
\label{lem:lrasub}
\bla
   If\/ $\RG \Gamma T A$ and $\RG \Gamma {T'} {A'}$ and $A \leq A' \in \TYPE$ then $\Gamma \der T \asub T'$.
\end{lemma}
\begin{proof*}
By induction on % $A_1' \in s_1$ and $A_2' \in s_2$ and cases on the inductive relations
$\LRTS \Gamma {T_1'} {A_1'} {s_1}$ and $\LRTS \Gamma {T_2'} {A_2'} {s_2}$
and cases on $A_1' \leq A_2' \in \TYPE$
we prove $\Gamma \der T_1' \asub T_2'$.

\begin{caselist}

\nextcase $A_i' \evalsto N_i$ and $T_i' \evalsto n_i$ and $N_1 = N_2 \in \NE$ and $\RTY \Gamma {n_i} {N_i} {s_i}$.
By Cor.~\ref{cor:oneone} $\Gamma \der n_1 = n_2$, thus, by completeness of NbE, $\Nbe\Gamma n_1 \equiv \Nbe\Gamma n_2$, which entails $\Gamma \der T_1' \asub T_2'$.

\nextcase $A_i' \evalsto \piT {A_i} {B_i}$ and  $T_i' \evalsto \piT{U_i}{T_i}$.
From $\LRTS \Gamma {U_i} {A_i} {s_i}$ and $A_2 \leq A_1 \in \TYPE$ we get $\Gamma \der U_2 \asub U_1$
by induction hypothesis on $A_i \in s_i$.
Let $a := {\up{A_2} \var\Gamma}$.  With $\LR {\cext \Gamma {U_2}} {\ind 0} {(U_2\slift)} a {A_2}$ we get
$\LRTS {\cext \Gamma {U_2}} {T_i} {B_i[a]} s$ and $B_1[a] \leq B_2[a] \in \TYPE$.  Thus by induction hypothesis on $B_i[a] \in s_i$ we obtain $\cext \Gamma {U_2} \der T_1 \leq T_2$, together $\Gamma \der T_1' \asub T_2'$.
\qed
\end{caselist}
\end{proof*}

\begin{corollary}[Completeness of algorithmic subtyping]
\label{cor:complasub}
If\/ $\Gamma \der T \leq T'$ then $\Gamma \der T \asub T'$.
\end{corollary}
\begin{proof}
  By the fundamental theorems $\RG \Gamma T {T\rhog}$ and $\RG \Gamma {T'} {T'\rhog}$ and $T\rhog \leq T'\rhog \in \TYPE$.
  By Lemma~\ref{lem:lrasub}, $\Gamma \der T \asub T'$.
\end{proof}

Since the algorithmic subtyping relation is equivalent to the declarative one, we can freely swap one relation for the other.

\begin{lemma}[Termination of algorithmic subtyping]
  \label{lem:termasub}
  If\/ $\RG \Gamma T A$ and $\RG \Gamma {T'} {A'}$ then the query $\Gamma \der T \asub T'$ terminates.
\end{lemma}
\begin{proof}
  By induction on $A \in s$ and $A' \in s'$ and cases on $\RG \Gamma T A$ and $\RG \Gamma {T'} {A'}$.
\end{proof}

\begin{theorem}[Decidability of subtyping]
  If\/ $\Gamma \der T,T'$, then $\Gamma \der T \leq T'$ is decided by the query $\Gamma \der T \asub T'$.
\end{theorem}
\begin{proof}
  By the fundamental theorem of typing, $\RG \Gamma T A$ and $\RG \Gamma {T'} {A'}$,
  thus, the query  $\Gamma \der T \asub T'$ terminates by Lemma~\ref{lem:termasub}.
  If successfully, then $\Gamma \der T \leq T'$ by soundness of algorithmic equality.
  If unsuccessfully, then $\Gamma \der T \leq T'$ is impossible by completeness of algorithmic equality.
\end{proof}


\section{Type Checking}
\label{sec:tycheck}

In this section, we show that type checking for normal forms is decidable, and succeeds for those which can be type via the restricted rule for size polymorphism elimination:
\[
  \ru{\Gamma \ders t : \forall T \qquad
      \resurrect\Gamma \der a : \Size
    }{\Gamma \ders t\, \ann a : T[a]}
\]
We will refer to the restricted typing judgement as \fbox{$\Gamma \ders t : T$}, and obviously,
if\/ $\Gamma \ders t : T$ then $\Gamma \der t : T$.

Bidirectional typing of normal forms.

Checking \fbox{$\Gamma \der t \jchk T$}.
\begin{gather*}
  \ru{T' \evalsto s \qquad
      \Gamma \der a : \Size
    }{\Gamma \der \Nat a \jchk T'}
\qquad
  \ru{T' \evalsto \Set[\ell'] \qquad \ell < \ell'
    }{\Gamma \der \Set[\ell] \jchk T'}
\\[2ex]
  \ru{T' \evalsto s \qquad
      \Gamma \der U \jchk s \qquad
      \cext \Gamma U \der T \jchk s
    }{\Gamma \der \piT U T \jchk T'}
\qquad
  \ru{T' \evalsto s \qquad
      \cext \Gamma \Size \der T \jchk s
    }{\Gamma \der \epiT \Size T \jchk T'}
%\\[2ex]
%   \ru{T' \evalsto \piT U T \qquad
%       \cext \Gamma U \der t \jchk T
%     }{\Gamma \der \lambda t \jchk T'}
% \qquad
%   \ru{T' \evalsto \epiT \Size T \qquad
%       \eext \Gamma \Size \der t \jchk T
%     }{\Gamma \der \lambda t \jchk T'}
\\[2ex]
  \ru{T' \evalsto \Nat b \qquad
      \resurrect \Gamma \der a+1 \leq b : \Size
    }{\Gamma \der \zero a \jchk T'}
\qquad
  \ru{T' \evalsto \Nat b \qquad
      \resurrect \Gamma \der a+1 \leq b : \Size \qquad
      \Gamma \der t \jchk \Nat a
    }{\Gamma \der \suc a t \jchk T'}
\\[2ex]
  \ru{T' \evalsto \epiT U T \qquad
      \eext \Gamma U \der t \jchk T
    }{\Gamma \der \lambda t \jchk T'}
\qquad
  \ru{\Gamma \der t \jinf T \qquad \Gamma \der T \asub T'
    }{\Gamma \der t \jchk T'}
\end{gather*}

Inference \fbox{$\Gamma \der t \jinf T$}.
\begin{gather*}
  \ru{\Gamma(i) = \erann[\noterased] T
    }{\Gamma \der \ind i \jinf T}
\qquad
  \ru{\Gamma \der t \jinf T' \qquad
      T' \evalsto \piT U T \qquad
      \Gamma \der u \jchk U
    }{\Gamma \der t\, u \jinf T[u]}
\\[2ex]
  \ru{\Gamma \der t \jinf T' \qquad
      T' \evalsto \piT \Size T \qquad
      \Gamma \der a : \Size
    }{\Gamma \der t\,a \jinf T[a]}
\qquad
  \ru{\Gamma \der t \jinf T' \qquad
      T' \evalsto \erpiT \Size T \qquad
      \resurrect\Gamma \der a : \Size
    }{\Gamma \der t\,\ann a \jinf T[a]}
\\[2ex]
  \ru{\Gamma \der u \jinf \Nat (a+1) \qquad
      \Gamma \der T \jchk \Nat (a+1) \to \Set[\ell] \qquad
      \Gamma \der t_z \jchk T\,(\zero a) \qquad
      \Gamma \der t_s \jchk \funT x {\Nat a} {T\,(\suc a x)}
    }{\Gamma \der u\, \case[\ell] T {t_z} {t_s} \jinf T\,u}
\\[2ex]
  \ru{\Gamma \der u \jinf \Nat a \qquad
      \Gamma \der T \jchk \FixK\,\ell \qquad
      \Gamma \der t \jchk \FixT\,T
    }{\Gamma \der u\, \fix[\ell] T t \jinf T\,a\,u}
\end{gather*}

We could go beyond normal forms, by adding inference rules for the $\Nat$-constructors:
\begin{gather*}
  \ru{\resurrect \Gamma \der a : \Size
    }{\Gamma \der \zero a \jinf \Nat(a+1)}
\qquad
  \ru{\resurrect \Gamma \der a : \Size \qquad
      \Gamma \der t \jchk \Nat a
    }{\Gamma \der \suc a t \jinf \Nat(a+1)}
\end{gather*}

\begin{theorem}[Soundness of type checking]
  Let $\der \Gamma$.
  \begin{enumerate}
  \item If\/ $\resurrect\Gamma \der T$ and $\DD :: \Gamma \der t \jchk T$ then $\Gamma \ders t : T$.
  \item If\/ $\DD :: \Gamma \der t \jinf T$ then $\resurrect\Gamma \der T$ and $\Gamma \ders t : T$.
  \end{enumerate}
\end{theorem}
\begin{proof}
  Simultaneously by induction on $\DD$, using subject reduction (Thm.~\ref{thm:sr})
  and soundness of algorithmic subtyping (Lemma~\ref{lem:asubsound}).
\end{proof}

\begin{lemma}[Weak head reduction of subtypes]
\label{lem:whdsub}
Let $\DD :: \Gamma \der T \asub T'$.
\begin{enumerate}
\item If\/ $T' \evalsto \Nat a'$ then $T \evalsto \Nat a$ and $\Gamma \der a \asub a' : \Size$.
\item If\/ $T' \evalsto \Set[\ell']$ then $T \evalsto \Set[\ell]$ and $\ell \asub \ell'$.
\item If\/ $T' \evalsto \piT{A'}{B'}$ then $T \evalsto \piT {A} {B}$ and
      $\Gamma \der A' \asub A$ and $\cext \Gamma {A'} \der B \asub B'$.
\item If\/ $T' \evalsto \epiT \Size {B'}$ and $T \evalsto \epiT \Size B$ and $\cext \Gamma \Size \der B \asub B'$.
\end{enumerate}
\end{lemma}
\begin{proof}
  By cases on $\DD$, since weak head evaluation is deterministic.
\end{proof}
\begin{lemma}[Weak head reduction of supertypes]
\label{lem:whdsuper}
Let $\DD :: \Gamma \der T \asub T'$.
\begin{enumerate}
\item If\/ $T \evalsto \Nat a$ then $T' \evalsto \Nat a'$ and $\Gamma \der a \asub a' : \Size$.
\item If\/ $T \evalsto \Set[\ell]$ then $T' \evalsto \Set[\ell']$ and $\ell \asub \ell'$.
\item If\/ $T \evalsto \piT A B$ then $T' \evalsto \piT {A'} {B'}$ and
      $\Gamma \der A' \asub A$ and $\cext \Gamma {A'} \der B \asub B'$.
\item If\/ $T \evalsto \epiT \Size B$ and $T' \evalsto \epiT \Size B'$ and $\cext \Gamma \Size \der B \asub B'$.
\end{enumerate}
\end{lemma}
\begin{proof}
  By cases on $\DD$, since weak head evaluation is deterministic.
\end{proof}
\begin{lemma}[Subsumption for type checking]
  \label{lem:subtc}
  Let $\sid : \Gamma' \leq \Gamma$.
  \begin{enumerate}
  \item If\/ $\DD :: \Gamma \der t \jchk T$ and $\resurrect\Gamma \der T \leq T'$ then $\Gamma' \der t \jchk T'$.
  \item If\/ $\DD :: \Gamma \der t \jinf T$ then $\Gamma' \der t \jinf T'$ and $\resurrect{\Gamma'} \der T \leq T'$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  Simultaneously by induction on $\DD$, using % weak head normalization of types,
  lemmata \ref{lem:whdsub} and \ref{lem:whdsuper},
  and soundness and completeness of algorithmic subtyping.
\end{proof}
\begin{theorem}[Completeness of type checking for normal terms]
\bla
\begin{enumerate}
\item If\/ $\DD :: \Gamma \ders v : T$ then $\Gamma \der v \jchk T$.
\item If\/ $\DD :: \Gamma \ders m : T$ then $\Gamma \der m \jinf U$ and $\resurrect\Gamma \der U \leq T$.
\end{enumerate}
\end{theorem}
\begin{proof}
Simultaneously by induction on $\DD$, using (strong) inversion and Lemma~\ref{lem:subtc}.
\end{proof}

\begin{lemma}[Termination of type checking]
  Let $\der \Gamma$.
  \begin{enumerate}
  \item The query $\Gamma \der t \jinf \mbox{?}$ terminates.
  \item If\/ $\resurrect\Gamma \der T$ then the query $\Gamma \der t \jchk T$ terminates.
  \end{enumerate}
\end{lemma}
\begin{proof}
  By induction on $t$, using type weak head normalization and soundness of type checking, to maintain well-formedness of types.
  And, of course, decidability of subtyping.
\end{proof}

\begin{theorem}[Decidability of type checking for normal terms]
  Let $\der \Gamma$ and $\resurrect \Gamma \der T$.
  Then $\Gamma \ders v : T$ is decided by $\Gamma \der v \jchk T$.
\end{theorem}


\section{Discussion and Conclusions}
\label{sec:concl}

In this article, we have described the first successful integration of higher-rank size polymorphism into a core type theory with dependent function types, a sized type of natural numbers, a predicative hierarchy of universes, subtyping, and $\eta$-equality.  This is an important stepping stone for the smooth integration of sized types into dependently-typed proof assistants.
In the final paragraphs, we discuss some questions and insights that follow from our work and go beyond it.

It is now straightforward to add a unit type $\One$ with extensional equality $t = {*} : \One$ for all $t : \One$.  We simply extend reification such that $\down\One a = {*}$.  Further, $\One$ is a new type shape with rule $\One \shape \One$.

Reification erases all irrelevant size arguments to $\infty$.  We have also considered to keep the sizes there, and define equality $v \approx v'$ of normal forms up to differences in erased arguments.  However, it seems difficult to prove that equal normal forms are judgmentally equal, \ie, that $\Gamma \der v,v' : T$ and $v \approx v'$ imply $\Gamma \der v = v' : T$.  Proving this statement seems to be the key to an incremental equality check; but
the usual bidirectional argument \cite{abelScherer:types10} does not seem to go through as we lack uniqueness of types.
In the long run, we wish for an incremental type-directed equality check, which is also at the heart of Agda's type checker, as this check can generate constraints for meta variables involved in type reconstruction \cite{norell:PhD}.

For now, we have only exploited shape-irrelevance of sized types, but this directly extends to universe levels.  If we consider all universes as a single shape $\Set[\ell_1] \shape \Set[\ell_2]$, we can quantify over levels irrelevantly, as $\Set$ is a shape-irrelevant type constructor.  This is a stepping stone for integrating universe cumulativity with Agda's explicit universe-polymorphism.  If levels are no longer unique (because of subsumption), they will get in the way of proofs, analogously to sizes.  With an irrelevant quantifier we can ignore levels where they do not matter.  We will still respect them where they matter, thus, we keep consistency.

Our reflections on level irrelevance lead us to the question: can a type theory $T$ with a stratified universe hierarchy be understood as a sort of refinement of the inconsistent System~$U$ (Type:Type)?  Intuitively, when checking two terms of $T$ for equality, could we ignore the stratification in the type $A$ which directs the equality check (thus, consider $A$ coming from $U$)?
Such a perspective would put stratification in one pot with size assignment:  Size annotations and levels are both just annotations for the termination checker, but do not bear semantic relevance.  We could switch the universe checker temporarily off as we do with the termination checker---cf.\ the work of \citet{stumpSjobergWeirich:par10} on \emph{termination casts}.

Finally, we would like a general theory of shape-irrelevance that extends beyond size-indexed types.  For instance, any data type constructor could be considered shape-irrelevant in all its parameters.  However, the current reification algorithm which erases irrelevant size arguments to $\infty$ would need some patching.  \citet{abelCoquandPagano:lmcs11} erase all proofs of a proposition $P$ to a canonical element $\star$ which inhabits any proposition $P$ that is already inhabited.  A similar technique could work in our setting and would be necessary unless we can justify the incremental equality check (see above).






%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  Swedish Research Council (Vetenskapsr\aa{}det)
  under Grant
  No.~621-2014-4864 \emph{Termination Certificates for Dependently-Typed Programs and Proofs via Refinement Types}.
  The first author is grateful for recent discussions with Thierry Coquand, Nils Anders Danielsson, and Sandro Stucki
  which helped clarifying the thoughts leading to this work.
  He also acknowledges past discussions with Christoph-Simon Senjak.
\end{acks}


%% Bibliography
\bibliography{auto-icfp17}


% %% Appendix
% \appendix
% \section{Appendix}

% Text of appendix \ldots

\end{document}
